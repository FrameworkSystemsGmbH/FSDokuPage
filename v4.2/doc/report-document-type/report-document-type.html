<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Report Document Type </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Report Document Type ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/fs-docfx.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="report-document-type">Report Document Type</h1>

<p><strong>Report Document Types</strong> stellen die Verbindung zwischen den Components und den Reports dar. Sie definieren, was für Daten in welchem Report ausgegeben werden. Ein Report Document Type enthält eine Angabe, welche Components ausgedruckt werden sollen und welche Reports dafür zur Verfügung stehen. Diese <strong>Report Document Types</strong> können später in Forms verwendet werden.</p>
<p><strong>Report-Document Types</strong> sind an dem <img src="media/report-icon.png" alt="rpt-icon">– Icon zu erkennen.</p>
<h2 id="erstellen-bearbeiten-und-löschen-von-report-document-types">Erstellen, bearbeiten und löschen von Report Document Types</h2>
<p>Sie erstellen einen neuen Report Document Type, indem Sie in der Registerkarte <strong>Namespaces</strong> den Namespace auswählen, in dem der Report Document Type abgelegt werden soll.</p>
<p>Mit dem Button <img src="../media/button-new.png" alt="new-button">(<strong>New</strong>) und dem Eintrag <strong>ReportDocuemtType</strong> aus dem Menü wird im markierten Namespace ein neuer Report Document Type angelegt. Dieser wird auch gleich geöffnet. Direkt nach dem Anlegen des Report Document Types steht der Cursor in dem sich öffnenden Designer auf dem Feld <strong>Name</strong>, wo Sie gleich den Namen eingeben können.</p>
<p>Es wird empfohlen, den Namen mit <strong>rpt</strong> zu beginnen.</p>
<p>Löschen können Sie einen Report Document Type mit dem Button <img src="../media/button-delete.png" alt="delete-button"> (<strong>Delete</strong>). Sie müssen dazu den gewünschten Report Document Type im Namespace-Baum markiert haben. Es gibt auch im Kontext-Menü den Eintrag <strong>Delete</strong>. Der Löschvorgang wird erst im Repository wirksam, wenn Sie den Button <img src="../media/button-save-all.png" alt="saveall-button"> (<strong>Save All</strong>) drücken.
 </p>
<h2 id="datasource">DataSource</h2>
<p>Unter Datasource werden die Components angegeben, die in einem Report ausgegeben werden sollen. Es ist möglich, mehrere Components (Collections) aus unterschiedlichen Namespaces einzubinden.</p>
<p>Jede Component wiederum kann für mehrere Reports als Datasource angegeben werden.</p>
<p><strong>Report Document Type – Registerkarte DataSource:</strong>
<img src="media/report-document-type-data-source.png" alt="Report Document Type – Registerkarte DataSource"></p>
<p>Mit dem Button <strong>Add</strong> wird ein neuer Eintrag in der Liste erstellt. In der Combobox <strong>Datatype</strong> können Sie angeben, welche Component / Collection verwendet werden soll. Im Feld <strong>Name</strong> können Sie dem Eintrag einen Namen geben. Dieser wird anhand des ausgewählten Datentyps mit einem Standard-Namen vorbelegt.</p>
<p>Diese Einträge sind sozusagen die Properties des Reports. Diese Properties müssen später beim Druck mit Werten gefüllt werden.</p>
<p>Wenn Sie Components oder Collections eingebunden haben, können Sie die Properties aufklappen und die Properties der Component / Collection werden angeboten. Sind dies wiederum Components, können diese wiederum aufgeklappt werden.</p>
<p>In diesem Baum können Sie angeben, welche Properties an den Report übergeben werden sollen. Dazu müssen Sie die Checkbox an dem entsprechenden Eintrag setzen.</p>
<p>Aus diesen Daten wird eine XSD-Datei (XML-Definition) erstellt. Diese XSD-Datei kann einem Crystal-Report zugewiesen werden. So versteht der Report die Daten, die ihm übergeben werden. Mit jedem Klick im Baum wird die XSD-Datei neu erzeugt. Sie wird im Report-Pfad der aktuellen Applikation abgelegt. Und bekommt folgenden Namen: Namespaces.rptXXX.xsd.</p>
<p>Zum Einstellen des Pfades siehe Kapitel <strong>Code-Builder / Applications</strong> (<a href="../ide/application.html">Application</a>).</p>
<p>Beim Druck werden die kompletten Components / Collections an den ReportDocmentType übergeben. Es werden aber nur die ausgewählten Daten weitergegeben. Umso größer die Listen, desto wichtiger ist es, dass nur die Daten übergeben werden, die wirklich benötigt werden.</p>
<p>Aus den Daten wird XML erzeugt. Dieses wird dann Crystal Reports übergeben, wo die Daten entsprechend aufbereitet und ausgegeben werden.</p>
<h2 id="crystal-reports">Crystal Reports</h2>
<p>Auf der Registerkarte Crystal Reports können dem Report Document Type mehrere Reports zugewiesen werden.</p>
<p>Report Document Type – Crystal Reports:
<img src="media/report-document-type-crystal-reports.png" alt="Report Document Type – Crystal Reports"></p>
<p>Einen neuen Report fügen Sie beispielsweise über das Kontextmenü der Tabelle hinzu, in der die Reports angezeigt werden.</p>
<p>Mit der Checkbox <strong>Include Base Reports</strong> legen Sie fest, ob vererbte, nicht geänderte Basisreports später in der Applikation zur Auswahl stehen sollen.</p>
<p>Die folgenden Einstellungen beziehen sich auf den in der Tabelle ausgewählten Report:</p>
<p>Im Feld <strong>Name</strong> kann dem Report ein Name gegeben werden.</p>
<div class="WARNING"><h5>Warning</h5><p>Dieser Name darf keine Leer- und Sonderzeichen enthalten, weil dieser später im Code zum Einsatz kommt. </p>
</div>
<p>Im Feld <strong>File</strong> kann ein vorhandener Report geöffnet und eingebunden werden. Dieser Report muss als Datenquelle das erzeugte XSD-File besitzen.</p>
<p>Mit dem Button <strong>Edit Report</strong> wird der Report über ein externes Tool bearbeitet.</p>
<div class="WARNING"><h5>Warning</h5><p>Zum Erstellen und Editieren von Reports benötigen Sie Crystal Reports oder Visual Studio.</p>
</div>
<p>Mit dem Button <strong>New Report</strong> wird ein neuer Report zugewiesen.</p>
<p>Der Button <strong>Choose Report</strong> öffnet einen Dateiauswahl Dialog, in dem Sie einen neuen, bereits existierenden Report zuweisen können.</p>
<h4 id="caption">Caption</h4>
<p>Im Report Document Type können Sie für Crystal Reports lokalisierte Bezeichnungen (Captions) hinterlegen, also die Bezeichnung mehrsprachig pflegen. Diese Captions können zur Laufzeit ausgewertet werden, um z.B. im Druck-Dialog bei der Auswahl der unterschiedlichen Report-Varianten einen sprechenden Text auszugeben.</p>
<h2 id="crystal-report-mit-visual-studio-erstellen">Crystal Report mit Visual Studio erstellen</h2>
<p>Öffnen Sie Visual Studio.</p>
<p>Legen Sie jetzt ein neues Projekt an (Visual C# Project / leeres Projekt oder empty Project) oder öffnen Sie ein bereits vorhandenes Projekt.</p>
<p>Es empfiehlt sich, ein Projekt zur Erstellung und Pflege von Reports anzulegen und dieses immer wieder zu verwenden.</p>
<p><img src="media/report-document-type-rpt-vs-additem.png" alt="Menu Project / Add New Item"></p>
<p><strong>Crystal Report</strong> auswählen und <strong>Open</strong> drücken.</p>
<p>Es öffnet sich ein Wizard zum Erstellen eines <strong>Crystal Reports</strong>.</p>
<p><strong>Crystal Report Gallery:</strong></p>
<p><img src="media/report-document-type-crystal-reports-galery.png" alt="Crystal Report Gallery"></p>
<p>Auf <strong>OK</strong> drücken.</p>
<p><strong>Standard Report Expert Registerkarte Data:</strong></p>
<p><img src="media/report-document-type-standard-report-expert.png" alt="Standard Report Expert Registerkarte Data"></p>
<p>In diesem Fenster wählen Sie den Eintrag <strong>Database Files</strong> aus. Es öffnet sich ein Datei-Auswahl-Dialog. Hier wählen Sie die von <strong>Framework Studio</strong> generierte XSD-Datei aus. Diese Datei befindet sich in dem Report Directory, der in Applications angegeben wurde.</p>
<p>Unter <strong>Database Files</strong> wird die XSD-Datei und darunter die darin enthaltenen Tabellen angezeigt. Jede im Report Document Type eingebundene Component wird als eine Tabelle angeboten und bekommt den Namen, den Sie angegeben haben. Ist in einer Component eine andere Component enthalten und wurde diese ebenfalls ausgewählt, wird diese als eigenständige Tabelle angeboten.</p>
<p>Sie können nun die gewünschten Tabellen mit einem Doppelklick auswählen. Sie werden dann in die rechte Listbox eingetragen.</p>
<p>Mit <strong>Next</strong> öffnet sich die Registerkarte, in dem Sie die Felder auswählen können, die der Report anzeigen soll.</p>
<p><img src="media/report-document-type-standard-report-expert-fields.png" alt="Standard Report Expert Registerkarte Fields"></p>
<p>Wählen Sie die gewünschten Felder mit Doppelklick oder <strong>Add</strong> aus. Mit den Pfeilen über der Liste, mit den ausgewählten Feldern, können Sie noch die Reihenfolge der Felder ändern.</p>
<p>Mit <strong>Next</strong> öffnen sich weitere Fenster, in denen Sie Gruppierungen, Summen, Layouts und weitere Einstellungen vornehmen können.</p>
<p>Mit <strong>Finish</strong> wird der Report erzeugt.</p>
<h2 id="crystal-report-mit-visual-studio-aktualisieren">Crystal Report mit Visual Studio aktualisieren</h2>
<p>Wenn Sie in DataSource Components oder Properties hinzufügen oder entfernen, ändert sich die Schnittstelle zum Report und somit auch die XSD-Datei. Dann ist es notwendig, dass diese Änderung dem Report mitgeteilt wird.</p>
<p>Dazu öffnen Sie wieder Visual Studio, legen ein leeres Projekt an oder öffnen Ihr Crystal-Reports-Projekt. Am besten fügen Sie zum Projekt den Report aus dem Report-Verzeichnis von Framework Studio hinzu. (Menu Project / Add Existing Item)</p>
<div class="WARNING"><h5>Warning</h5><p>Achtung: als Dateityp geben Sie Crystal Reports an.</p>
</div>
<p>Rufen Sie im Field-Explorer bei Database Fields Verify Database auf.</p>
<p><strong>Project2 – Microsoft Visual C#.NET [design] – Customer1.rpt</strong>*
<img src="media/report-document-type-rptcusto-vs-design.png" alt="rpt-design"></p>
<p>Wenn die XSD-Dateien nicht gefunden werden, fragt <strong>Visual Studio</strong> nach, wo diese zu finden sind.</p>
<p>Es werden jetzt die neuen Felder hinzugefügt und die entfernten Felder gelöscht. Das Löschen kann ggf. zu Fehlermeldungen führen.</p>
<p>Wenn Sie neue Components eingebunden haben, können diese mit dem Befehl <strong>Add/Remove Database</strong> manuell hinzugefügt werden.</p>
<h2 id="die-klasse-reportdocument">Die Klasse ReportDocument</h2>
<p>Diese Klasse ist die Basis-Klasse aller Reports, die mit Framework-Studio entwickelt werden.</p>
<p>Es folgt eine Beschreibung der allgemeinen Properties und Methoden, die jeder Report besitzt.</p>
<h3 id="properties">Properties</h3>
<h4 id="reports-static">Reports (static)</h4>
<p>Eine Klasse, die alle, im Report-Document-Type definierten Crystal Reports, als Properties beinhaltet.</p>
<p>Verwenden dieser Klasse:</p>
<p>bei der Instanziierung des Reports</p>
<pre><code class="lang-csharp">rptReport myRptReport = new rptReport( this.Global, rptReport.Reports.SpecialReport1, ExportFormat.PDF );
</code></pre><p>nachträglich setzen</p>
<pre><code class="lang-csharp">myRptReport.SelectedReport = rptReport.Reports.SpecialReport2;
</code></pre><p>Auslesen der Informationen, um diese zum Beispiel in einer Auswahl anzubieten. Das erfolgt mithilfe von Reflection:</p>
<pre><code class="lang-csharp">System.Type T = rptDocumentP.GetType().GetNestedType &quot;Reports&quot;);
System.Reflection.FieldInfo [] Fields = T.GetFields
    (System.Reflection.BindingFlags.Static |System.Reflection.BindingFlags.Public);

foreach (System.Reflection.FieldInfo F in Fields)
{
    // den Namen auslesen
    String sName  = F.Name;
    // Das object auslesen, um es später dem SelectedReport-Property zuzuweisen.
    Object oReportType = F.GetValue (null) as
        FrameworkSystems.FrameworkBase.Reporting.ReportEnum;
}
</code></pre><p>Siehe auch: <a href="#crystal-reports">Crystal Reports</a></p>
<h4 id="useoldlogic-get-set-static">UseOldLogic {get; set} (static)</h4>
<p>Dieses boolsche Property aktiviert eine alte Logik, bei der die Reports komplett im Print-Server oder in der ReportGenerator.aspx verarbeitet werden.</p>
<p>Mit der neuen Logik werden mehr Verarbeitungs-Schritte direkt in der Broker-Logik durchgeführt. So werden die Daten nicht mehr als separates XML verarbeitet, sondern direkt in die Report-Datei hineingegeben und bei der Anzeige von Reports generiert der Broker schon das fertige PDF. Falls es dadurch zu Komplikationen kommt, können Sie mit diesem Schalter auf alte Logik umschalten.</p>
<p>Dieses Property ist statisch. Eine Änderung wirkt sich somit auf den kompletten Broker aus.</p>
<h4 id="selectedreport">SelectedReport</h4>
<p>Der aktuell ausgewählte Report. Die vorhandenen Reports können über das Statische Property Reports ermittelt werden.</p>
<p>Siehe <a href="#properties">Properties</a></p>
<h4 id="exportformat">ExportFormat</h4>
<p>Das Format, in dem der Report ausgegeben werden soll.</p>
<p>Diese Einstellung wird ignoriert, wenn der Report auf einem Drucker ausgegeben werden soll.</p>
<p>Es gibt folgende Typen:</p>
<ul>
<li>RichText</li>
<li>Word</li>
<li>Excel</li>
<li>PDF</li>
<li>Html32</li>
<li>Html40</li>
</ul>
<p>Verwenden des Properties:</p>
<p>bei der Instanziierung des Reports</p>
<pre><code class="lang-csharp">rptReport myRptReport = 
    new rptReport( this.Global, rptReport.Reports.SpecialReport1, ExportFormat.PDF );
</code></pre><p>nachträglich setzen</p>
<pre><code class="lang-csharp">myRptReport.ExportFormat = ExportFormat.Html40;
</code></pre><h4 id="xsdfilename">XSDFileName</h4>
<p>Gibt den Namen der XSD-Datei zurück, die verwendet wird.</p>
<h4 id="reportdir">ReportDir</h4>
<p>Gibt den Namen des Dateiordners zurück, in dem die Crystal Reports abgelegt sind.</p>
<h4 id="cachecrystalreport-get-set">CacheCrystalReport {get; set}</h4>
<p>Dieses boolsche Property gibt an, ob der CrystalReport zwischengespeichert werden soll, der mit der Methode ExportReport erzeugt wird.</p>
<p>Wenn ein Report mehrfach verarbeitet werden soll, dann erhöht dieser Schalter die Performance, da der Report nur einmal geladen und mit Daten befüllt werden muss. Die Methoden Print und PrintToPrinter rufen intern ebenfalls die Methode ExportReport auf. Wenn man also einen Report anzeigt oder druckt und zugleich ein PDF erzeugen möchte, dann handelt es sich um eine mehrfache Verarbeitung.</p>
<p>Der Schalter muss vor der ersten Verarbeitung aktiviert werden.</p>
<p>Nach der letzten Verarbeitung muss die Methode UncacheCrystalReports aufgerufen werden. Ansonsten kann es zu Speicher-Lecks und ggf. auch zu Exceptions führen.</p>
<p>Ein Report sollte nicht über einen Request hinaus zwischengespeichert werden.</p>
<p>Beispiel-Code:</p>
<pre><code class="lang-csharp">ReportDocument rd = new ReportDocument(….)
[…]
rd.CacheCrystalReport = true;
rd.PrintToPrinter(….);
btye[] bytesPDF = rd.ExportReport( ExportFormat.PDF );
rd.UncacheCrystalReport();
</code></pre><h4 id="methoden">Methoden</h4>
<h5 id="listreportenum-getreportenums">List<reportenum> GetReportEnums()</reportenum></h5>
<p>Damit kann man aus dem ReportDocument die Liste der ReportEnums (Klasse ReportEnum) ermitteln. Diese beinhaltet je nach Angabe im ReportDocument ggf. auch die Basis-Reports.</p>
<h5 id="string-setdatasourcestring-dsname-object-value">String SetDatasource(String dsName, Object value)</h5>
<p>Mit dieser Methode können die Datasources dynamisch gesetzt werden.</p>
<h5 id="reportenum-convertfilenametoreportsenumfilename">ReportEnum ConvertFileNameToReportsEnum(filename)</h5>
<p>Diese Methode kann verwendet werden, um einen Report mit einem bestimmten Datei-Namen zu finden.</p>
<h5 id="byte-exportreportexportformat-format">byte[] ExportReport(ExportFormat format)</h5>
<p>Exportiert den Report in das gewünschte Format. Dabei wird der SelectedReport verwendet.</p>
<p>Wird diese Funktion mehrfach hintereinander aufgerufen, dann kann die Performance mit dem Property <a href="#cachecrystalreport-get-set">CacheCrystalReports</a> gesteigert werden.</p>
<h4 id="void-uncachecrystalreport">void UncacheCrystalReport()</h4>
<p>Räumt den zwischengespeicherten CrystalReport auf. siehe <a href="#cachecrystalreport-get-set">CacheCrystalReports</a>.</p>
<h2 id="klasse-reportenum">Klasse ReportEnum</h2>
<p>Diese Klasse repräsentiert einen Crystal Report.</p>
<h3 id="properties-1">Properties</h3>
<h4 id="orientation">Orientation</h4>
<p>Landscape, Portrait, Default (Wird bei der Code-Generierung aus der Crystal Report-Datei ermittelt.)</p>
<h4 id="string-name">String Name</h4>
<p>Der interne Name des Reports.</p>
<h4 id="string-reportfilename">String ReportFileName</h4>
<p>Der Dateiname des Reports (ohne Pfad)</p>
<h4 id="imlstring-mlcaption">IMLString MLCaption</h4>
<p>Mehrsprachige Bezeichnung des Reports. (Siehe auch String GetCaption(IFSGlobalObject globalObj)).</p>
<h3 id="methoden-1">Methoden</h3>
<h4 id="string-getcaptionifsglobalobject-globalobj">String GetCaption(IFSGlobalObject globalObj)</h4>
<p>Gibt die Bezeichnung des Reports (Caption) für die aktuelle Sprache im GlobalObj zurück. Da der ReportEnum aus einer statischen Struktur kommt, kennt er selber kein GlobalObject. Deshalb muss dieses übergeben werden, um die Caption in der richtigen Sprache zu ermitteln.</p>
<p>Beispiel für die Verwendung von ReportEnum:</p>
<pre><code class="lang-csharp">foreach( ReportEnum oReportEnum in rptDocumentP.GetReportEnums() )
{
    cPrintReportName oPrintReportName = new cPrintReportName(this.Global);

    oPrintReportName.sReportName = oReportEnum.ReportName;
    oPrintReportName.sReportCaption = oReportEnum.GetCaption( this.Global );
    oPrintReportName.sReportFileName = rptDocumentP.ReportDir + &quot;\\&quot; 
        + oReportEnum.ReportFileName;
    oPrintReportName.oReportName = oReportEnum;
    oPrintReportName.intPaperOrientaion = (int)oReportEnum.Orientation;

    this.Add(oPrintReportName);
}
</code></pre><h2 id="klasse-printserver">Klasse PrintServer</h2>
<p>Diese Klasse dient zum einen dazu die bestehenden Print-Server zu ermitteln und zum anderen um Transaktionen an einem Print-Server zu steuern.</p>
<h3 id="methode-getprintservers">Methode GetPrintServers()</h3>
<pre><code class="lang-csharp">public static IList&lt;PrintServer&gt; GetPrintServers(IGlobalObjects global)
</code></pre><p>Liefert eine Liste der an der Runtime-Datenbank registrierten Print-Server zurück.</p>
<pre><code class="lang-csharp">IList&lt;PrintServer&gt; PSList = PrintServer.GetPrintServers(this.Global);
foreach (PrintServer PS in PSList)
{
    // PS
}
</code></pre><h3 id="methode-getprinters-">Methode GetPrinters( )</h3>
<pre><code class="lang-csharp">public IList&lt;Printer&gt; GetPrinters( );
IList&lt;PrintServer&gt; PSList = PrintServer.GetPrintServers(this.Global);

foreach (PrintServer PS in PSList)
{
    IList&lt;Printer&gt; Plist = PS.GetPrinters( );
}
</code></pre><pre><code class="lang-csharp">public static IList&lt;Printer&gt; GetPrinters( IGlobalObjects global, guid printServerId ) 
</code></pre><pre><code class="lang-csharp">IList&lt;PrintServer&gt; PSList = PrintServer.GetPrintServers(this.Global);
foreach (PrintServer PS in PSList)
{
    IList&lt;Printer&gt; Plist = PrintServer.GetPrinters( this.Global, PS.PrintServerId);
}
</code></pre><h2 id="klasse-printqueue">Klasse PrintQueue</h2>
<p>Diese Klasse bietet Methoden an, mit denen die Print-Queue ausgewertet und bearbeitet werden kann.</p>
<h3 id="methode-getstate-">Methode GetState( )</h3>
<pre><code class="lang-csharp">public static int GetState( IGlobalObjects global, guid printJobId )
</code></pre><p>Diese Methode liefert den Status des Druckauftrags mit der übergebenen PrintJobID zurück. Dabei wird der Status der den Druckauftrag umklammernden Transaktion zurückgegeben.</p>
<ol>
<li>Transaktion ist offen. Es können weitere Druckaufträge zur Transaktion hinzugefügt werden.</li>
<li>Transaktion ist bereit zu drucken. Alle Druckaufträge sind hinzugefügt und der Printserver kann mit dem Druck beginnen.</li>
<li>Der Druck läuft gerade.</li>
<li>Druckauftrag ist abgeschlossen.</li>
<li>Der Druckauftrag wurde mit einem Fehler beendet.</li>
</ol>
<pre><code class="lang-csharp">int Status = PrintQueue.GetState( this.Global, new guid( sPrintJobID ) );
</code></pre><h3 id="methode-getdocumentout-">Methode GetDocumentOut( )</h3>
<pre><code class="lang-csharp">public static byte[] GetDocumentOut( IGlobalObjects global, guid printJobId )
</code></pre><p>Diese Methode liefert das herausgeschriebene Dokument.</p>
<p>Dazu muss der Druck mit dem Kommando <strong>Out</strong> ausgeführt worden sein und der Status des Druck-Jobs muss 3 sein.</p>
<pre><code class="lang-csharp">byte[] PdfBytes = PrintQueue.GetDocumentOut( this.Global, new guid( sPrintJobID ) );
</code></pre><h3 id="method-delete-">Method Delete( )</h3>
<pre><code class="lang-csharp">public static void Delete( IGlobalObjects global, guid printJobId )
</code></pre><p>Diese Methode löscht den Datensatz aus der Print-Queue. Handelt es sich dabei um den letzten Eintrag für eine Transaktion wird diese ebenfalls mit gelöscht.</p>
<pre><code class="lang-csharp">if (PrintQueue.GetStatus( this.Global, guid( sPrintJobID) ) == 3 )
{
    PrintQueue.Delete( this.Global, new guid( sPrintJobID) );
}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
