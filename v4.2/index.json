{
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html",
    "title": "Class FrameworkApplicationException",
    "keywords": "Class FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. Inheritance Object Exception ApplicationException FrameworkApplicationException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class FrameworkApplicationException : ApplicationException, ISerializable, _Exception Constructors FrameworkApplicationException(String) FrameworkApplicationException(String, Exception) FrameworkApplicationException(String, Int32) FrameworkApplicationException(String, Int32, Exception) Properties Severity Definiert den Schweregrad der Exception."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html",
    "title": "Field ID",
    "keywords": "Field ID Die eindeutige ID des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly guid ID Returns Type Description FrameworkSystems.FrameworkDataProvider.BaseObjects.guid"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html",
    "title": "Field AssemblyPrefix",
    "keywords": "Field AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string AssemblyPrefix Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html",
    "title": "Field Name",
    "keywords": "Field Name Der Name des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Name Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html",
    "title": "Field Version",
    "keywords": "Field Version Die Version des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Version Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html",
    "title": "Field ProductName",
    "keywords": "Field ProductName Der an der Package-Version definierte Product Name. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string ProductName Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html",
    "title": "Field Manufacturer",
    "keywords": "Field Manufacturer Der im Package definierte Hersteller. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Manufacturer Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html",
    "title": "Field PublicKey",
    "keywords": "Field PublicKey Der öffenliche Schlüssel des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly RSAKeyPair PublicKey Returns Type Description FrameworkSystems.FrameworkBase.License.RSAKeyPair"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html",
    "title": "Field LastCompileDate",
    "keywords": "Field LastCompileDate Zeitpunkt des letzten Compiles. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly DateTime LastCompileDate Returns Type Description DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html",
    "title": "Field WasLastCompileBugFix",
    "keywords": "Field WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly bool WasLastCompileBugFix Returns Type Description Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html",
    "title": "Class AUHelper.PackageInfo",
    "keywords": "Class AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden. Inheritance Object AUHelper.PackageInfo Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class PackageInfo Remarks Warning Die Klasse darf nicht im eigenen Code instanziiert werden. Fields AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. ID Die eindeutige ID des Packages. LastCompileDate Zeitpunkt des letzten Compiles. Manufacturer Der im Package definierte Hersteller. Name Der Name des Packages. ProductName Der an der Package-Version definierte Product Name. PublicKey Der öffenliche Schlüssel des Packages. Version Die Version des Packages. WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html",
    "title": "Method FillOnDrop",
    "keywords": "Method FillOnDrop FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. Declaration public virtual void FillOnDrop() Remarks Hintergrund: Einige Datenformate bringen unter Umständen sehr große Datenmengen mit sich. Beispielsweise können Dateien sehr groß sein. Daher werden beim ersten Request des Clients ( OnCanDrop ) nur Informationen wie der Speicherort, Name, Größe usw. übertragen und nur dann, wenn der Inhalt tatsächlich im OnDrop benötigt wird (und deshalb FillOnDrop() aufgerufen wurde), werden die ggf. großen Daten ausgelesen und übertragen."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html",
    "title": "Class FlavorData",
    "keywords": "Class FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. Inheritance Object FlavorData FileListFlavorData ImageFlavorData TextFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public abstract class FlavorData Remarks Die Klasse bietet die Methode FillOnDrop() . Durch den Aufruf dieser Methode wird gesteuert, dass beim Drop-Vorgang alle Daten vollständig gefüllt werden sollen. Methods FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. See Also FileFlavorData FileListFlavorData ImageFlavorData TextFlavorData UriListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T Declaration T FromXml(string xml) Parameters xml String Returns T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. Declaration string ToXml(T value) Parameters value T Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html",
    "title": "Interface IXmlConverter<T>",
    "keywords": "Interface IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T . Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IXmlConverter<T> Type Parameters Name Description T Methods FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. See Also XmlConverter"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html",
    "title": "Constructor ColumnListDataSource",
    "keywords": "Constructor ColumnListDataSource ColumnListDataSource() Declaration public ColumnListDataSource()"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. Declaration public string DataSource { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. Declaration public bool? ContainsNullEntry { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string DisplayMember { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string ValueMember { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html",
    "title": "Property DisplayMdt",
    "keywords": "Property DisplayMdt DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer DisplayMdt { get; set; } Property Value MLContainer"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html",
    "title": "Class ColumnListDataSource",
    "keywords": "Class ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). Inheritance Object ColumnListDataSource Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class ColumnListDataSource Constructors ColumnListDataSource() Properties ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html",
    "title": "Enum GridColumnDefinition.ColumnTextAlign",
    "keywords": "Enum GridColumnDefinition.ColumnTextAlign Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnTextAlign Fields Name Description Center Left Right"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html",
    "title": "Field TextRtf",
    "keywords": "Field TextRtf Stellt Text im RTF-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextRtf = \"text/rtf\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html",
    "title": "Field TextUriList",
    "keywords": "Field TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextUriList = \"text/uri-list\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html",
    "title": "Field TextPlain",
    "keywords": "Field TextPlain Stellt unformatierten Text dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextPlain = \"text/plain\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html",
    "title": "Method IsTextFlavor",
    "keywords": "Method IsTextFlavor IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist. Declaration public static bool IsTextFlavor(string flavorType) Parameters flavorType String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html",
    "title": "Class FlavorType",
    "keywords": "Class FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. Inheritance Object FlavorType Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static class FlavorType Remarks Diese Klasse stellt primär Konstanten für alle von Framework Studio bekannten Datenformate zur Verfügung. Die Konstanten sind vom Typ String. So kann das externe Transferobjekt grundsätzlich auch unbekannte Datenformate unterstützen. Fields FileList Stellt Dateien dar. Image Stellt ein Bild dar. TextHtml Stellt Text im HTML-Format dar. TextPlain Stellt unformatierten Text dar. TextRtf Stellt Text im RTF-Format dar. TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. TextXml Stellt Text im XML-Format dar. Methods IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist."
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html",
    "title": "Constructor FrameworkApplicationException",
    "keywords": "Constructor FrameworkApplicationException FrameworkApplicationException(String) Declaration public FrameworkApplicationException(string msg) Parameters msg String FrameworkApplicationException(String, Int32) Declaration public FrameworkApplicationException(string msg, int severity) Parameters msg String severity Int32 FrameworkApplicationException(String, Exception) Declaration public FrameworkApplicationException(string msg, Exception innerEx) Parameters msg String innerEx Exception FrameworkApplicationException(String, Int32, Exception) Declaration public FrameworkApplicationException(string msg, int severity, Exception innerEx) Parameters msg String severity Int32 innerEx Exception"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html",
    "title": "Property Severity",
    "keywords": "Property Severity Severity Definiert den Schweregrad der Exception. Declaration public int Severity { get; } Property Value Int32 Remarks Diese Information wird momentan nicht ausgewertet."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public FrameworkFormatMask? Format { get; set; } Property Value Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html",
    "title": "Class MLContainer",
    "keywords": "Class MLContainer TODO! Inheritance Object MLContainer Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class MLContainer"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html",
    "title": "Struct FSstring",
    "keywords": "Struct FSstring TODO! Summary description for FSstring. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSstring : IFSstring, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html",
    "title": "Struct FSbyteArray",
    "keywords": "Struct FSbyteArray TODO! Summary description for FSbyteArray. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyteArray : IFSbyteArray, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html",
    "title": "Method GetArgumentFSlong",
    "keywords": "Method GetArgumentFSlong GetArgumentFSlong(String) Declaration public FSlong GetArgumentFSlong(string key) Parameters key String Returns FSlong"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html",
    "title": "Class FrameworkOnLinkClickEventArgs",
    "keywords": "Class FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden Inheritance Object EventArgs FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkEventArgs FrameworkOnLinkClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnLinkClickEventArgs : FrameworkEventArgs Methods GetArgumentFSlong(String)"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde. Declaration public virtual string Text { get; protected set; } Property Value String Remarks Lediglich die Texte in den Formaten TextPlain und TextUriList werden schon im OnCanDrop gefüllt."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html",
    "title": "Class ExternalTransferObject",
    "keywords": "Class ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. Inheritance Object ExternalTransferObject Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ExternalTransferObject Remarks Die Klasse bietet Methoden, mit denen ermittelt werden kann, welche FlavorTypes ( FlavorType ) unterstützt werden, also in welchen Formaten Daten zur Verfügung stehen. Außerdem können zu jedem FlavorType die entsprechenden Daten ( FlavorData ) abgefragt werden. In den Events OnCanDrop und OnDrop kann eindeutig erkannt werden, ob es sich um einen internen oder einen externen Drag&Drop-Vorgang handelt, indem überprüft wird, ob das TransferObject vom Typ ExternalTransferObject ist. Examples ExternalTransferObject oExternalTransferObject = e.TransferObject as ExternalTransferObject; if (oExternalTransferObject != null) { // Drag&Drop-Vorgang von außerhalb der Applikation } else { // Drag&Drop-Vorgang innerhalb der Applikation } Methods GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html",
    "title": "Property Now",
    "keywords": "Property Now Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time. Declaration public static FSDateTime Now { get; } Property Value FSDateTime"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html",
    "title": "Struct FSDateTime",
    "keywords": "Struct FSDateTime TODO! Summary description for FSDateTime. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSDateTime : IFSDateTime, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen Properties Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time."
  },
  "api/FrameworkSystems.FrameworkBase.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkBase.EditorStyle.html",
    "title": "Enum EditorStyle",
    "keywords": "Enum EditorStyle Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum EditorStyle Fields Name Description CheckBox ComboBox Editfield MultilineEditfield"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html",
    "title": "Class DevMLString",
    "keywords": "Class DevMLString TODO! Inheritance Object DevMLString Namespace : FrameworkSystems.FrameworkBase.MultiLanguage Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevMLString"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.GlobalObj",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.GlobalObj Interfaces IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage Classes DevMLString TODO!"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Classes FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html",
    "title": "Struct FSbool",
    "keywords": "Struct FSbool Summary description for FSbool. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbool : IFSbool, IFSType, IComparable, IConvertible Remarks TODO! Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html",
    "title": "Property UserTokenAsString",
    "keywords": "Property UserTokenAsString UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string UserTokenAsString { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html",
    "title": "Property Username",
    "keywords": "Property Username Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string Username { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html",
    "title": "Property IsDefaultUser",
    "keywords": "Property IsDefaultUser IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. Declaration public bool IsDefaultUser { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html",
    "title": "Property AuthenticationEnabled",
    "keywords": "Property AuthenticationEnabled AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. Declaration public bool AuthenticationEnabled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html",
    "title": "Method IdentifyDefaultUser",
    "keywords": "Method IdentifyDefaultUser IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser() Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück. IdentifyDefaultUser(out AUHelper.Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser(out AUHelper.Message msg) Parameters msg FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html",
    "title": "Method IdentifyUser",
    "keywords": "Method IdentifyUser IdentifyUser(out AUHelper.Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyUser(out AUHelper.Message msg, string username, string password, ref string loginInfo, bool includeRolesInToken) Parameters msg FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. username String password String loginInfo String Der Parameter LoginIngo wird ausgelesen und vom Authentication Service geloggt. Zurückgegeben wird die zuletzt geloggte Information. includeRolesInToken Boolean Der letzte Parameter gibt an, ob die Rollen im Token kommuniziert werden sollen - Standardwert true Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html",
    "title": "Method IdentifyUnit",
    "keywords": "Method IdentifyUnit IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. Declaration public void IdentifyUnit(string unitKey) Parameters unitKey String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html",
    "title": "Property UnitKey",
    "keywords": "Property UnitKey UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Declaration public string UnitKey { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html",
    "title": "Property Units",
    "keywords": "Property Units Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Declaration public IEnumerable<KeyValuePair<string, string>> Units { get; } Property Value IEnumerable < KeyValuePair < String , String >> Remarks KeyValuePair.Key = Schlüsselwert der Unit (Geschäftseinheit) KeyValuePair.Value = Name der Unit"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html",
    "title": "Method Granted",
    "keywords": "Method Granted Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. Declaration public bool Granted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1, AUPermissionType.Delete ) ) { //Delete granted } if ( this.Global.Granted(AUList.aufrmForm1, AUPermissionType.Insert) ) { //Insert granted } Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Declaration public bool Granted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . Returns Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1 ) ) { //Access granted }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html",
    "title": "Method LicenseGranted",
    "keywords": "Method LicenseGranted LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. Declaration public bool LicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . type AUPermissionType Eine AUPermissionType Returns Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access } LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt Declaration public bool LicenseGranted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . Returns Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html",
    "title": "Method GetPackages",
    "keywords": "Method GetPackages GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. Declaration public List<AUHelper.PackageInfo> GetPackages() Returns List < AUHelper.PackageInfo > Remarks Das SystemPackage ist in der Liste nicht enthalten. Die Liste beginnt mit dem DefaultPackage und endet mit dem obersten CustomizingPackage. Die Klasse AUHelper.PackageInfo enthält über ein Package die Informationen ID, Name, Version und Hersteller (Manufacturer)."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html",
    "title": "Method ChangePasswordChecked",
    "keywords": "Method ChangePasswordChecked ChangePasswordChecked(String, String, String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, string oldPassword, string newPassword, out AUHelper.Message message, string loginInfo) Parameters username String oldPassword String newPassword String message FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message loginInfo String beliebiger Text, der vom Authentication Service geloggt wird, darf null sein ChangePasswordChecked(String, Byte[], String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, byte[] oldHashSign, string newPassword, out AUHelper.Message message, string loginInfo) Parameters username String oldHashSign Byte [] Der Hashwert des alten Passwortes. newPassword String message FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message loginInfo String beliebiger Text, der vom Authentication Service geloggt wird, darf null sein"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html",
    "title": "Method ChangePassword",
    "keywords": "Method ChangePassword ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. Declaration public void ChangePassword(string oldPassword, string newPassword) Parameters oldPassword String newPassword String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetAllLanguages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetAllLanguages.html",
    "title": "Method GetAllLanguages",
    "keywords": "Method GetAllLanguages GetAllLanguages() Gibt eine Liste mit ISO Kürzeln aller an dieser Applikation bekannten Sprachen zurück. Declaration public List<string> GetAllLanguages() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html",
    "title": "Method RegisterUnits",
    "keywords": "Method RegisterUnits RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service. Declaration public void RegisterUnits(IEnumerable<KeyValuePair<string, string>> units) Parameters units IEnumerable < KeyValuePair < String , String >> Key = unit id / Value = unit name"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html",
    "title": "Class AUHelper",
    "keywords": "Class AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. Inheritance Object AUHelper Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AUHelper Examples this.Global.AUHelper.ChangePassword( sOld, sNew ); Properties AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Methods ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. ChangePasswordChecked(String, Byte[], String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. ChangePasswordChecked(String, String, String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. GetAllLanguages() Gibt eine Liste mit ISO Kürzeln aller an dieser Applikation bekannten Sprachen zurück. GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetGrantedLanguages() Gibt eine Liste mit ISO Kürzeln der Sprachen zurück, die zur Verfügung stehen und durch die verwendeten Lizenzen freigegeben sind. GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyDefaultUser(out AUHelper.Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. IdentifyUser(out AUHelper.Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service."
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html",
    "title": "Constructor RowVersionInvalidException",
    "keywords": "Constructor RowVersionInvalidException RowVersionInvalidException(String) Declaration public RowVersionInvalidException(string caption) Parameters caption String RowVersionInvalidException(String, Exception) Declaration public RowVersionInvalidException(string caption, Exception ex) Parameters caption String ex Exception"
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html",
    "title": "Class RowVersionInvalidException",
    "keywords": "Class RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Inheritance Object Exception FrameworkSystems.FrameworkExceptions.FrameworkException RowVersionInvalidException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class RowVersionInvalidException : FrameworkException, ISerializable, _Exception Constructors RowVersionInvalidException(String) RowVersionInvalidException(String, Exception)"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html",
    "title": "Enum ComboEditStyle",
    "keywords": "Enum ComboEditStyle TODO! Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.Data Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum ComboEditStyle Fields Name Description FreeTextInput ListValuesInput"
  },
  "api/FrameworkSystems.FrameworkBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.html",
    "title": "Namespace FrameworkSystems.FrameworkBase",
    "keywords": "Namespace FrameworkSystems.FrameworkBase Classes BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. Enums AUPermissionType Kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. EditorStyle FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben)"
  },
  "api/FrameworkSystems.FrameworkBase.AUPermissionType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AUPermissionType.html",
    "title": "Enum AUPermissionType",
    "keywords": "Enum AUPermissionType Kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public enum AUPermissionType Fields Name Description Access Is general access allowed? AccessDerived Is access of an AccessUnit, which is derived from this AccessUnit, possible? Delete Is deleting allowed? Insert Is inserting allowed? Update Is updating allowed?"
  },
  "api/FrameworkSystems.FrameworkExceptions.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.html",
    "title": "Namespace FrameworkSystems.FrameworkExceptions",
    "keywords": "Namespace FrameworkSystems.FrameworkExceptions Classes FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Enums FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop Classes ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Enums FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html",
    "title": "Class AccessUnit",
    "keywords": "Class AccessUnit TODO! Inheritance Object AccessUnit Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AccessUnit"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html",
    "title": "Struct FSlong",
    "keywords": "Struct FSlong TODO! Summary description for FSlong. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSlong : IFSlong, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html",
    "title": "Struct FSdecimal",
    "keywords": "Struct FSdecimal TODO! Summary description for FSdecimal. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdecimal : IFSdecimal, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html",
    "title": "Method CloseApplication",
    "keywords": "Method CloseApplication CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. Declaration void CloseApplication() Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. Declaration void CloseApplication(FrameworkCloseMode closeMode) Parameters closeMode FrameworkCloseMode Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. Declaration void CloseApplication(string message) Parameters message String Die Meldung die am Client angezeigt werden soll. Wird String.Empty übergeben, wird die Anwendung ohne Meldung beendet. Wird null übergeben, verhält sich die Methode wie die parameterlose CloseApplication() . Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html",
    "title": "Property AUHelper",
    "keywords": "Property AUHelper AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. Declaration AUHelper AUHelper { get; } Property Value AUHelper"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html",
    "title": "Property SelectedLanguage",
    "keywords": "Property SelectedLanguage SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Declaration string SelectedLanguage { get; set; } Property Value String Remarks Beim Setzen der SelectedLanguage gibt es 2 Möglichkeiten: 1.) Es wird nur ein ISO-Code übergeben.Dieser wird an die erste Stelle der LanguageHierarchy gesetzt. Wenn dieser Code schon in der Hierarchie enthalten ist, dann wird dieser an die erste Stelle verschoben. 2.) Es wird eine Komma-separierte Liste von ISO-Codes übergeben.In diesem Fall wird aus dieser Liste eine neue LanguageHierarchy aufgebaut. Die Sprache wird beim Start im Client festgelegt. Der Broker wechselt beim Start der Anwendung ggf. auf die Default-Sprache der Anwendung, wenn die vom Client angefragte Sprache nicht zur Verfügung steht. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html",
    "title": "Method CreateComponent",
    "keywords": "Method CreateComponent CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. Declaration object CreateComponent(string componentName) Parameters componentName String Returns Object Remarks Das zurückgegebene Objekt muss ggf. in einen anderen Typ umgewandelt werden, damit eine Weiterverarbeitung möglich ist. DevFrameworkObject oObject = this.Global.CreateComponent(\"Namespace.cdComponent\") as DevFrameworkObject; DevFrameworkObjectColl oColl = this.Global.CreateComponent(\"Namespace.cdComponentColl\") as DevFrameworkObjectColl; Der ComponentName entspricht dem FullName des Typs. Dieser kann auch zur Laufzeit ermittelt werden. sComponentName = oComponent.GetType().FullName; Warning Da der übergebene Parameter nicht kompiliert ist, sollte diese Funktion nur in Ausnahmefällen eingesetzt werden, um z.B. verallgemeinerte Logik umzusetzen."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html",
    "title": "Method GetCodeDirectory",
    "keywords": "Method GetCodeDirectory GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. Declaration string GetCodeDirectory() Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html",
    "title": "Property LanguageHierarchy",
    "keywords": "Property LanguageHierarchy LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. Declaration IEnumerable<string> LanguageHierarchy { get; set; } Property Value IEnumerable < String > Remarks Beim Setzen kann jeder Typ zugewiesen werden, der von IEnumerable<string> erbt. Es ist jedoch empfehlenswert, mit einer ReadOnlyCollection<string> zu arbeiten, um Manipulationen an dieser Liste zu verhindern. Diese kann zum Beispiel mit der Methode Liste<string>.AsReadOnly() erzeugt werden. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html",
    "title": "Property SafeInitializing",
    "keywords": "Property SafeInitializing SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. Declaration bool SafeInitializing { get; } Property Value Boolean Remarks Der Modus kann mithilfe der Methode EndSafeInitialize() zurückgesetzt werden. Wenn diese Methode einmal aufgerufen wurde, dann ist es nicht mehr möglich, den Modus wieder zu aktivieren. Wenn dieser Modus aktiv ist, dann können z.B. in einer Update-Sitation Exceptions unterbunden werden, die den Start der Anwendung verhindern würden. Examples try { [Aktion] } catch (Exception ex) { if (this.Global.SafeInitializing) { [Fehler behandeln] } else { // Exception weiter werfen. throw; } }"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html",
    "title": "Method EndSafeInitialize",
    "keywords": "Method EndSafeInitialize EndSafeInitialize() Deaktiviert den SafeInitializing Modus. Declaration void EndSafeInitialize()"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html",
    "title": "Interface IGlobalObjects",
    "keywords": "Interface IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten. Namespace : FrameworkSystems.FrameworkBase.GlobalObj Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IGlobalObjects : IFrameworkDBPerformanceCounter Properties AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Methods CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. EndSafeInitialize() Deaktiviert den SafeInitializing Modus. GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html",
    "title": "Property Size",
    "keywords": "Property Size Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Declaration public long Size { get; protected set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html",
    "title": "Property Type",
    "keywords": "Property Type Type Gibt den Typ der Datei zurück. Declaration public FileFlavorData.FileType Type { get; protected set; } Property Value FileFlavorData.FileType Remarks Mögliche Werte sind : File : Datei Directory : Verzeichnis"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Declaration public string Name { get; protected set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html",
    "title": "Property FullName",
    "keywords": "Property FullName FullName Gibt den Dateinamen inklusive Pfad zurück. Declaration public string FullName { get; protected set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html",
    "title": "Property LastModified",
    "keywords": "Property LastModified LastModified Gibt das letzte Änderungsdatum der Datei zurück. Declaration public DateTime LastModified { get; protected set; } Property Value DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html",
    "title": "Property Content",
    "keywords": "Property Content Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. Declaration public byte[] Content { get; protected set; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html",
    "title": "Class FileFlavorData",
    "keywords": "Class FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). Inheritance Object FileFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileFlavorData Properties Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. FullName Gibt den Dateinamen inklusive Pfad zurück. LastModified Gibt das letzte Änderungsdatum der Datei zurück. Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Type Gibt den Typ der Datei zurück."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Gibt die Anzahl der enthaltenen Dateien zurück. Declaration public int Count { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück. Declaration public IEnumerator<FileFlavorData> GetEnumerator() Returns IEnumerator < FileFlavorData > Examples FileListFlavorData oFileListFlavorData = oExternalTransferObject.GetFileListFlavorData(); foreach (FileFlavorData oFileFlavorData in oFileListFlavorData) { String sFileName = oFileFlavorData.Name; // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html",
    "title": "Class FileListFlavorData",
    "keywords": "Class FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . Inheritance Object FlavorData FileListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileListFlavorData : FlavorData, IEnumerable<FileFlavorData>, IEnumerable Remarks Die Enumeration enthält (auch im Event OnCanDrop ) immer mindestens ein Objekt vom Typ FileFlavorData . Properties Count Gibt die Anzahl der enthaltenen Dateien zurück. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück."
  },
  "doc/html-client/lizenzen.html": {
    "href": "doc/html-client/lizenzen.html",
    "title": "Hinweise zu Lizenzen",
    "keywords": "Hinweise zu Lizenzen Timeout Aus technischen Gründen kann der HTML-Client weder im Browser, noch in der App auf einem mobilen Gerät dem Broker mitteilen, dass er beendet wurde. Z.B. kann auf einem Android-Gerät nicht unterschieden werden, ob eine App nur in den Ruhezustand gewechselt hat oder komplett geschlossen wurde. Dies hat zur Folge, dass Broker-Sessions, die von einem HTML-Client aus gestartet wurden, offen bleiben, bis der Broker sie von sich aus verwirft. Diese Zeitspanne beträgt 12 Stunden . ClientID Um dem Verbrauch von Lizenzen entgegen zu wirken, wird im HTML-Client eine ClientID generiert, die den Browser bzw. das mobile Gerät identifiziert und mit zum Broker geschickt wird. Im Browser ist die ClientID eine UUIDv4, die im Code generiert wird, auf mobilen Geräten wird die Cordova-Geräte-ID herangezogen. Über die ClientID kann der Broker den Browser bzw. das mobile Gerät identifizieren und bei einem erneuten Start einer Anwendung diesem die bisherige Lizenz zuordnen. Zusatz für mobile Geräte Die ClientID auf mobilen Geräten ist immer gleich. Ein mobiles Gerät verbraucht am Broker eine Lizenz unabhängig vom Benutzer. Zusatz für Browser Ein Browser hat keinen Zugriff auf das Betriebssystem und den Computer. Die generierte ClientID wird deshalb im sogenannten „Local Storage“ des Browsers gespeichert. Dieser Speicher ist je nach Konfiguration benutzerabhängig. Beispiel: Ist auf einem Computer, den drei Benutzer verwenden, Firefox als Browser installiert, so hat jeder Benutzer seinen eigenen Local Storage. Dies bedeutet, dass jeder Benutzer seine eigene ClientID bekommt und somit auch drei Lizenzen am Broker verbraucht werden. Dies gilt auch, wenn ein Benutzer dieselbe Applikation einmal im Firefox und einmal im Chrome öffnet. Die beiden Browser haben separate Local Storages und verbrauchen somit auch wieder zwei Lizenzen am Broker."
  },
  "doc/documentation/editor.html": {
    "href": "doc/documentation/editor.html",
    "title": "Editor",
    "keywords": "Editor *Dokumentations-Editor in Framework Studio Zugang zum Editor der verschiedenen Elemente Da an verschiedenen Elementen im Framework Studio dokumentiert werden kann, werden nachfolgend alle Einsprungpunkte zum Editor aufgezeigt. Documentation-Element Da das Documentation-Element keine andere Funktion hat außer Freitexte in Form von DocML zu verfassen, besteht das Hauptformular eines Documentation-Elements aus dem Editor selbst. Das Documentation-Element besteht praktisch nur aus einem Editor: Form Um ein Form zu dokumentierten, muss dieses geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Zugang zum Editor über den Reiter Documentation : Form Control Controls auf einem Form werden über den Form Designer dokumentiert. Dazu muss das gewünschte Control markiert werden. Mit einem Rechtsklick auf das Control öffnet sich das Kontextmenü in dem der Menüpunkt Edit Documentation aufgeführt wird. Alternativ kann über das Property-Fenster von Framework Studio im Bereich Documentation auf den Button mit den drei Punkten geklickt werden. Der Editor öffnet sich für die Controls als modaler Dialog über dem Form Designer. Aufrufen des Editors für ein Control: Component Property Um ein Property zu dokumentieren, muss in der Component das jeweilige Property ausgewählt sein. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation eines Properties: DBColumn Um eine Datenbankspalte zu dokumentieren, muss an der DBTable die gewünschte Spalte ausgewählt werden. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation einer DBColumn: Metadatentyp Um einen Metadatentyp zu dokumentierten, muss dieser geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Dokumentation eines Metadatatypen: Arbeiten mit dem Editor Der Dokumentationseditor ist ähnlich intuitiv bedienbar wie z.B. ein normaler Texteditor in Microsoft Word oder anderen Textverarbeitungsprogrammen. Es wird der Text markiert, auf den eine Formatierung angewendet werden soll und das jeweilige Icon in der Werkzeugleiste geklickt, um die Formatierung an- oder auszuschalten. Bei Textbausteinen wie Tabellen oder Listen wird der Cursor an die Stelle gesetzt, an der das gewünschte Element eingefügt werden soll. Info Panel Info Panel und Link zum Chapter Tree im Editor: Über die Radiobuttons im Info Panel kann zwischen verschiedenen Ansichten des Editors umgeschaltet werden. None: Zeigt nur den DocML-Editor für die ausgewählte Sprache. Preview: Zeigt zusätzlich zum DocML-Editor das Vorschaufenster an (wird automatisch aktiviert, wenn in der Werkzeugleiste geklickt wird). Other: Zeigt zusätzlich zum DocML-Editor einen zweiten DocML-Editor im Lesemodus an, um zeitgleich eine andere Sprache oder eine andere Dokumentation aus einem anderen Package bereitzustellen. Über den Link Open Documentation Tree kann aus jedem Editor heraus der Kapitel-Baum aufgerufen werden. Siehe Chapter Tree . Werkzeugleiste Combobox Language Hier kann die Sprache eingestellt werden, für die im Dokumentations-Editor dokumentiert werden soll. Die DocML-Scripte für die jeweiligen Sprachen sind völlig unabhängig voneinander und beeinflussen sich somit nicht gegenseitig. Textbox Caption Dieses Textfeld ist nur an Form-Dokumentationen und Documentation-Elementen verfügbar. Hier wird die Kapitelüberschrift für das fertige Dokument eingegeben. Die Kapitel werden im Chapter Tree verwaltet. Neue Section Sie erkennen Neue Section an einem -Icon. Fügt an der Stelle des Cursers im Dokumentations-Editor eine neues Section-Tag ein. Dabei wird automatisch eine neue 32-stellige GUID generiert und in das id-Attribut des Tags eingefügt. Von da an steht die Section für Customizing-Zwecke bereit. Siehe Customizing . Preview anzeigen Sie erkennen Preview anzeigen an einem -Icon. Über diesen Button wird das sich im Editor befindliche DocML in HTML konvertiert und im Preview-Panel angezeigt. Kann das DocML aufgrund von Fehlern nicht korrekt umgewandelt werden, werden die entsprechenden Fehler im Common Errors -Panel von Framework Studio aufgelistet. Syntax-Check Sie erkennen Syntax-Check an -Icons. Über diese Buttons kann das DocML auf Validität geprüft werden. Der erste Button überprüft das sich im Editor befindliche DocML für die ausgewählte Sprache. Der Button mit dem Zusatz All überprüft das DocML für alle verfügbaren Sprachen, die über die Combobox Language auswählbar sind. Bei einem Klick auf den Preview-Button wird automatisch erst eine Validierung des DocML’s für die aktuelle Sprache durchgeführt. Schriftart Sie erkennen Schriftart an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftart. Um die finale Dokumentation der Anwendung möglichst homogen zu halten, stehen nur zwei Schriftarten zur Auswahl Normal: Wird in HTML und Word in Arial konvertiert Code: Wird in HTML in ein <code>-Tag geschrieben, im Word wird Courier New verwendet. Schriftgröße Sie erkennen Schriftgröße an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftgröße. Die Einstellung Normal spiegelt die gängige Standardgröße 11pt in Word wider. Die Schriftgrößenangaben sind relativ gehalten, da aus DocML unterschiedliche Ausgabeformen generiert werden können (HTML, Word). Schriftfarbe Sie erkennen Schriftfarbe an -Icons. Formatiert den im Editor markierten Text in der ausgewählten Schriftfarbe. Es können die Schriftfarbe sowie die Hintergrundfarbe für den Text ausgewählt werden. Textformatierungen Sie erkennen Textformatierungen an -Icons. Umgibt den im Editor ausgewählten Text mit dem entsprechenden Formatierungstag. Zur Auswahl stehen: Fett Kursiv Unterstrichen Durchgestrichen Tiefgestellt Hochgestellt Ausrichtung Sie erkennen Ausrichtung an -Icons. Richtet den im Editor markierten Text nach Wunsch links, mittig, rechts oder als Blocksatz aus. Die Standardeinstellung ist linksbündig. Liste Sie erkennen Liste an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Auflistung: List Type Mit List Type wird die Art der Liste definiert. Unordered stellt eine Liste mit Symbolen dar, während Ordered die Listeneinträge aufsteigend nummeriert. List Symbol Nur verfügbar, wenn als Listentyp “Unordered” ausgewählt wurde. Es kann zwischen Disk, Circle und Square gewählt werden. List Item Count Legt die Anzahl der in der Liste befindlichen li-Tags fest. Diese können anschließend im DocML beliebig erweitert werden. Tabelle Sie erkennen Tabelle an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Tabelle. Nach dem Klick auf das Symbol wird zunächst ein Panel angezeigt, in dem die Größe der zu konfigurierenden Tabelle ausgewählt werden muss: Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat unten rechts gezeigt, vergrößert sich die Auswahl. Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat oben links gezeigt, verkleinert sich die Auswahl. Nach der Auswahl der Tabellengröße wird der Dialog zum Konfigurieren der Tabelle angezeigt: Es können alle Parameter der Tabelle eingestellt werden. Dazu gehören Breite, Ausrichtung und Farbe der Tabelle, Spalten, Zeilen und Zellen. Die Werte der Tabelle können durch Spalten, Zeilen und Zellen überschrieben werden. Die Hierarchie der Überschreibungen sieht wie folgt aus: Tabelle -> Spalte -> Zeile -> Zelle Mit einem Klick auf den Button Ok werden für die konfigurierte Tabelle die entsprechenden Tags in den Editor generiert und können anschließend mit Werten befüllt werden. Bild einbinden Sie erkennen Bild einbinden an einem -Icon. Öffnet einen Dialog zum Einbinden eines Bildes in die Dokumentation. Es können nur Bildressourcen aus Framework Studio in die Dokumentation eingebunden werden. Für Bilder von der Festplatte oder aus dem Internet wird eine entsprechende Bildressource angelegt. Einfügen eines Bildes in die Dokumentation: Im Bereich Image Source muss zuerst ausgewählt werden, woher das einzubindende Bild stammt. Wenn das Bild schon als Ressource im Framework Studio verfügbar ist, kann diese aus der Baumansicht ( Existing Resource ) ausgewählt werden. Eine Vorschau des Bildes erscheint auf der rechten Seite. Es kann auch direkt ein Bild aus dem Internet eingebunden werden ( From Url ). Damit das Bild in der Dokumentation angezeigt wird, wenn beim Betrachten keine Internetverbindung besteht, muss dieses mit dem Button Load geladen werden. Danach erscheint das Bild in der Vorschau. Die Url des Bildes muss mit Fehler! Linkreferenz ungültig beginnen. Soll ein Bild von der Festplatte eingebunden werden, muss zuerst der Radiobutton From File aktiviert werden. Danach kann über den Button […] ein Bild von der Festplatte gewählt werden. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Bildes verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Bildes in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Bildes. Height Höhe des Bildes (nur aktiv, wenn Keep aspect ratio deaktiviert ist). Keep aspect ratio Wenn aktiviert (Standard), wird anhand der eingegebenen Breite des Bildes, die zugehörige Höhe anhand des originalen Seitenverhältnisses berechnet. Das Bild wird somit nicht verzerrt. Inline Image Wenn aktiviert, verhält sich das Bild wie ein Schriftzeichen und folgt dem normalen Textfluss. Andernfalls wird vor und nach dem eingefügten Bild ein Zeilenumbruch generiert. Caption Nur verfügbar, wenn die Option Inline Image deaktiviert ist. Es kann eine Bildunterschrift angegeben werden. Warning Wenn das Bild aus dem Internet oder von der Festplatte eingebunden werden soll, wird nach dem Klick auf den Button Ok ein Dialog angezeigt, der darauf hinweist, dass automatisch eine Framework Studio Resource für das Bild angelegt wird. Screenshot Sie erkennen Screenshot an einem -Icon. Öffnet einen Dialog zum Einbinden eines automatisch generierten Screenshots des Formulars in die Dokumentation. Diese Funktion ist nur in der Form-Dokumentation verfügbar. Anhand der Designer-Daten wird ein Screenshot des Formulars generiert. Sollten Tabellen mehr Spalten haben, als in der Breite angezeigt werden können, werden die Spaltenköpfe umgebrochen und mehrzeilig fortgeführt. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Screenshots verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Formulars in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Screenshots. Height Die Höhe des Bildes wird automatisch anhand des Seitenverhältnisses des Formulars berechnet. Link Sie erkennen Link an einem -Icon. Öffnet einen Dialog zum Einfügen eines Querverweises oder eines Hyperlinks. Es kann im DocML sehr einfach auf ein anderes Kapitel (Formular oder Documentation-Element) verwiesen werden oder ein Hyperlink ins Internet bereitgestellt werden. Bei einem Querverweis auf ein Kapitel muss das entsprechende Form oder Documentation-Element aus der Baumansicht ausgewählt werden. Für einen Hyperlink ins Internet kann eine beliebige URL beginnend mit Fehler! Linkreferenz ungültig eingegeben werden. In der Textbox Text wird festgelegt, wie der Link in der Dokumentation angezeigt werden soll. Indexeintrag Sie erkennen Indexeintrag an einem -Icon. Öffnet einen Dialog zum Einfügen eines Indexeintrages in die Dokumentation. Im Export Wizard kann definiert werden, ob in der gerenderten Dokumentation ein Index erstellt werden soll. Kapitelüberschriften (von Forms und Documentation-Elementen) werden dem Index automatisch hinzugefügt. Über den Dialog ist es möglich, manuell einen Indexeintrag zu generieren. Dabei muss der Haupteintrag definiert werden. Optional kann ein Untereintrag angegeben werden. Basisaufruf Sie erkennen Basisaufruf an einem -Icon. Nur verfügbar in den Dokumentationen von Controls, Component Properties, DBColumns und Metadatentypen. Erstellt ein base-Tag, welches die Basisdokumentation des aktuellen Elements (Controls, Component Properties, DBColumn oder Metadatentyps) in die Dokumentation mit einbindet. Mehr Information hierzu finden Sie im Kapitel Vererbung Linie Sie erkennen Linie an einem -Icon. Erstellt an der Curser-Position im Editor ein line-Tag. Dieses generiert in der Dokumentation eine schwarze Linie über die gesamte Seitenbreite mit anschließendem Zeilenumbruch. Zeilenumbruch Das br-Tag ist sicherlich das am häufigsten verwendete Tag in einer Dokumentation in DocML. Es wäre sehr umständlich, wenn jedes Mal, wenn ein Zeilenumbruch in der Dokumentation eingefügt werden soll, ein Button in der Werkzeugleiste geklickt werden müsste. Dies würde den Schreibfluss mit der Tastatur erheblich behindern. Um ein br-Tag ( [br/] ) an der Cursorposition einzufügen, muss im Editor nur <STRG + Enter> gedrückt werden. Es wird ein br-Tag eingefügt und automatisch in die nächste Zeile gesprungen. Text markieren Alle Formatierungsfunktionen des Editors wie z.B. Fettschrift oder Ausrichtung des Textes funktionieren ähnlich wie in einem WYSIWYG-Editor. Es wird Text markiert und dann die gewünschte Formatierungsoption aufgerufen. Der Unterschied des DocML-Editors ist allerdings, dass sich im markierten Text auch DocML-Tags befinden können, wie folgendes Beispiel zeigt: Dies ist allerdings absolut kein Problem. Soll z.B. der oben markierte Text kursiv geschrieben werden, kann einfach in der Werkzeugleiste der entsprechende Button geklickt werden. Der Editor erkennt die Markierung und alle Tags darin und wendet die neue Formatierung entsprechend an: Es muss also nicht auf Tags geachtet werden, wenn zusätzliche Formatierungen auf schon zuvor formatierte Textstellen angewendet werden. Auch bei Block-Tags wie Listen kann dieses Verhalten auftreten. Nachfolgend soll z.B. eine gesamte Liste fett gedruckt werden. Da Block-Tags (lst-Tags) nicht in Inline-Tags (b-Tags) auftreten dürfen, kümmert sich der Editor selbst darum und ergänzt die Texte in der Liste automatisch mit den entsprechenden Tags. Folgende Liste soll komplett fett gedruckt dargestellt werden: Nach einem Klick auf den Button für Fettschrift in der Werkzeugleiste werden die Listeneinträge automatisch um die jeweiligen b-Tags ergänzt und die Validität des DocML wird erhalten: Beim Markieren von Texten für Formatierungen muss also nicht explizit an schon vorhandene Tags gedacht werden, der Editor erledigt dies alles automatisch. Kommentare DocML bietet die Möglichkeit, in Dokumentationen Kommentare einzufügen, die nicht in die Ausgabe gerendert werden. So können z.B. kleine Notizen oder Erinnerungen in die Dokumentation eingefügt werden. Ein Kommentar-Tag startet mit der Zeichenfolge [-- und endet mit --] . Kommentare sind im DocML an ihrer grünen Farbe zu erkennen und beeinflussen die Ausgabe in keinster Weise. Kommentare können an beliebiger Stelle im DocML platziert werden. Escape-Zeichen Die Sprache DocML beinhaltet einige Steuerzeichen wie z.B. eckige Klammern ( [ und ] ), mit denen die Tags abgebildet werden. Allerdings werden diese Zeichen natürlich auch im Fließtext der Ausgabe benötigt. Dass Framework Studio den Unterschied zwischen einer eckigen Klammer eines Tags und einer normalen eckigen Klammer im Fließtext unterscheiden kann, müssen diese Zeichen mit einem Blackslash ( \\ ) escaped werden. Wie zu sehen ist, werden die Backslashes in der Ausgabe eliminiert. Um einen Backslash als Zeichen in die Dokumentation einzufügen, muss dieser ebenso mit einem weiteren Backslash escaped werden. Panel Other Der Editor bietet die Möglichkeit, ein zusätzliches Fenster einzublenden, welches eine Dokumentation aus einem anderen Package oder in einer anderen Sprache anzeigt. So kann z.B. während die englische Dokumentation für ein Formular erstellt wird, parallel die deutsche Dokumentation angezeigt werden, um besser übersetzen zu können. Language Mit dieser Combobox wird die Sprache der anzuzeigenden Dokumentation gewählt. Package Mit dieser Combobox kann zwischen den Dokumentationen des Elementes in unterschiedlichen Packages gewählt werden. Mehr Informationen über Package-übergreifende Dokumentation und das Customizing befindet sich in den Kapiteln Vererbung und Customizing ."
  },
  "doc/documentation/dokumentations-system.html": {
    "href": "doc/documentation/dokumentations-system.html",
    "title": "Dokumentations-System",
    "keywords": "Dokumentations-System Framework Studio bietet die Möglichkeit, die entwickelten Applikationen mittels eines in die IDE integrierten Dokumentationssystems zu dokumentieren. Im Gegensatz zu herkömmlichen Dokumentationen mittels Microsoft Word oder Latex bietet das System jedoch gravierende Vorteile, da es komplett an die Datenstruktur und –hierarchie von Framework Studio angepasst ist. Features Um den Einstieg in das Dokumentationssystem zu vereinfachen, werden im Folgenden die wichtigsten Features vorgestellt. Automatische Generierung der Dokumentationsstruktur „Wo steht was?“ ist ein großes Problem im Bereich Dokumentation. Ein Mitarbeiter beschreibt erst die Steuerelemente des Formulars und danach dessen Funktionalität, ein anderer macht es genau anders herum. Framework Studio trennt sich vom klassischen Weg der Dokumentationserstellung. Egal, ob die Dokumentation später als Word oder HTML exportiert wird, die Struktur bleibt dieselbe. Jedes Formular folgt dem gleichen Schema, alles hat seinen zugewiesenen Platz durch vordefinierte Formatvorlagen seitens Framework Studio. Vererbung vom Metadatentyp bis zum Steuerelement Hinter fast jedem Steuerelement in Framework Studio verbirgt sich als DataSource ein Component Property, eine DBColumn oder ein Metadatentyp . Hier verhält sich die Dokumentation ähnlich wie die Tooltips. Wird ein Metadatentyp dokumentiert, steht diese Dokumentation auch am Steuerelement zur Verfügung und wird in die endgültige Fassung herausgerendert. Dokumentationen können vererbt, gecustomized und überschrieben werden, sollte sich z.B. der Kontext in einem Formular ändern. Customizing und Package-Struktur Das Herz von Framework Studio bildet das Package-System. Das Dokumentationssystem folgt diesem und bietet voll Customizing-fähige Dokumentationen über Package-Grenzen hinweg. Vererben, überschreiben, anhängen, austauschen… die Dokumentation ist anpassbar bis zum letzten Satz. Mehrsprachigkeit Erfassen Sie die Dokumentation in allen möglichen Sprachen. Der Dokumentationseditor unterstützt das parallele Bearbeiten von mehreren Sprachen. Wenn Sie die englische Dokumentation schreiben, nehmen Sie sich einfach die deutsche Dokumentation als Vorlage für die Übersetzung zur Hand. Screenshot-Generierung Screenshot erstellen, in das Grafikprogramm laden, den Ausschnitt zurechtschneiden, Screenshot in das Dokument einfügen, Größe anpassen… und nach einer Woche ist der Screenshot veraltet, weil drei neue Steuerelemente hinzugekommen sind. Um dieses Problem aus dem Weg zu schaffen, bietet das Dokumentationssystem eine Screenshot-Generierung für Formulare. Bei jedem Herausschreiben der Dokumentation wird von Framework Studio anhand der Steuerelementdaten des Designers ein Screenshot des Formulars erstellt und automatisch in die Dokumentation eingefügt. So sind die Masken in der Dokumentation stets auf dem neuesten Stand und der Benutzer findet jedes Steuerelement wo er es erwartet. Theme Support In Framework Studio 3.5 hielten Themes Einzug in die IDE. Die Dokumentation lässt sich für verschiedene Themes rendern. Sind beispielsweise automatisch generierte Screenshots in die Dokumentation eingebunden, werden diese im jeweiligen Theme gerendert. Auch für eingebundene Bilder können je Theme unterschiedliche Bilder definiert werden. Aufbau des Dokumentationssystems Die beiden Elemente, die das Fundament des Dokumentationssystems bilden, sind das Form- und das Documentation-Element (siehe Documentation-Element ). Diese Elemente werden mittels einer Baumstruktur (siehe Chapter Tree ) in Kapitel unterteilt. Somit bildet jedes Form- oder Documentation-Element ein Kapitel mit eigener Kapitelnummer in der fertigen Dokumentation ab. Form Sie erkennen Form an einem -Icon. Elemente des Forms mit Dokumentation: Ein Form definiert sich grundsätzlich durch dessen Controls. Jedes Control kann eine DataSource zugewiesen haben, die über ein Component Property auf eine DBColumn verweist, die wiederum einen Wert eines Metadatatypes kapseln kann. Diesem Mechanismus folgt das Dokumentationssystem. Es besteht die Möglichkeit, auf jeder einzelnen Ebene in Framework Studio eine Dokumentation zu hinterlegen, die von der nächst höheren Instanz verwendet werden kann (siehe Vererbung ). So können am Metadatentyp z.B. Informationen zum Wertebereich oder zur Genauigkeit angegeben werden. In der Dokumentation des Controls, welches auf diesen Metadatentyp verweist, kann z.B. die Dokumentation des Metadatentyps eingebunden werden und steht dem Leser somit als zusätzliche Information zur Verfügung. Während in der Dokumentation eines Controls ausschließlich auf die Funktion dessen eingegangen werden sollte, dient die Dokumentation des Formulars der generellen Beschreibung, d.h. es können beliebige Texte verfasst werden, die die Funktionalität des Formulars im Gesamten beschreibt. So können Beispiele, Prozesse, Arbeitsanweisungen usw. beschrieben werden. Im Gegensatz zu den Control-Dokumentationen werden Form-Dokumentationen in sogenannte Sections unterteilt. Diese dienen als Text-Trenner für das Customizing (siehe Customizing ). Documentation-Element Sie erkennen Documentation-Element an einem -Icon. Die meisten Dokumentationen einer Anwendung beziehen sich auf ein oder mehrere Formulare. Oft muss aber auch ein Hintergrundprozess wie z.B. eine Preisfindung oder ein Importvorgang dokumentiert werden, für den es keine visuelle Repräsentation gibt. Für diesen Zweck bietet Frameworks Studio die Documentation-Elemente. Sie sind eigenständige Elemente wie Forms, Workflows oder Components und können wie diese ein- und ausgecheckt werden. Documentation-Elemente im Namespace TreeView: Die Documentation-Elemente bestehen nur aus einem einzigen Dokumentationseditor. Wie Forms bildet jedes Documentation-Element in der fertigen Dokumentation ein eigenes Kapitel mit eigener Kapitelnummer ab. Anwendungsfall für ein Documentation-Element: Wenn auf einem Formular ein Button existiert, welcher z.B. den Preis eines Artikels anhand eingegebener Konditionen berechnet, könnte der Kalkulationsprozess dokumentiert werden. Hier bietet sich ein Documentation-Element an. In diesem wird der Kalkulationsablauf im Detail beschrieben, ohne Bezug auf das Formular oder den Button, von dem der Prozess ausgelöst wird. In der Dokumentation des Button-Controls kann nun ein Verweis auf das Documentation-Element eingefügt werden, welcher in der fertigen Dokumentation als Hyperlink verfügbar ist. Der große Vorteil ist: Sollte in einem anderen Programmteil derselbe Kalkulationsprozess aufgerufen werden, müsste dort nur auf das bereits existierende Documentation-Element verwiesen werden, ganz nach dem Motto „write once, read anywhere“ ."
  },
  "doc/tables/dbrun_mlstrings.html": {
    "href": "doc/tables/dbrun_mlstrings.html",
    "title": "dbRun_MLStrings (Business-Datenbank)",
    "keywords": "dbRun_MLStrings (Business-Datenbank) In dieser Tabelle werden die Fremdsprachen-Texte für die ML-Columns abgelegt. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Spalte Beschreibung ML_TableName Der Name der Datenbank-Tabelle (Uppercase) ML_ColumnName Der Name der MLColumn-Tabellen-Spalte (Uppercase) ML_FSRowID Die FSRowID des referenzierten Datensatzes. Diese kann für SQL-Abfragen verwendet werden. ML_Iso Der 2-stellige Iso-Code der Fremdsprache (Lowercase) ML_Text Der fremdsprachige Text (Langtext)"
  },
  "doc/tables/dbrun_config.html": {
    "href": "doc/tables/dbrun_config.html",
    "title": "dbRun_Config (Business-Datenbank)",
    "keywords": "dbRun_Config (Business-Datenbank) Diese Tabelle beinhaltet die Konfigurationen für den automatischen Datenbank-Update. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Die Einstellungen müssen manuell per SQL vorgenommen werden. Wenn keine Einstellung existiert, dann zieht automatisch die Default-Einstellung. Spalte Beschreibung ConfigKey Schlüssel (siehe unten) ConfigValue Wert (siehe unten) ConnectionGroup Der Name der Connection-Group. Bei <NULL> zieht die Einstellung für alle Connection-Groups. Wenn für eine Connection-Group eine Konfiguration angegeben ist, dann hat diese Priorität. ConfigKey UNICODE Dieser ConfigKey stellt das Unicode-Verhalten des Update-Assinstenten ein. In ConfigValue sind folgende Werte zulässig: Disabled (Default) Neue Spalten werden ASCII (VARCHAR/ CLOB) angelegt. Enabled Neue Spalten werden Unicode (NVARCHAR/ NCLOB) angelegt. Adjust Bestehende Spalten werden auf Unicode umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. Important Diese Einstellung hat zur Folge, dass die GESAMTE Datenbank angefasst wird. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. ConfigKey LOB Dieser ConfigKey steuert, wie der Update-Assistent mit Langtext-Spalten umgehen soll. In ConfigValue sind folgende Werte zulässig Normal (Default) Neue Spalten werden mit LOB-Typen angelegt. Adjust Bestehende Spalten werden auf LOB-Typen umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. SQL-Server: text => varchar(max) / image => varbinary(max) Oracle: varchar2(2000) => CLOB Important ACHTUNG! Diese Einstellung hat zur Folge, dass große Teile der Datenbank angefasst werden. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. Bei Oracle kann sein ggf. sein, dass einige ältere Programme (wie z.B. SQL-Business) nicht mit dem Datentyp CLOB umgehen können. In diesem Fall muss der Schalter auf Normal gesetzt werden."
  },
  "doc/sql/syntax.html": {
    "href": "doc/sql/syntax.html",
    "title": "SQL-Syntax",
    "keywords": "SQL-Syntax Framework Studio übersetzt alle SQL-Statements in die Syntax der verwendeten Ziel-Datenbank. Dazu werden alle Statements geparsed und für die Ziel-Datenbank wieder neu zusammengesetzt."
  },
  "doc/sql/datum-funktionen.html": {
    "href": "doc/sql/datum-funktionen.html",
    "title": "Datums-Funktionen",
    "keywords": "Datums-Funktionen GETDATE GETDATE ( ) Liefert das aktuelle Datum auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETDATE ( ) Oracle SYSDATE GETUTCDATE GETUTCDATE ( ) Liefert die aktuelle Weltzeit (UTC) auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETUTCDATE ( ) Oracle CAST(sys_extract_utc(systimestamp) AS TIMESTAMP) ADD_DAYS ADD_DAYS ( <Date Expression>, <Days> ) Addiert die übergebenen Tage zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( DAY, <Days>, <Date Expression> ) Oracle <Date Expression> + <Days> ADD_MINUTES ADD_MINUTES ( <Date Expression>, <Minutes> ) Addiert die übergebenen Minuten zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MINUTE, <Minutes>, <Date Expression> ) Oracle <Date Expression> + ( <Minutes> / 1440 ) ADD_MONTHS ADD_MONTHS ( <Date Expression>, <Months> ) Addiert die übergebenen Monate zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MONTH, <Months>, <Date Expression> ) Oracle ADD_MONTHS ( <Date Expression>, <Months> ) DAYS_BETWEEN DAYS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Tage zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF ( DAY, <Start-Date>, <End-Date> ) Oracle TRUNC ( <End-Date> - <Start-Date> ) MONTHS_BETWEEN MONTHS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Monate zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF (MONTH, <Start-Date>, <End-Date>) Oracle MONTHS_BETWEEN (<End-Date>, <Start-Date>) YEAR YEAR ( <Date Expression> ) Liefert eine 4-stellige Zahl, die dem Jahr des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server YEAR ( <Date Expression> ) Oracle EXTRACT ( YEAR FROM <Date Expression> ) MONTH MONTH ( <Date Expression> ) Liefert eine Zahl, die dem Monat des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server MONTH ( <Date Expression> ) Oracle EXTRACT ( MONTH FROM <Date Expression> ) DAY DAY ( <Date Expression> ) Liefert eine Zahl, die dem Tag (Tag des Monats) des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DAY ( <Date Expression> ) Oracle EXTRACT ( DAY FROM <Date Expression> ) HOUR HOUR ( <Date Expression> ) Liefert eine Zahl, die der Stunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( HOUR, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'HH24' ) ) MINUTE MINUTE ( <Date Expression> ) Liefert eine Zahl, die der Minute des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( MINUTE, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>,'MI' ) ) SECOND SECOND ( <Date Expression> ) Liefert eine Zahl, die der Sekunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( SECOND, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'SS' ) )"
  },
  "doc/sql/cast-funktionen.html": {
    "href": "doc/sql/cast-funktionen.html",
    "title": "Umwandlungsfunktionen",
    "keywords": "Umwandlungsfunktionen CHAR_TO_DATE CHAR_TO_DATE ( <Expression>, <format-Number>) Wandelt eine Zeichen-Kette in ein Datum um. Dabei wird das angegebene Format verwendet. Die Format-Nummer muss als konstante Zahl übergeben werden. Sie kann folgende Werte haben: Number Format YY Format YYYY 1 / 101 MM/DD/YY MM/DD/YYYY 2 / 102 YY/MM/DD YYYY/MM/DD 3 / 103 DD/MM/YY DD/MM/YYYY 4 / 104 DD.MM.YY DD.MM.YYYY 5 / 105 DD-MM-YY DD-MM-YYYY 6 / 106 DD MM YYY DD MM YYYY 7 / 107 Mon DD, YY Mon DD, YYYY 8 / 108 hh:mm:ss (24h) 10 / 110 MM-DD-YY MM-DD-YYYY 11 / 111 YY/MM/DD YYYY/MM/DD 12 / 112 YYMMDD YYYYMMDD 20 / 120 YYYY-MM-DD hh:mm:ss (24h) DATE_TO_CHAR DATE_TO_CHAR ( <date Expression>, <format-Number> ) Wandelt ein Datum in eine Zeichenkette um. Die Format-Nummer arbeitet wie bei der Funktion CHAR_TO_DATE. NUMBER_TO_CHAR NUMBER_TO_CHAR ( <Number Expression>, <Decimals>) Wandelt eine Dezimal-Zahl in einen Text um. Dabei wird die Zahl auf die übergebene Anzahl von Dezimal-Stellen gerundet bzw. abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, <Decimals> ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999.9999' ) ) Die Anzahl der Nachkommastellen ist gleich <Decimals> INT_TO_CHAR INT_TO_CHAR ( <Number Expression>) Wandelt eine Ganzzahl in einen Text um. Bei einer Dezimal-Zahl wird gerundet bzw. es werden die Dezimal-Stellen abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, 0 ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999' ) ) CHAR_TO_DECIMAL CHAR_TO_DECIMAL ( <Expression> ) Wandelt eine Zeichenkette in eine Dezimal-Zahl um."
  },
  "doc/mlkey/mlstring.html": {
    "href": "doc/mlkey/mlstring.html",
    "title": "MLString",
    "keywords": "MLString Framework Studio bietet eine durchgängige Unterstützung für die Mehrsprachigkeit. An allen Stellen, an denen für den Anwender sichtbare Beschriftungen, Tooltips oder Meldungstexte gepflegt werden bietet Framework Studio einen Editor zur Bearbeitung von mehrsprachigen Texten (Multi Language String / MLString ) an. Der Editor wird in Form einer Tabelle angezeigt, in der die Verschiedenen Sprachen des Textes angezeigt und bei Bedarf auch bearbeitet werden. Die fett gedruckten Angaben sind an dieser Stelle überschrieben. Die normal gedruckten Angaben sind aus dem Basis-Package oder dem Basis-Record geerbt. Siehe auch Abschnitt Vererbung . An erster Stelle steht immer der MLKey . Dieser stellt einen Verweis auf das Wörterbuch dar. Es kann direkt ein MLKey eingeben werden oder mit dem Auswahl-Button ein Such-Dialog geöffnet werden. Dabei handelt es sich um den voll funktionsfähigen Multilanguage Text Editor erweitert um eine Auswahl-Funktion. In diesem Dialog können, wenn kein passender MLKey gefunden wurde, auch ein neuer Key erfasst werden. Die Texte in den einzelnen Sprachen werden im Designer und auch zur Laufzeit der Anwendung aus dem Wörterbuch ermittelt. Die angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Important Ist ein MLKey angegeben, dann ist es davon abzuraten, einzelne Texte zu überschreiben. Im Property-Grid wird der MLString in einer Zeile dargestellt, die zur Anzeige der einzelnen Sprachen erweitert werden kann. Die einzeilige Anzeige stellt einen kombinierten Text in Format @{MLKey} - {deutscher Text} dar. In diesem Text man auch direkt mit vorangestellten @ -Zeichen einen anderen MLKey eintragen - z.B. @LBL_ArticleID . Ein MLKey kann auch (wie oben beschrieben) am entsprechenden MLKey-Eintrag eingetragen oder ausgewählt werden. Vererbung Mit den verschiedenen Records in Framework Studio werden auch die entsprechenden MLStrings vererbt. Dadurch werden im Idealfall die am Metadatentyp definierten Texte über die komplette Kette bis hin zu den Form-Controls durchgereicht. Ein vererbter Text kann an jeder beliebigen Stelle in der Kette überschrieben werden. Es gibt 2 Möglichkeiten: Einen anderen MLKey zuweisen Damit werden alle anderen Texte aus der Basis inkl. MLKeys und den überschriebenen Texten ausgeblendet. Auch wenn der neue MLKey z.B. keinen Text für fr definiert hat, wird ein in der Basis definierter fr Text ausgeblendet. Einen einzelnen Text überschreiben: Warning Darauf sollte möglichst verzichtet werden. Wenn lediglich die Übersetzung gepflegt wird, dann erfolgt dies besser im Wörterbuch. Wenn eine abweichende Bedeutung gewünscht ist, dann sollte ein anderer MLKey angegeben werden. Das überschreibt nur den Text der entsprechenden Sprache. Die anderen nicht überschriebenen Sprachen werden weiter aus der Basis gezogen. Caution In der eNVenta/WS Standard-Entwicklung ist das verboten. Das folgende Bild zeigt eine Vererbungs-Hierarchie. Die Pfeile stellen den Weg dar, über den der Text für das Control ermittelt wird. Dabei wird hier die Sprache fr mit den Fallback-Sprachen en und de verwendet. Der erste Text der auf diesem Weg gefunden wird, wird ausgegeben."
  },
  "doc/mlkey/mlkey-cleanup.html": {
    "href": "doc/mlkey/mlkey-cleanup.html",
    "title": "MLKeys Cleanup",
    "keywords": "MLKeys Cleanup MLKeys-Cleanup ist eine Wartungs-Routine, die bereinigungen im Wörterbuch durchführt. Sie kann über das Menu Tools / Checks / MLKeys Cleanup aufgerufen werden."
  },
  "doc/mlkey/enventa-regeln.html": {
    "href": "doc/mlkey/enventa-regeln.html",
    "title": "eNVenta Regeln für MLKeys",
    "keywords": "eNVenta Regeln für MLKeys Allgemeine Regeln Texte aus den Test-Namespaces : Diese sollen nicht ins Wörterbuch aufgenommen werden. Unübersetzbare Texte : Texte, die nicht übersetzt werden können wie z.B. Eigennamen, müssen mit dem Kommentar untranslatable versehen werden. Sind weitere Hinweise im Kommentar nötig, beginnt der Kommentar mit untranslatable gefolgt von einem Zeilenumbruch. Der Text soll in diesem Fall nur in der deutschen Sprache angegeben werden. Abkürzungen im Namen eines MLKeys : Werden im Namen eines MLKeys bewusst Großbuchstaben als Abkürzungen für Teilworte verwendet, weil z.B. der Name sonst zu lang würde, so muss die Abkürzung nach folgendem Schema im Comment erläutert werden: {Abkürzung1} = {Begriff1}, {Abkürzung2} = {Begriff2} Beispiele: LBL_CCServicePort : Comment = CC = Cross Company LBL_CCNameDebit : Comment = CC = Cost Center Bezeichnung von MLKeys Normalfall Begriffe: LBL_{englische Bezeichnung} Beispiel: LBL_Search Sätze: MSG_{GUID} Beispiel: MSG_f39ceca46b3341ee8b9862d34cfd06b6 Einheiten LBL_{englische Bezeichnung}_Unit Beispiel: LBL _mm_Unit Zeichen LBL_{englische Bezeichnung}_Sign Beispiel: LBL_Plus_Sign für den Text „+“ Ziffern LBL_{englische Bezeichnung}_Digit oder LBL_{englische Bezeichnung}_Digits (Plural) Beispiele: LBL_Nine_Digit für den Text „9“, LBL_EightOClock_Digits für den Text „08:00“ Prozentzeichen LBL_{englischer Prefix}Percent (kein Unterstrich) Beispiel: LBL_DiscountPercent (de = „Skonto %“, en = „Discount %“) Abkürzungen / Ausgeschriebene Texte Wenn für einen englischen Begriff im deutschen am häufigsten eine abgekürzte Schreibweise verwendet wird, so wird der MLKey für den Text mit Abkürzung normal mit LBL_{englische Bezeichnung} benannt. Wird parallel dazu auch der im deutschen (oder anderen Fremdsprachen) ausgeschriebene Text benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Full benannt. Wird zu einem Begriff, zu dem es schon eine ausgeschriebene Schreibweise gibt eine Abkürzung benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Abbrev bezeichnet. Beispiele: LBL_ClerkScanner (de = „SB-Scanner“), LBL_ClerkScanner_Full (de = „Sachbearbeiter Scanner“) LBL_Reminder (de = „Wiedervorlage“), LBL_Reminder_Abbrev (de = „Wiedervorl.“) Spezialfall: Ein Buchstabe als Abkürzung LBL_{englische Bezeichnung}_Char Beispiele: LBL_Order_Char (de = „B“, en= „O“) LBL_Container_Char (de = „B“, en = „C“) Beschriftung von Mini-Buttons LBL_{englische Bezeichnung}_Mini Wird ein MiniButton (Control Style = MiniEmpty) auf einer Maske mit einer Caption von 1 bis 2 Buchstaben versehen (die typischerweise eine Abkürzung darstellen), so wird der MLKey dazu mit der eigentlichen Bezeichnung, ergänzt um _Mini beschriftet. Dabei ist darauf zu achten, dass die Beschriftungen pro Sprache eindeutig sind. Beispiele: LBL_Customer_Mini (de = „K“, en = „Cu“) LBL_CrossOver_Mini (de = „C“, en = „Cr“) Zwei unterschiedliche deutsche Begriffe, die im Englischen gleich heißen Wenn zwei unterschiedliche Begriffe im englischen durch den gleichen Text beschrieben werden, so werden die Bezeichnungen der MLKeys durch Anhängen eines Zählers beginnend mit 1 im Format _{Zähler} unterschieden. Beispiel: de = „Herkunft“, en = „Source“ => MLKey = LBL_Source de = „Quelle“, en = „Source“ => MLKey = LBL_Source_1 Tooltips Wenn ein Tooltip eindeutig einem einfachen Begriff zugeordnet werden kann, so wird der MLKey mit TTT_{englische Bezeichnung} benannt. Andernfalls wird das Format TTT_{GUID} verwendet. Beispiele: TTT_Fatal (de = „Fatale Einträge anzeigen“) `TTT_584b58008ed04cd2b40b78b70e52402c' (de = „Wert für die Kreditorenvorerfassung-Pufferzeit definieren.“) Note Wenn man einen Tooltip verwenden möchte, zu dem es bereits einen exakt passenden LBL_ Eintrag gibt, so soll dazu kein TTT_ Eintrag angelegt werden! Diese Einträge wären sonst ja logisch äquivalent. Kleingeschriebene Begriffe Sollte man ein Text (z.B. wegen einer Verwendung in einer Textcollection) berechtigterweise klein geschrieben sein und es soll trotzdem ein sprechender Key generiert werden, so ist dieser ebenfalls klein zu schreiben. Beispiel: de = „eins“, en = „one“ => MLKey = LBL_one Texte Alle Texte in allen Sprachen beginnen mit einem großen Buchstaben. Ausnahmen: Abgekürzte Einheiten (z.B. mm) Einträge in Textcollections, soweit diese zwingend alle klein geschrieben werden müssen. Vor Satzzeichen werden keine Leerzeichen verwendet. Ganze Sätze werden mit einem Satzzeichen beendet. Im Englischen werden bei Texten mit bis ca. 4 Worte (Beschriftungen von Eingabefeldern, Menüs, Buttons usw.) alle Worte bis auf Füllwörter wie of , to , in , ... groß geschrieben."
  },
  "doc/mlkey/draft.html": {
    "href": "doc/mlkey/draft.html",
    "title": "Text-Collections",
    "keywords": "Text-Collections Text-Collections arbeiten ebenfalls mit MLKeys. Im Grunde sind sie eine Auflistung von MLKeys. Arbeitsweise Das Wörterbuch wird in xml-Dateien gespeichert. Diese liegen im Broker-Verzeichnis im Ordner lang . Die Dateien werden separat prop Package und Sprache mit dem folgenden Datei-Namen abgelegt: <package>.<iso>.lang.xml Beispiel: <broker-directory> |--lang | |--CustomPackage.de.lang.xml | |--eNVenta.de.lang.xml | |--eNVenta.en.lang.xml | |--eNVenta.fr.lang.xml | |--SystemPackage.de.lang.xml | |--SystemPackage.en.lang.xml Zur Laufzeit werden diese Dateien bei Bedarf einmalig für die benötigten Sprachen eingelesen. Dabei wird die Package-Hierarchie berücksichtigt."
  },
  "doc/mdt/metadatentypen.html": {
    "href": "doc/mdt/metadatentypen.html",
    "title": "Metadatentypen",
    "keywords": "Metadatentypen Die Idee der Metadatentypen kommt daher, dass bestimmte Felder innerhalb einer Anwendung immer wieder auftauchen (z.B. Artikelnummer, Kundennummer, ...). Deshalb können solche Felder an einer zentralen Stelle definiert werden, was Fehler in der Felddefinition verhindert und Redundanzen minimiert. Dabei werden Informationen wie das Label, das Datenformat, das zugehörige Control, die mehrsprachige Bezeichnung usw. hinterlegt, so dass sich der Arbeitsaufwand bei der späteren Arbeit mit dem Metadatentypen minimiert. Sie erkennen Metadatentypen an einem - Icon vor der Bezeichnung. Metadatentypen bearbeiten Um einen Metadatatypen zu bearbeiten, doppelklicken Sie den entsprechenden Eintrag auf der Registerkarte Namespaces . Der Metadatentyp wird im Hauptfenster des Framework Designers angezeigt. Der Metadatentyp kann in verschiedenen Teilen der Anwendung zum Einsatz kommen: Er kann auf unterster Ebene der Spalte einer DBTable zugeordnet werden. Er kann in Components oder Forms als Datentyp für Properties verwendet werden. Deshalb nehmen Sie an einem Metadatentyp verschiedene Einstellungen vor: Name : Geben Sie die Bezeichnung des Metadatentyps an. Datatype Database : Benennen Sie den Datentyp der Spalte in der Datenbank. Datatype Application : Gibt den FS-Datentyp des Metadatentyps an. Dieser Datentyp wird später in den Components und Forms gezogen. Die folgende Tabelle zeigt, welche Database-Datentypen mit welchem Application-Datatype kombiniert werden können: FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring Binary X Boolean X Byte X Date X DateTime X Time X Double X Currency X X X Single X X X Decimal X X Big Int X Integer X X Smallint X X X Tiny Int X X X Ansi String X Long Varchar X String X null X X X X X X X X X X X Warning Wenn Sie die Datentypen nachträglich ändern, kann das evtl. Auswirkungen auf Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren. Die Einstellungen für Size, Precision und Scale hängen von der Auswahl des Datatype Database ab. Je nachdem, ob der Datenbank-Datentyp Zeichen, Ganzzahlen oder Gleitkommazahlen unterstützt, sind die Felder für Eingaben zugänglich. Size : Definiert die Feldlänge bei Zeichenfeldern. Precision : Anzahl der Stellen inkl. eventueller Nachkommastellen bei numerischen Feldern. Scale : Anzahl der Nachkommastellen bei Dezimal -Feldern. Format : Gibt das Anzeige-Format des Felds an. Das Format wirkt sich in der Darstellung des Felds auf einem Form aus. Format Pattern : Wird im Feld Format User Defined gewählt, ist es möglich hier selbst ein Format anzugeben. Es können Formate für Zahlen, Daten und Zeichenketten entsprechend der Standard-Definition für reguläre Ausdrücke eingegeben werden. Siehe auch Format-Pattern Registerkarte Description Hier kann eine Beschreibung des Metadatentyps eingegeben werden. Registerkarte Values Für einen Metadatentypen kann definiert werden, welche Werte er annehmen darf. Wird hier nichts angegeben, sind alle Werte möglich, die der entsprechend hinterlegte Datentyp zulässt. Es können mehrere Werte oder Wertebereiche angegeben werden. From : Gibt die untere Grenze eines Wertebereichs an. Warning Ist nur dieses Feld gefüllt (und To nicht), wird dies als Wert und nicht als Wertebereich angesehen. To : Gibt die obere Grenze eines Wertebereichs an. Button Add New Range : Mit dem Button Add New Range kann ein neuer Bereich hinzugefügt werden. Button Remove Range : Mit dem Button Remove Range kann ein Bereich gelöscht werden. Registerkarte Default Label Einem Metadatentypen kann ein Label zugewiesen werden. Dieses Label wird im Form links neben dem Control des Metadatentyps angezeigt. Das Label kann mehrsprachig hinterlegt werden. Tip Es ist möglich, dieses Label in den Components und im Form zu überschreiben. Registerkarte Control Types Die Registerkarte ControlTypes zeigt an, welche Controls später im Form zur Verfügung stehen sollen. Es ist möglich, einem Metadatentypen mehrere Controls zuzuordnen. Es kann aber maximal ein Control als Default gekennzeichnet sein. Das als Default gekennzeichnete Control wird zunächst angezeigt, wenn ein Property (welches diesen Metadatentypen verwendet) in ein Form gezogen wird. Das Default-Control kann dann auf weitere, hier hinterlegte Controls geändert werden. Diese Liste von Controls kann auch im DBTable oder in der einer Component ergänzt werden. Ist kein Control als Standard-Control hinterlegt, wird ein Editfeld angenommen. Mit dem Button Add wird ein neuer Control-Type hinzugefügt. Es öffnet sich das Fenster Assign Controls. In diesem Fenster sind alle Controls aufgelistet, einschließlich der Controls, die Sie in den Control Default Styles definieren können (siehe Kapitel Control Default Styles). Wählen Sie hier ein Control aus und setzen Sie ggf. die Checkbox is Default . Mit dem Button OK wird das Control der Liste hinzugefügt. Mit dem Button Change können Sie das Control ändern. Es öffnet sich wieder wie bei Add das Fenster Assign Controls . Sie können hier ein anderes Control auswählen und dann mit OK bestätigen. Mit dem Button Delete wird das markierte Control gelöscht."
  },
  "doc/mdt/format-pattern.html": {
    "href": "doc/mdt/format-pattern.html",
    "title": "Format-Pattern im Metadatentyp",
    "keywords": "Format-Pattern im Metadatentyp Je nachdem, welcher Datentyp ausgewählt wurde, ändern sich die Einstellungen für das Format-Pattern. Format Pattern für Zeichenketten Bei Zeichenketten können im Format reguläre Ausdrücke eingegeben werden. Die Zeichenketten müssen dann dem definierten regulären Ausdruck entsprechen. Im Java-Client wird bereits bei der Eingabe überprüft, ob die Zeichenkette dem Ausdruck genügt. Format-Pattern für Zahlen Bei Zahlen können gewöhnliche Zahlenformate eingegeben werden. Neben dem Feld Format-Pattern wird eine Beispiel-Zahl für das eingegebene Format dargestellt. Warning Es ist aber zu beachten, dass als Tausender-Trennzeichen das Komma und als Dezimal-Trennzeichen der Punkt dient. Gültige Formate wären z.B. #,##0.00 ergibt 1.234,56 0.00 ergibt 1.234,56 #,##0.00 ’EUR’ ergibt 1.234,56 EUR Format-Pattern für Datum Bei Datum können gewöhnliche Datum-Formate eingegeben werden. Neben dem Feld Format-Pattern wird als Beispiel das aktuelle Systemdatum entsprechend formatiert dargestellt. Der Button Default Values setzt die Werte auf die vom Framework Studio vorgegebenen Standardwerte zurück."
  },
  "doc/html-client/funktionsumfang.html": {
    "href": "doc/html-client/funktionsumfang.html",
    "title": "Funktionsumfang",
    "keywords": "Funktionsumfang Der HTML-Client befindet sich noch in der agilen Entwicklung. Verglichen mit dem ausgereiften JavaClient ist der Funktionsumfang des HTML-Clients noch überschaubar. Neue Funktionen und die Unterstützung für weitere Controls werden kontinuierlich weiter entwickelt und veröffentlicht. Note Wird in diesem Kapitel etwas nicht erwähnt, wie z.B. ein Property eines Controls, eine Action oder andere Client-Funktionalitäten, so muss davon ausgegangen werden, dass diese noch nicht unterstützt werden. Handhabung von nicht unterstützten Funktionalitäten Es gibt im Form Designer oder im Code Editor von Framework Studio keine Limitierungen, die den Entwickler auf den Funktionsumfang des HTML-Clients einschränken. Werden Controls, Actions oder anderweitige Funktionalitäten genutzt, die vom HTML-Client nicht unterstützt werden, so werden diese (so weit es möglich ist) vom Client ignoriert. Wenn z.B. ein Grid-Control in ein Form eingebaut wird, so wird dieses erst garnicht vom HTML-Client interpretiert. Dasselbe gilt für nicht unterstützte Properties an Controls. Frameset Der HTML-Client besitzt kein Frameset. Alle geöffneten Forms werden in einer einzigen Liste organisiert. Es ist irrelevant, welchem Frame ein Form in einem Workflow zugeordnet ist. MessageBox und ExceptionBox Werden vollständig unterstützt inkl. Buttons, Icons, DialogResult und EventHandler. Werden im Client als modale Popups angezeigt. Modale Forms Modale Forms, die das Wechseln zu einem anderen Form unterdrücken, werden vom HTML-Client vollflächig angezeigt. Dabei wird der Menü-Button ausgeblendet. Verhalten beim Drücken des „Zurück“-Button auf einem mobilen Gerät: Wenn am Form das Property IsCloseIconVisible auf true gesetzt ist, wird der modale Dialog geschlossen. Wird dem Form über die Action SetCloseButton ein Button zugewiesen, dessen Click-Event beim Schließen ausgelöst werden soll, wird dies beim Drücken des Zurück-Button ebenfalls ausgelöst. Drag & Drop Drag & Drop und alle damit verbundenen Events werden vom HTML Client nicht unterstützt. Shortcuts und ToolTips Da für den HTML-Client die mobile Welt im Vordergrund steht, werden Shortcuts und ToolTips noch nicht unterstützt, da diese auf einem Handy bzw. Tablet keinen Sinn machen. Control Styles Control Styles werden für alle im HTML-Client verfügbaren Controls unterstützt. Wird im Form Designer einem Control ein Control Style zugeordnet, so werden dessen Properties korrekt interpretiert bzw. die Property-Hierarchie beachtet. Actions Es werden derzeit folgende Actions unterstützt: SetEnabled SetVisible SetCloseButton ScanBarcode Zurück-Button auf mobilen Geräten Mobile Geräte (z.B. Android) besitzen teilweise einen Zurück-Button. Der HTML Client unterstützt diesen kontextabhängig. Es gibt drei Prioritätsebenen, die nacheinander durchlaufen werden. Wird in einer Ebene auf das Drücken des Zurück-Buttons reagiert, so werden die darunter liegenden Ebenen nicht mehr behandelt. Die Ebenen geordnet nach Priorität sind: Overlays Modale Dialoge Normale Anzeige Overlays Als Overlay definiert sich alles, was sich mit einem ausgegrauten Hintergrund über die restliche Anzeige legt, wie z.B. MessageBoxen oder die ComboBox-Auswahl. Wenn ein Overlay geöffnet ist und der Zurück-Button gedrückt wird, wird das Overlay geschlossen. Eine MessageBox kann nur durch den Zurück-Button geschlossen werden, wenn ein Abbrechen-Button vorhanden ist. Modale Dialoge Modale Dialoge können mit dem Zurück-Button geschlossen werden, wenn das Property IsCloseIconVisible am Form auf true gesetzt ist. Wurde dem Form über die Action SetCloseButton ein Button mit einem Click-Event zugeordnet, so wird beim Drücken des Zurück-Buttons das Click-Event ausgelöst. Normale Anzeige Befindet sich der HTML Client in einem normalen Form, wird beim Drücken des Zurück-Buttons das Beenden der Application angestoßen, was mit der Rückfrage, ob die Session beendet werden soll, einher geht. Befindet sich der HTML Client im Broker-Auswahldialog, wird die Anwendung ohne Rückfrage geschlossen."
  },
  "doc/html-client/controls.html": {
    "href": "doc/html-client/controls.html",
    "title": "Controls",
    "keywords": "Controls Symbol Bedeutung + Property oder Event wird vollständig unterstützt - Property oder Event wird nicht unterstützt o Property oder Event wird teilweise unterstützt (Anmerkung beachten) Allgemein Die folgende Auflistung beinhaltet diejenigen Properties und Events, die an allen verfügbaren Controls im HTML-Client vorhanden sind. Properties Name Unterstützt Anmerkung Alignment + BackColor + BorderColor + BorderRadius + BorderThickness + ButtonGroupDataSource + Caption + DockPanel.ItemSize + Font Family - Ist im Client hart definiert auf die Hierarchie Arial -> Helvetica -> Sans-Serif. Font Bold + Font Italic + Font Underline + ForeColor + IsEditable + LabelTemplate + MapEnterToTabAction - Margin + MaxSize + MinSize + Name + Padding + Shortcut - TabStop + ToolTip + Visibility + Events Name Unterstützt OnCanDrop - OnDrag - Form Properties Name Unterstützt BadgeImage DataSource - IsCloseIconVisible + MainMenu - PreferredSize - SymbolImage - Title + VerticalScrollbarOverlay - Events Name Unterstützt OnLoad + OnClose + Dock Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - DockPanelOrientation + Spacing + Events Name Unterstützt OnEnter - OnLeave - Wrap Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - ContentAlignment + InvertFlowDirection + Spacing + WrapArrangement + Events Name Unterstützt OnEnter - OnLeave - Field Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - RowLabelTemplate + SynchronizeColumns + Events Name Unterstützt OnEnter - OnLeave - Field Row Properties Name Unterstützt FieldRowSize + LabelMode + OptimizeGeneratedLabels + Button Properties Name Unterstützt ShowCaption + TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + ImageButton Properties Name Unterstützt BadgeImage DataSource - CaptionAlign - ContextMenu - DataSource - DisabledImage + HighlightImage - Image + MouseOverImage + PressedImage + ScaleMode - ShowCaption + SymbolImage - TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + Label Properties Name Unterstützt DataSource + TextAlign + Events Name Unterstützt OnEnter + OnLeave + CheckBox Properties Name Unterstützt DataSource + ShowCaption + Events Name Unterstützt OnClick + OnEnter + OnLeave + Editfield Properties Name Unterstützt Anmerkung DataSource + DisabledBackColor o Wird dynamisch im Client berechnet DisplayLength + Editor o Nur \"PlainText”, \"HTML” wird nicht unterstützt Format + FormatPattern o Funktioniert nur mit Format \"Decimal\" Multiline + PasswordChar + Client generiert ein Password-Feld, wenn gesetzt, das Passwort-Zeichen selbst kann aber nicht geändert werden (in Web Browsern technisch nicht möglich). ScrollBars + SelectionEnd - SelectionStart - TabStop + TextAlign + WordWrap + Events Name Unterstützt OnEnter + OnLeave + OnValidated + ComboBox Properties Name Unterstützt DataSource + DisplayLength + EditStyle + List + ListOrder + MaxDropDownSize + TabStop + Events Name Unterstützt OnEnter + OnLeave + OnSelectionChanged + RadioButton Properties Name Unterstützt CaptionDataSource + DataSourceOnValue + Events Name Unterstützt OnEnter + OnLeave + OnClick + ListView Properties Name Unterstützt DataSource + ItemArrangement + ItemSize + SelectedItems + SelectionMode + SelectorPosition + Spacing + Template + Events Name Unterstützt OnEnter - OnLeave - OnItemActivated + OnItemSelectionChanged +"
  },
  "doc/mlkey/import-export.html": {
    "href": "doc/mlkey/import-export.html",
    "title": "MLKey Import / Export",
    "keywords": "MLKey Import / Export"
  },
  "doc/mdt/vererbung.html": {
    "href": "doc/mdt/vererbung.html",
    "title": "Vererbung von Metadatentypen",
    "keywords": "Vererbung von Metadatentypen Es ist möglich, Metadatentypen zu vererben. Das macht dann Sinn, wenn Metadatentypen aufeinander aufbauen und z.B. ein gemeinsames Format-Pattern verwenden. Sie können so in einem Basis-Metadatentyp mit allen Datentypen Controls und einem Default-Label definieren. Anschließend brauchen Sie diesen nur abzuleiten und die Ableitung hat die gleichen Eigenschaften wie die Basis. Dann können Sie noch z.B. das Label oder den Wertebereich ändern. In der Ableitung werden die nachträglich geänderten Werte fettgedruckt dargestellt. Eine Ableitung können Sie auf zwei Wegen erstellen: Einen Metadatentypen ableiten, indem Sie den Metadatentyp im Overview auswählen, den Button ( Derive ) drücken und in der Namespace-Auswahl angeben, in welchem Namespace die Ableitung angelegt werden soll. Einem vorhandenen Metadatentypen im Feld Base eine Basis (oder auch eine andere Basis) zuweisen. Warning Wird beim Ändern der Basis auch der Datentyp geändert, kann das evtl. Auswirkungen auf die Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren."
  },
  "doc/mdt/validierung.html": {
    "href": "doc/mdt/validierung.html",
    "title": "Metadatentyp-Validierung",
    "keywords": "Metadatentyp-Validierung Die Einstellungen, die am Metadatentyp zu sehen sind (z.B. Größe, Formatierung, Wertebereich, …), werden bei der Arbeit mit Properties herangezogen, um die Werte zu validieren und ggf. zu korrigieren. Auch der Client nutzt diese Informationen, um falsche Eingaben so früh wie möglich zu unterbinden. Die Zusammenhänge werden durch folgendes Schaubild erläutert: Die folgende Tabelle stellt dar, was passiert, wenn mit einem Wert gearbeitet wird, der denen am Metadatentyp definierten Kriterien nicht entspricht. Einstellung Lesen von Properties aus der Datenbank, die falsche Werte beinhalten Setzen von Properties Client Allgemein Values Value Ranges Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Strings Size Bei zu langen Strings wird auf dieser auf die Size gekürzt. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Uppercase, Lowercase Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Die Eingabe lässt nur Groß- bzw. Kleinbuchstaben zu. Format-Pattern (Regulärer Ausdruck) Es wird FSstring.Null zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Es wird zuvor noch versucht, den String mit Uppercase oder Lowercase zu korrigieren, wenn der reguläre Ausdruck selber Uppercase bzw. Lowercase ist. Wenn das funktioniert, dann wird der Wert in Uppercase bzw. Lowercase konvertiert. Numerische Werte Precision Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Scale (bei Dezimal-Zahlen) Der Wert wird „kaufmännisch“ gerundet. Der Wert wird „kaufmännisch“ gerundet. Die Eingabe wird begrenzt. Positive Integer, Negative Integer (bei Ganzzahlen) Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Das Minus-Zeichen wird bei der Eingabe unterdrückt bzw. automatisch hinzugefügt. Der Java-Client gibt bei der Eingabe eines falschen Wertes die folgenden Fehlermeldungen aus: Wenn das Format-Pattern (der reguläre Ausdruck) verletzt wird: Wenn ein Wertebereich verletzt wird:"
  },
  "doc/html-client/index.html": {
    "href": "doc/html-client/index.html",
    "title": "HTML-Client (Beta)",
    "keywords": "HTML-Client (Beta) Neben dem Java Client bietet Framework Studio auch einen HTML-Client für Desktop- sowie mobile Geräte an. Dieser befindet sich aktuell in der Beta-Phase und unterstützt noch deutlich weniger Funktionen und Controls als der Java Client. Was derzeit schon mit dem HTML-Client möglich ist, erfahren Sie in diesem Kapitel. Aktivieren des HTML-Clients Damit der HTML-Client über den Run Wizard und die Broker-Startseite gestartet werden kann, muss in der Application die Checkbox Supports Html Client gesetzt werden. Dies soll vermeiden, dass bisher existierende Applikationen ohne Weiteres im HTML-Client gestartet werden können, da diese sehr wahrscheinlich auf Controls und Funktionalitäten aufbauen, die derzeit vom HTML-Client noch nicht oder nicht vollständig unterstützt werden. Browser-Unterstützung Desktop Der HTML-Client basiert auf modernster Webtechnologie und benötigt deshalb auch einen aktuellen Browser für die Ausführung. Für Desktopsysteme empfehlen wir folgende Browser : Chrome Firefox Edge Safari (OSX) Auch alle weiteren Browser, basierend auf der Chromium-Engine (Opera, Vivaldi), funktionieren problemlos. Note Internet Explorer 11 kann auf Grund der betagten JavaScript-Engine nicht mehr verwendet werden. Mobile Endgeräte Eine auf den HTML-Client ausgelegte Applikation kann über die Broker-Startseite natürlich auch von einem beliebigen mobilen Gerät aus gestartet werden, welches über einen aktuellen Browser verfügt. Die Unterstützung der Browser im mobilen Umfeld ist sehr schwer zu beurteilen, da es gerade auf Android eine extrem große Auswahl gibt. Wir empfehlen deshalb folgende mobilen Browser : Chrome Firefox Edge Dolphin Android Browser (ab Android 5.1) Safari (ab iOS 10)"
  },
  "doc/application/application.html": {
    "href": "doc/application/application.html",
    "title": "Application",
    "keywords": "Application"
  },
  "doc/allgemein/options.html": {
    "href": "doc/allgemein/options.html",
    "title": "Options",
    "keywords": "Options Die Options können in der IDE über den Menüeintrag Tools / Options geöffnet werden. IDE (Registerkarte) Login Get DLLs Mit der Checkbox Enable option 'Include Debug DLLs' by default wird im Login dafür gesorgt, dass beim Get DLLs die vom Framework Compiler erzeugten Debug-Informationen gezogen werden. Das beinhaltet (soweit vorhanden) die Debug-Informationen der Basis-Packages. Appearance Error Display Wird die Checkbox Legacy Error Window gesetzt, kann erzwungen werden, dass die Errors in derselben Art und Weise ausgegeben werden, wie es bis Framework Studio 2.6 der Fall war. Background Image Wird die Checkbox Disable gesetzt, wird in der Framework Studio Umgebung kein Hintergrundbild mehr angezeigt. Dies kann zu einer Performancesteigerung bei Remote Sessions beitragen (z.B. VNC). Documentation Indicators Zeigt an den Controls im Form-Designer an, ob eine Dokumentation gepflegt ist, bzw vererbt wurde. Siehe Dokumentationsstatus von Steuerelementen Form Control DoubleClick Gibt an, was im Form-Designer passieren soll, wenn auf ein Control Strg + Doppelklick ausgeführt wird. RadioButton Show Control Events : Zeigt den Events-Dialog für das Control an. Diese Option ist sinnvoll für normale Entwickler. Der Documentation-Editor kann über das Context-Menü des Controls geöffnet werden. RadionButton Show Documentation : Zeigt den Documentation-Editor für das Control an. Diese Option ist sinnvoll für Benutzer, die viel an Dokumentationen arbeiten. Die Control-Events können über das Context-Menü des Controls geöffnet werden. Show form designer grid Gibt an, ob im Form-Designer das Raster-Grid angezeigt werden soll. Bei der Arbeit über Remote Desktop kann dieses Grid die Performance sehr stark verschlechtern. Languages in designer Hier können die Sprachen eingestellt werden, die in den MLStrings und im Wörterbuch angeboten werden sollen. Die Reihenfolge wird - sofern dies möglich ist - von den Designer-Fenstern berücksichtigt. Es werden kommasepariert die Iso-Codes der Sprachen angegeben - z.B. de,en,fr . Wird keine Angabe gemacht, werden in allen Designer-Fenstern immer alle verfügbaren Sprachen angeboten. Code Editor Font Family Hier können Schriftart und -größe für den Code-Editor angepasst werden. Go to Definition with Ctrl+DoubleClick Schaltet im Code-Editor die Funktion Go to Definition (F12) mit Strg + Doppelklick ein. Es kann sinnvoll sein, diese Funktion zu deaktivieren, wenn man diese Funktion öfters aus Versehen auslöst. Dann bleibt immer noch die F12-Taste oder das Context-Menü zum Aufruf dieser Funktion. Context Tooltip Gibt an, ob im Code-Editor Informationen zu Elementen angezeigt werden sollen, wenn mit der Maus auf Code-Teile gezeigt wird. Compile / Debug (Registerkarte) Broker Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Host Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Compile Rootdirectory Gibt an, unter welchem Ordner Framework Studio die Compile-Verzeichnisse erzeugen soll. Diese Einstellung muss manuell in der Datei FrameworkStudio.exe.config angepasst werden. Beispiel: <configuration> <appSettings> <add key=\"CompileBaseDirectory\" value=\"C:\\FS\\Compile42\" /> [...] Visual Studio Path Hier kann angegeben werden, wo Visual Studio installiert ist. Die aktuell von Framework Studio unterstützten Versionen von Visual Studio werden automatisch erkannt. Wenn eine andere Version oder Edition (z.B. Visual Studio Express) verwendet werden soll, kann das entsprechende Programm angegeben werden. Mit dem Button Reset wird der Wert auf die Original-Einstellung zurückgesetzt. Diese Einstellung wird für das Menu View / Compiled Code in Visual Studio in den Designer-Fenstern verwendet. Außerdem wird der Ordner aus dieser Einstellung verwendet, um für die Arbeit mit Services das Programm WcfTestClient.exe zu finden. Visual Studio Arguments Hier können die Kommandozeilen-Argumente für das Öffnen der Quellcode-Dateien angegeben werden. Beim Einsatz von Visual Studio können die Standard-Einstellungen %file% /Edit beibehalten werden. Der Platzhalter %file% steht für die zu öffnenden Dateien. Dieser werden in dem Format \"Datei1.cs\" \"Datei2.cs\"… übergeben. Wenn dieser Platzhalter nicht angegeben ist, dann werden die Dateien an der Parameter gestellt. Utilities (Registerkarte) Mit dem Button [...] kann jeweils ein Dateiauswahldialog geöffnet werden. SvcUtil Gibt den Pfad zur SvcUtil.exe des Windows SDK an. Diese wird für die Generierung des Services verwendet. InstallUtil Gibt den Pfad zur InstallUtil.exe des .NET-Frameworks an. Crystal Report Designer Gibt den Pfad zum Crystal Report Designer an. Diff Tool Hier kann die ausführbare Datei für das Diff Tool angegeben werden. Diff Tool Data Dir Hier kann das Datenverzeichnis für das Diff Tool angegeben werden."
  },
  "doc/index.html": {
    "href": "doc/index.html",
    "title": "Framework Studio Technische Dokumentation",
    "keywords": "Framework Studio Technische Dokumentation"
  },
  "articles/requirements.html": {
    "href": "articles/requirements.html",
    "title": "Systemvoraussetzungen",
    "keywords": "Systemvoraussetzungen Entwicklungs-Rechner Ein Rechner auf dem mit der Framework Studio IDE entwickelt wird bzw. ein Rechner oder Server auf dem der Framework-Compiler ausgeführt wird. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows 10 - mind. Version 18.03 Windows 8.1 Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 .NET Framework .NET Framework 4.8 - oder höher https://dotnet.microsoft.com/download/dotnet-framework/net48 Weitere Software Java-Runtime Crystal Reports Runtime Crystal Reports Designer Visual Studio: empfohlen zum Debuggen von Anwendungen Visual Studio 2012 Visual Studio 2010 Andere Versionen und Editionen können auf eigene Verantwortung in den IDE-Options konfiguriert werden. Anwendungs-Server Rechner, auf dem Broker oder mit Framework Studio veröffentlichte Services laufen. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 Client-Betriebssysteme: Ein Broker oder Service kann prinzipiell auf einem Client-Betriebssystem (Windows 8.1, Windows 10) installiert werden. In einer Produktiv-Umgebung wird aber dringend der Einsatz eines o.g. Server-Betriebssystems empfohlen. Auf Client-Betriebssystemen können nur sehr wenige Benutzer parallel arbeiten. .NET Framework .NET Framework 4.8 - oder höher Weitere Software Crystal Reports Runtime IIS Print-Server Der Print-Service benötigt eine Verbindung zur Runtime-Repository-Datenbank und er muss die gewünschten Drucker ansprechen können. Er wird nicht von der Anwendung direkt kontaktiert, deshalb kann auch ein Client-Betriebssystem verwendet werden. Print-Service Die hier aufgeführten Systemvorrausetzungen gelten für den Print-Service Version 4.2. Framework Studio ist kompatibel mit älteren Versionen des Print-Service. Kommen diese zum Einsatz, gelten die Systemvorrausetzungen für die jeweilige Version. Framework Studio Print-Service 3.11 Framework Studio Print-Service 3.10.3 Framework Studio Print-Service 3.9.10 Framework Studio Print-Service 3.8.14 Betriebssystem siehe Entwicklungs-Rechner Es wird der Einsatz eines 64-Bit Betriebssystems empfohlen. Wenn z.B. ein spezieller Drucker-Treiber nur unter 32-Bit funktioniert, kann der Print-Service auch unter 32-Bit eingesetzt werden. Weitere Software Crystal Reports Runtime .NET Framework 4.8 - oder höher Authentication-Server Authentication-Service Framework Studio Authentication-Service 3.9 Framework Studio Authentication-Service 3.9.1 (unterstützt Runtime Supervisor) Framework Studio Authentication-Service 3.8 oder 3.8.5 Betriebssystem siehe Anwendungs-Server Weitere Software .NET Framework 4.5 / 4.5.1 / 4.5.2 / 4.6 Oracle-Client Client-Rechner Rechner, auf dem die Anwendung mit dem Java-Client ausgeführt wird. Betriebssystem An das Betriebssystem werden grundsätzlich keine besonderen Anforderungen gestellt. Entscheidend ist, dass die Java-Runtime verfügbar ist. Ja nach Framework-Studio-Anwendung kann es ggf. weitere Einschränkungen geben. Windows 10 Windows 8.1 Windows 8 Windows 7 SP1 Windows Vista SP2 Windows Server 2012 Windows Server 2008 Ubuntu Linux Mac OS X 10.9 Weitere Software Java-Runtime Crystal Reports Designer - sofern Reports bearbeitet werden sollen Je nach Framework-Studio-Anwendung ggf. weitere Software Java-Runtime Die Java Laufzeit-Umgebung wird benötigt am Client-Rechner und auf dem Entwicklungs-Rechner zur Ausführung der Anwendung. Java 8 Crystal Reports Runtime Diese Runtime wird benötigt auf dem Anwendungs-Server, dem Print-Service und dem Entwicklungs-Rechner. SAP Crystal Reports Runtime engine for .NET Framework 13.0.9 oder höher. Bei 64Bit-Betriebssystemen muss die 64Bit-Version der Runtime verwendet werden. Crystal Reports Designer Der Crystal Reports Designer wird für die Bearbeitung der Crystal Reports auf dem Entwicklungs-Rechner benötigt und sofern erforderlich auch auf dem Client-Rechner. Crystal Reports 2008 Datenbank-Server Microsoft SQL Server 2014 - oder höher (Standard / Enterprise / BI) Microsoft SQL Server 2012 SP1 (Standard / Enterprise / BI) Die Express- und Developer-Editionen des SQL Server können zu Entwicklungs- und Test-Zwecken eingesetzt werden. Dabei sind aber entsprechende funktionale und lizenzrechtliche Einschränkungen seitens Microsoft zu beachten. Der Einsatz erfolgt auf eigene Verantwortung. Oracle 12.2 - oder höher (Standard / Enterprise) Oracle-Client Es ist kein Oracle Client erforderlich. Der Oracle Managed Provider bringt seine eigene Client-DLL mit. Important der Oracle ODP Provider ist veraltet (deprecated). Ein produktiver Einsatz wird nicht mehr supported. In einer zukünftigen Version wird er komplett entfernt. Für die Verwendung des Oracle ODP Providers muss ein Oracle-Client installiert werden: Oracle Client 12.1.0.1+ mit Oracle Data Provider for .NET 4 Oracle Client 11.2.0.3+ mit Oracle Data Provider for .NET 4"
  },
  "articles/release-4-2.html": {
    "href": "articles/release-4-2.html",
    "title": "Release-Information Framework Studio 4.2",
    "keywords": "Release-Information Framework Studio 4.2 4.2 Beta 2 (18.09.2019) Die Auslieferung umfasst das Paket FS_4.2.0_Beta_2_Setup_x64 Alle anderen Pakete wie Print-Service, Client-Launcher und Requirements können weiter aus Framework Studio 4.0 verwendet werden. Important Wenn Sie bereits mit der Beta 1 ein Repository auf 4.2 upgedatet oder ein neues Repository angelegt haben, dann führen Sie bitte die folgende Aktion aus: Im Programm-Verzeichnis die FrameworkStudioUpgradeDatabase.exe starten und am Repository anmelden. Den Update ausführen, um die verbleibenden 2 Scripte auszuführen. Korrigierte Fehler 2019099609 - Broker : Ist an einem Form-Control die Caption mit expliziten fremdsprachigen Text überschrieben, dann ziehen diese nicht zur Laufzeit. Es werden die Texte des MLKeys aus der Basis angezeigt. 2019099613 - Repository : Beim Update des Repositories von Version 3.11 auf 4.2 gibt es eine Exception im Script 4.0.0.0 2017.12.31 Version 4.0.0.0 . 2019099616 - Repository : Beim Update auf die Version 4.2 werden in den Text-Collections des System-Packages (ctDocumentationTexts, ctSystemMessages) die Texte durch MLKeys ersetzt. Dadurch sehen ältere FS-Versionen keine Texte mehr und es kommt zu Fehlern - z.B. beim Dokumentations-Export. 4.2 Beta 1 (13.09.2019) Die Auslieferung umfasst das Paket FS_4.2.0_Beta_1_Setup_x64 Alle anderen Pakete wie Print-Service, Client-Launcher und Requirements können weiter aus Framework Studio 4.0 verwendet werden. Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.2 Korrigierte Fehler Neben den Fehlern, die bereits bis einschließlich Framework Studio 4.0.14 korrigiert wurden, wurden in Framework Studio 4.2 die folgenden Fehler korrigiert: 2019089003 - Doku-System : Ausgeblendete Controls (hidden/Collapsed) werden im Doku-Screenshot nicht gerendert. 2019099502 - Repository : Alle Sublabeled Tabellen sollen aus Performance-Gründen mit einem Index auf die PackageID-Spalte versehen werden. Die folgenden Fehler wurden bereits für die Version 4.0.15 korrigiert und sind in der 4.2 Beta 1 ebenfalls korrigiert: 2019099320 - Java-Client : Im Metal Look & Feel wird an der aktiven Tab-Page eine falsche Border gezeichnet. 2019068382 - Java-Client : Unter Linux und MacOS werden die Menüs falsch dargestellt. Note Auf nicht-Windows-Systemen wird empfohlen, das Look & Feel \"Metal\" zu verwenden. Im Look & Feel \"Default\" können weiterhin Probleme auftreten. 2019099428 - Java-Client : Wird eine Datei sehr schnell per Drag&Drop auf die Anwendung gezogen, kann es nach Auswahl einer D&D-Aktion zu einer \"Java-Exception: null\" kommen. 2019047700 - IDE : Suche: Combobox zur Einschränkung auf den Elementtyp wird nicht angezeigt. 2017099728 - IDE : Im Service-Release ist der Get- und Set-Method-Code von Properties manchmal fälschlicherweise editierbar. 2019099379 - IDE : Wird im Run-Wizard bei einer Connection-Group das Runtime-Repository angegeben, und die dazugehörigen Connection steht nicht auf \"Imported\", dann prüft der der Update-Assistent von eNVenta diese Datenbank auf Änderungen. Dabei werden auch die Trigger des Repositories erkannt und zum Deaktivieren angeboten. Das hat erhebliche Fehlfunktionen im Repository zur Folge. Note Repository-Trigger werden jetzt erkannt und vom Update-Assistenten ignoriert. 2019088935 - Package-Merge : Die Eigenschaft \"Include Base Reports\" an ReportDocumentTypes soll generell nicht übertragen werden. Der Wert im Ziel-Package muss unverändert erhalten bleiben."
  },
  "articles/neuheiten-4-2.html": {
    "href": "articles/neuheiten-4-2.html",
    "title": "Neuheiten Framework Studio 4.2",
    "keywords": "Neuheiten Framework Studio 4.2 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen . Neue Systemvorraussetzungen In dieser Version gibt es einige Anpassungen bei den Systemvoraussetzungen . Im folgenden sind die wichtigsten Änderungen aufgeführt. 64 Bit Die folgenden Programme können nur noch auf 64-Bit Systemen installiert werden. Eine 32-Bit Installations-Routine wird nicht mehr angeboten: Framework Studio IDE / Package Manager Publish / Publish2Go Anwendungs-Broker Framework Studio Services 32-Bit wird weiterhin unterstützt für: Client-Rechner Print-Server .NET Framework 4.8 Framework Studio setzt auf das .NET Framework 4.8 auf. Dieses wird beim Ausführen der Installations-Routine (nach Rückfrage) automatisch installiert. Es ist nicht mehr im Requirements-Packet enthalten. Für eine manuelle Installation finden Sie das .NET Framework 4.8 direkt bei Microsoft unter https://dotnet.microsoft.com/download/dotnet-framework/net48 . Betriebssysteme Mit dem Umstieg auf das .NET Framework 4.8 können einige ältere Windows Betriebssysteme nicht mehr unterstütz werden. Es werden aktuell folgende Betriebssysteme unterstützt: Server Windows Server 2012 R2 - oder höher Client / Entwicklungs-Rechner Windows 10 (Version 18.03 - oder höher) Windows 8.1 Für die Endanwender-Rechner bzw. Terminal-Server gelten weiter die bisherigen Anforderungen. SQL-Server Es wird der SQL-Server 2012 oder höher unterstützt. Ältere Version (z.B. SQL-Server 2008) werden nicht mehr supported Oracle Server Es wird der Oracle Server 12.2 oder höher (18c, 19c, ...) unterstützt. Ältere Versionen werden nicht mehr supported. Oracle Client Es wird nur noch der Oracle Managed Provider unterstützt. Der Oracle ODP Provider ist veraltet (deprecated) und wird nicht mehr supported. C# 7 Mit dem Update auf das .net Framework 4.8 unterstützt Framework Studio auch die C# Sprach-Features bis zur Version 7.3. Eine Übersicht der Features bietet die Web-Seite: https://docs.microsoft.com/de-de/dotnet/csharp/whats-new/csharp-7 In der folgenden Liste werden einige Features genannt, die seit C# 6 hinzugekommen sind. Der Einsatz dieses Features ist in Framework-Studio empfehlenswert: out variables - inline-Deklaration (C# 7.0) Folgende Features können ggf. sinnvoll sein: Tuples (C# 7.0) - nur innerhalb von Methoden-Code (z.B. bei Linq-Queries), nicht als Parameter oder Rückgabe-Typ von Methoden Inferred tuple element names (C# 7.1) Tuples support == and != (C# 7.3) Pattern matching (C# 7.0) Local functions (C# 7.0) - aber nur sehr gut überlegt!! MLKey Wörterbuch Eine zentrale Neuerung in der Version 4.2 betrifft das Handling der fremdsprachigen Texte. Diese werden jetzt in einem zentralen Wörterbuch verwaltet. Bisher wurden alle Texte am jeweiligen Element (z.B. Metadatentyp, ComponentProperty, FormControl) gepflegt. Jetzt werden an allen diesen Stellen Schlüssel (MLKeys) angegeben, die auf das zentrale Wörterbuch verweisen. Dadurch hat man erst einmal etwas mehr organisatorischen Aufwand, aber auf längerer Sicht betrachtet bringt diese Vorgensweise viele Vorteile: Redundanzen werden vermieden, weil existierende Texte wiederverwendet werden können und sollen. Dadurch erhält man zudem in der kompletten Anwendung durchgängige und einheitliche Bezeichnungen. Die fremdsprachigen Übersetzungen können sehr einfach und zentral gepflegt werden. Besonders im Customizing-Package ist das von großem Vorteil, weil jetzt nicht mehr die einzelnen Elemente ausgecheckt werden müssen. Das Wörterbuch kann auch im Service-Release bearbeitet werden. Der Export und Import von Texten ist sehr einfach. Es wird das standardisierte TMX-Format verwendet. Texte können so zwischen verschiedenen Packages und Versionen ausgetauscht werden. Auch eine Übersetzung durch Werkzeuge oder externe Dienstleister ist dadurch deutlich einfacher als bisher. Eine detailliert Beschreibung der Funktionalität finden sie im Kapitel MLKey . Es ist sinnvoll, die Texte des eigenen Packages in das Wörterbuch zu überführen. Bitte beachten sie dazu die Hinweise und Anleitungen für die Migration . Code-Messages überarbeitet Die vom Exception- und MessageBox-Wizard generierten Code-Messages wurden überarbeitet. Das bisherige Konstrukt mit #region wurde durch eine Variante mit einem einfachen eingefärbten Kommentar // FSCodeMessage: ersetzt. Das macht den Quellcode kompakter und leserlicher – ohne extra aufklappen zu müssen. Der XML-Teil, welcher bisher die Informationen für die Wizard-Dialoge beinhaltet hat, entfällt. In der Vergangenheit konnte es sein, dass die XML-Informationen vom Code abwichen. Der Wizard hat dann den Code ignoriert und einfach ersetzt. Dadurch konnten wichtige Infos – wie z.B. ein MessageBox EventHandler – verloren gehen. Die Informationen werden jetzt aus dem Code geparsed. Kann (z.B. aufgrund von manuellen Anpassungen) der Code nicht geparsed werden, kann er nicht mehr durch den Wizard bearbeitet werden. Die Code-Messages können einen MLKey aus dem Wörterbuch verwenden. Die bisherige Variante mit TextCollection-Einträgen soll nach und nach durch die MLKeys ersetzt werden und so die ctMessage-TextCollections auslaufen. Bei MsgBox.Show() sind die Enum-Werte für Button und Icon leserlich ausgeschrieben. Bisher wurden dort nur die int-Werte verwendet. Die Konvertierung des bestehenden Codes in das neue Format erfolgt auf folgende Weise: Durch die MLKey-Konvertierungs-Routine – diese setzt alle Code-Messages automatisch auf einen MLKey und/oder das neue Format um. Durch manuellen Aufruf des Exception- oder MsgBox-Wizards. Beim Speichern wird der Code durch die neue Variante ersetzt. Bei beiden Konvertierungen wird nur der Code betrachtet - der alte XML-Teil wird ignoriert. Neue Messages werden immer im neuen Format generiert. Dabei ist es egal, ob ein Textcollection-Eintrag oder ein MLKey verwendet wird. Actions SetEnabled und SetVisible nullable Die Control-Actions SetEnabled und SetVisible haben neue Überladungen bekommen, welche das Zurücksetzen auf den im Property-Grid des Form-Designers eingestellten Wert ermöglichen. Dazu wurden folgende Überladungen ergänzt, bei denen der null -Wert zum Zurücksetzten verwendet werden kann: SetEnabled(bool? value) SetEnabled(FSbool value) SetVisible(FSVisibility? value) Caution Achtung, falls Reflection verwendet wurde! Sollte eine der ursprünglichen Methoden aus irgend einem Grund per Reflection angesprochen worden sein, so kann es nun zu dem Problem kommen, dass nicht mehr eine eindeutige, sondern mehrere Überladungen der Methode gefunden werden. Die Überladungen SetEnabled(bool value) und SetVisible(FSVisibility value) wurden entfernt, da Aufrufe vom Compiler direkt auf die entsprechenden Nullable-Überladungen umgelenkt werden."
  },
  "doc/sql/operatoren.html": {
    "href": "doc/sql/operatoren.html",
    "title": "Operatoren",
    "keywords": "Operatoren || Verbindet 2 Zeichenketten. Beispiel: SELECT column1 || ' - ' || colum2 FROM tabelle Bei Zeichen-Ketten muss dieser Operator verwendet werden. Der + - Operator ist nicht zulässig. Wenn dennoch der + - Operator verwendet wird, versucht der Parser dies zu korrigieren. Das ist möglich, wenn bei der Operation Zeichen-Ketten oder bestimmte Zeichenketten-Funktionen beteiligt sind. Nicht erkannt wird z.B. das Verbinden von 2 Spalten. In diesem Fall kann es zu Fehlern auf der Ziel-Datenbank kommen. + - * / Addiert, subtrahiert, multipliziert bzw. dividiert 2 Zahlenwerte. Der Framework Studio SQL-Parser versteht die im Folgenden beschriebenen Operatoren und Funktionen. Diese werden Datenbank-spezifisch umgesetzt und können bedenkenlos in selbst formuliertem Sql verwendet werden. Funktionen, die der Parser nicht kennt, werden direkt ohne Konvertierung an die Datenbank weitergegeben. Das bedingt, dass diese Funktionen von der Datenbank verstanden werden. Ggf. Ist es in solchen Fällen nötig, selbst dafür zu sorgen, dass das Sql datenbankspezifisch formuliert wird."
  },
  "doc/sql/num-funktionen.html": {
    "href": "doc/sql/num-funktionen.html",
    "title": "Numerische Funktionen",
    "keywords": "Numerische Funktionen ABS ABS ( <Numeric Expression> ) Liefert den absoluten Betrag einer Zahl TRUNC TRUNC ( <Numeric Expression>, <Decimals> ) Schneidet eine Dezimal-Zahl auf die angegebene Anzahl Stellen ab. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server ROUND ( <Numeric Expression>, <Decimals>, 1 ) Oracle TRUNC ( <Numeric Expression>, <Decimals> ) ROUND ROUND ( <Numeric Expression>, <Decimals> ) Rundet eine Dezimal-Zahl auf die angegebene Anzahl Stellen. POWER POWER ( <Numeric Expression>, <y> ) Potenziert eine Zahl mit y SQUARE SQUARE ( <Numeric Expression> ) Quadrat eine Zahl. SQRT SQRT ( <Numeric Expression> ) Quadratwurzel einer Zahl CEILING CEILING ( <Numeric Expression> ) Rundet eine Zahl auf. FLOOR FLOOR ( <Numeric Expression> ) Rundet eine Zahl ab. LOG LOG (<Float Expression> ) Natürlicher Logarithmus einer Fließkommazahl. LOG10 LOG10 ( <Float Expression> ) Logarithmus mit der Basis 10. EXP EXP ( <float Expression> ) Gibt den exponentiellen Wert des angegebenen float-Ausdrucks zurück. (e x ) SIN SIN ( <float Expression> ) Sinus einer Fließkommazahl. TAN TAN (<Float Expression> ) Tangens einer Fließkommazahl. SIGN SIGN ( <Number> ) Gibt das Vorzeichen der Zahl zurück. Negativ -> -1, 0 -> 0, positiv -> +1."
  },
  "index.html": {
    "href": "index.html",
    "title": "Framework Studio 4.2",
    "keywords": "Framework Studio 4.2 Andere Versionen können hier aufgerufen werden. Note Diese Dokumentation befindet sich noch im Aufbau. Diese Seite gliedert sich in folgende Teile, die über die Navigation im oberen Bereich aufgerufen werden können: 1.) Framework Studio 4.2 Hier finden sie Neuheiten, Release-Listen, aktuelle Informationen und Systemvorrausetzungen 2.) Technische Dokumentation Alle Dokumentationen und Anleitungen für die Framework Studio IDE, Programmier-Themen und andere Programme. 3.) Api-Dokumentation Umfasst eine generierte Dokumentation der von Framework Studio bereitgestellten Klassen und Schnittstellen."
  },
  "doc/themes/zwischen-themes-wechseln.html": {
    "href": "doc/themes/zwischen-themes-wechseln.html",
    "title": "Zwischen Themes wechseln",
    "keywords": "Zwischen Themes wechseln Sind im aktuellen Package oder in dessen Basis-Packages Themes definiert (und nicht auf Deprecated gesetzt) kann das aktive Theme über das Menü Tools > Choose Theme ausgewählt werden. Note Wird Framework Studio neu gestartet, wird IMMER das Default-Theme geladen. Menü zur Auswahl des aktiven Themes: Wenn das aktive Package über ein oder mehrere Basis-Packages verfügt, in denen auch Themes definiert sind, werden diese mit dem jeweiligen Package Namen angezeigt. Themes aus Basis-Packages: Das aktuell aktive Theme wird auch rechts in der Framework Studio Statusleiste angezeigt. Anzeige des aktiven Themes:"
  },
  "doc/themes/themeable-properties.html": {
    "href": "doc/themes/themeable-properties.html",
    "title": "Themeable Properties",
    "keywords": "Themeable Properties Um der Anwendung ein anderes Aussehen zu geben, können folgende Elemente auf Theme-Ebene angepasst werden: Applications Default Control Styles Resources (nur Bilder) Im Folgenden werden die verschiedenen Properties dieser Elemente aufgelistet, die im Rahmen eines Themes verändert werden können: Themeable Application Properties BackImage FocusHighlightColor Icon IsTransparent MenuBackColor MenuBackColorAlpha MenuItemBackColor MenuItemBackColorAlpha SplitterBackColor SplitterBackColorAlpha StartImage Themeable Default Control Styles Für jeden Default Control Style BackColor ForeColor Font IsEditable IsVisible IsTransparent EditField DisableBackColor TextAlign ImageButton CaptionAlign ScaleMode Picture ContentAlignment PictureScaleMode TabbedWindow TabAlignment TabLayout TreeView IsBorderVisible IsFirstExpandIconVisible IsHeaderVisible Themeable Resource Property Da Bilder die einzigen Ressourcen sind, die durch Themes angepasst werden können, ist auch das einzige Property, welches anpassbar ist, das Bild, welches die Resource definiert."
  },
  "doc/tables/ml_config.html": {
    "href": "doc/tables/ml_config.html",
    "title": "ML_Config (Business-Datenbank)",
    "keywords": "ML_Config (Business-Datenbank) Die ML-Columns arbeiten standardmäßig mit der Default-Sprache de Deutsch. Ist die \"führende\" Sprache nicht de , dann kann über diese Tabelle die korrekte Default-Sprache eingestellt werden. Das geschieht in der Business-Datenbank, wo auch die Übersetzungs-Tabelle dbRun_MLStrings abgelegt ist, welche die anderssprachigen Werte speichert. Die Einstellung muss in dieser Datenbank stehen, damit sichergestellt ist, dass die Übersetzungs-Tabelle immer mit derselben Konfiguration angesprochen wird - unabhängig davon, wie die Anwendung FS-seitig konfiguriert ist. Die Tabelle muss bei Bedarf manuell per SQL angelegt werden. Dazu können die folgenden Scripte verwendet werden. Das Iso-Sprach-Kürzel de muss entsprechend durch das gewünschte Iso-Sprach-Kürzel ersetzt werden. -- SQL-Server CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR(2), CONSTRAINT PK_ML_CONFIG PRIMARY KEY CLUSTERED (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); -- Oracle CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR2(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR2(2) NULL, CONSTRAINT PK_ML_CONFIG PRIMARY KEY (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); Caution Wenn die Konfiguration geändert wurde, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Die Konfiguration darf nicht nachträglich geändert werden, weil ansonsten die in der Übersetzungs-Tabelle abgelegten Texte nicht mehr stimmen. Wenn die Konfiguration zu Beginn bei Einrichtung der Business-Datenbank vorgenommen wird, dann muss im Anschluss sichergestellt werden, dass die Tabelle dbRun_MLStrings leer ist. Wenn bei einer Änderung der Konfiguration doch dbRun_MLStrings -Inhalte erhalten bleiben sollen, müssen alle Einträge, für die neue Default-Sprache gelöscht werden."
  },
  "doc/code-editor/index.html": {
    "href": "doc/code-editor/index.html",
    "title": "Code-Editor",
    "keywords": "Code-Editor Framework Studio bietet einen umfangreichen C#-Code Editor mit IntelliSense Funktion und Code Highlighting. Intellisense Der Code Editor beinhaltet die Funktionalität von IntelliSense, die kontextabhängig Code-Vervollständigung zur Verfügung stellt. Aufgerufen werden kann IntelliSense mit der Tastenkombination Strg + Leertaste an einer beliebigen Stelle im Code. Go to Definition Mit der Kombination Strg + Doppelklick oder über das Kontextmenü kann aus dem Code Editor heraus zu den angeklickten Zielen gesprungen werden. Dies funktioniert bei Properties und Methoden. Ausgenommen davon sind Methoden fremder Components. Go to Base Über den Eintrag Go to Base im Kontextmenü des Code Editors kann zu der Basis der aktuellen Methode navigiert werden. Compare with Base Über den Kontextmenüeintrag Compare with Base im Code Editor ist es möglich, Überschreibungen von Methoden mit deren Implementierung im Basis-Package zu vergleichen. Zum Vergleich wird ein externes Programm verwendet, welches mit dem Menüpunkt Tools / Options im Hauptfenster konfiguriert werden muss. (Vgl. Konfiguration von Method History Browser)"
  },
  "doc/themes/hierarchie-bei-mehreren-package-und-themes.html": {
    "href": "doc/themes/hierarchie-bei-mehreren-package-und-themes.html",
    "title": "Hierarchie bei mehreren Packages und Themes",
    "keywords": "Hierarchie bei mehreren Packages und Themes Wenn mehrere Packages übereinander liegen und mehrere Themes verfügbar sind, folgt Framework Studio einem gewissen Schema, woher die einzelnen Property-Werte bezogen werden. Dieses Schema ist für Properties der Applications, der Default Control Styles, sowie der Bilder der Ressourcen exakt gleich. Im folgenden Beispiel wird angenommen, dass 3 Packages übereinander liegen und im untersten Package (BasePackage) 2 Themes definiert wurden, die somit auch den anderen Packages zur Verfügung stehen. Das Property, welches hier betrachtet werden soll, ist die FocusHighlightColor (im Folgenden FHC) einer Application. Die FHC soll in der Package-Hierarchie wie folgt definiert sein: Theme-Definition für die FocusHighlightColor: Ist die FHC im aktuellen Package für das gewählte Theme nicht definiert (wie z.B. bei CustomPackage/Theme2), werden erst alle Basis-Packages durchsucht, ob dort das Property für das gewählte Theme gesetzt ist. Ist dies nicht der Fall, wird die gleiche Suche für das Property im Default-Theme angestoßen (siehe Pfeile). Anhand der folgenden Grafik soll nun erläutert werden, welche Werte die FHC je Package und Theme annehmen würde: Lookup-Pfad des Themeable Properties: Beispiel BasePackage/Theme1 Da im BasePackage für das Theme Theme1 die FHC explizit auf Purple gesetzt wurde, wird keine Hierarchiesuche angestoßen und die FHC ist somit Purple . Beispiel BasePackage/Theme2 Im BasePackage ist die FHC für das Theme Theme2 nicht definiert. Da das BasePackage kein weiteres Basis-Package hat, wird der Wert des Default-Theme zurückgegeben. In diesem Fall ist im Default-Theme auch nicht explizit ein Wert gesetzt, also wird die Standardfarbe für die FHC (Black) zurückgegeben. Beispiel CustomPackage/Theme1 Für Theme1 ist im CustomPackage keine FHC definiert, also wird im Basis-Package von CustomPackage (BasePackage) für das Theme1 nach der FHC gesucht. Dort ist Purple definiert und wird somit zurückgegeben. Beispiel CustomPackage /Theme2 Im CustomPackage ist die FHC für Theme2 nicht definiert. Es wird somit in BasePackage für Theme2 nach einem Wert gesucht. Dort ist ebenso kein Wert definiert. Es verbleiben keine weiteren Basis-Packages, also wird wieder vom CustomPackage aus durch die Hierarchie gesucht, diesmal jedoch mit dem Default-Theme (da für Theme1 in keinem Package ein Wert für FHC definiert wurde). Für das Default-Theme ist im CustomPackage der Wert Red für die FHC definiert und wird somit zurückgegeben. Beispiel AdditionalPackage/Theme1 In diesem Beispiel ist im AdditionalPackage für das Theme1 gleich ein Wert für die FHC definiert. Yellow wird sofort zurückgegeben. Beispiel AdditionalPackage /Theme2 Für Theme2 ist in keinem der Packages ein Wert für die FHC definiert. Somit wird die Package-Hierarchie für das Default-Theme nach einem Wert für die FHC durchsucht. Im AdditionalPackage wird für das Default-Theme gleich ein Wert Blue gefunden und zurückgegeben."
  },
  "doc/themes/einfuehrung.html": {
    "href": "doc/themes/einfuehrung.html",
    "title": "Einführung",
    "keywords": "Einführung Durch Themes wird die Möglichkeit gegeben, einer FS-Anwendung ein anderes Aussehen zu geben, ohne dabei auf die Geschäftslogik und damit den Sourcecode Einfluss zu nehmen. Beispiel FS-Demo mit Standard-Theme: Das Bild zeigt die FS-Demo-Anwendung, wie sie standardmäßig von Framework Studio erstellt wird. Im folgenden Bild wurde das Aussehen der Anwendung durch Hinzufügen eines Themes grundlegend verändert: In diesem neuen Theme wurden folgende Änderungen durchgeführt: Hintergrundbild geändert. Transparenz des Grids deaktiviert. Button-Images durch blaue Bilder ersetzt. Schriftfarbe der Labels auf blau gesetzt. FocusHighlightColor auf hellgelb gesetzt."
  },
  "doc/themes/aufraeum-routine.html": {
    "href": "doc/themes/aufraeum-routine.html",
    "title": "Aufräum-Routine",
    "keywords": "Aufräum-Routine Diese Routine ist verantwortlich dafür, Themes korrekt aus einem Package zu entfernen. Da nicht nur die Themes alleine von Framework Studio gespeichert werden, sondern auch Referenzen von den Applications, Default Control Styles und Ressourcen auf die Themes verweisen, müssen vor dem endgültigen Löschen der Themes erst alle Referenzen in diesen Elementen eliminiert werden. Gelöscht werden grundsätzlich alle Themes im aktuellen Package, die im Theme Manager auf „Deprecated“ gesetzt wurden. Es werden erst alle Applications, Default Control Styles und Ressourcen durchlaufen und jegliche Referenzen auf nicht vorhandene oder auf Deprecated gesetzte Themes eliminiert und danach die Themes an sich gelöscht. Mit dem Button im Theme Manager kann die Routine gestartet werden. Es erfolgt zur Sicherheit noch eine Abfrage, ob fortgefahren werden soll: Sicherheitsabfrage der Aufräum-Routine Bevor die Routine startet, wird von Framework Studio auf das Default-Theme gewechselt. Um Änderungen an den Applications, Default Control Styles und Ressourcen vornehmen zu können, müssen diese Elemente ausgecheckt sein. Dies wird von der Routine selbst übernommen. Ist ein zu bearbeitendes Element nicht ausgecheckt, wird es automatisch ausgecheckt und nach erfolgreichem Ablauf der Routine wieder eingecheckt. Sollte ein zu änderndes Element schon vom Benutzer ausgecheckt worden sein, wird die Routine die Änderungen am Element durchführen, es aber nach erfolgreichem Ablauf NICHT einchecken (Der Benutzer könnte schon andere Änderungen am Element vorgenommen haben, die er vielleicht noch gar nicht einchecken will). Der Ablauf der Routine selbst ist im Output-Fenster von Framework Studio einsehbar: Ablauf der Routine im Output-Fenster: Nun muss noch folgender Fall betrachtet werden: Was ist, wenn ein Package Theme-Informationen beinhaltet, die auf Themes verweisen, die im Basis-Package definiert wurden und dort gelöscht werden? Dafür wird noch einmal die Konstellation von 3 Packages und 2 Themes betrachtet: Theme-Definition für die FocusHighlightColor: Beide Themes sind im Package „BasePackage“ über den Theme-Manager angelegt worden. Nun gibt es 2 Szenarien, in denen „unnötige Theme-Daten“ in den aufgesetzten Packages (CustomPackage und AdditionalPackage) entstehen. Szenario 1 Im BasePackage werden z.B. beide Themes auf Deprecated gesetzt und die Aufräum-Routine ausgeführt. Danach ist im BasePackage nur noch das Default-Theme vorhanden und jegliche Informationen zu den Themes in den Applications, Default Control Styles und Ressourcen gelöscht. Da die Themes im BasePackage gelöscht wurden, sind diese nun auch nicht mehr in den aufsetzenden Packages auswählbar. Die Property-Informationen zu den Themes in den aufsetzenden Packages sind jedoch noch im Repository gespeichert. So ist die Information Yellow für die FHC für Theme1 im AdditionalPackage immer noch im Repository vorhanden, obwohl das Theme längst aus dem BasePackage gelöscht wurde. Dies hat zur Folge, dass bei jedem CheckIn/CheckOut der Application diese nunmehr sinnlose Information mitgeschleift wird. Es empfiehlt sich also, die Aufräum-Routine auch in den aufsetzenden Packages durchzuführen. Die Routine erkennt nicht nur auf Deprecated gesetzte Themes, sondern eliminiert auch jegliche Informationen zu Themes, die in der Package-Hierarchie nicht mehr auffindbar sind. Im konkreten Fall würde die Routine im AdditionalPackage die Application durchgehen, in der für Theme1 für die FHC Yellow definiert wurde. Sie erkennt dann, dass die das Theme Theme1 gar nicht mehr in der Package-Hierarchie auffinden kann (da es ja im BasePackage gelöscht wurde). Somit wird diese Property-Information aus dem AdditionalPackage gelöscht und die Application hat, bezogen auf die Themes, wieder einen sauberen Stand. Szenario 2 Da Framework Studio die Möglichkeit bietet, Packages beliebig in der Hierarchie anzuordnen, kann folgender Fall eintreten: Das BasePackage mit den 2 definierten Themes wird aus der Hierarchie entfernt und ein neues BasePackage wird an dessen Stelle gesetzt. In diesem neuen BasePackage sind jedoch die Themes überhaupt nicht definiert. Ab diesem Zeitpunkt ist die Situation wieder wie in Szenario 1. Die aufsetzenden Packages CustomPackage und AdditionalPackage haben in ihren Elementen Theme-Informationen für Themes, die gar nicht mehr in der Package-Hierarchie existieren. Das Starten der Aufräum-Routine in den Packages CustomPackage und AdditionalPackage würde diese Unsauberkeiten bereinigen. Note Wenn Themes gelöscht werden und die Aufräum-Routine in aufsetzenden Packages NICHT ausgeführt wird, hat dies funktional KEINEN Einfluss auf die Anwendungen. Es werden lediglich unnütze Daten im Repository von Version zu Version mitgeschleift ."
  },
  "doc/sql/grammatik.html": {
    "href": "doc/sql/grammatik.html",
    "title": "SQL-Grammatik",
    "keywords": "SQL-Grammatik Im Folgenden ist die Grammatik beschrieben, die vom Framework Studio SQL-Parser verstanden wird. Alle an die Datenbank geschickten Befehle müssen dieser Grammatik genügen, ansonsten kommt es zu SqlParser-Exceptions. Grammatik für SQL-Kommandos <select> SELECT [DISTINCT] { * | <resultColumn>[,…n] } FROM { <singleSource> | <joinSource> } [ WHERE <condition> ] [ GROUP BY <value>[,…n] [HAVING <condition>]] [ {UNION [ALL] | INTERSECT | EXCEPT} <select(ohne orderby)> ] [ ORDER BY <orderColumn>[,…n] ] <insert> INSERT INTO <identifierChain> ( <identifier>[,…n] ) { VALUES ( <value>[,…n] ) | <select> } <update> UPDATE <identifierChain> SET {<identifierChain> = <value> } [,…n] [ WHERE <condition> ] <delete> DELETE [FROM] <identifierChain> [ WHERE <condition> ] Grammatik für die Bestandteile der Kommandos <resultColumn> <identifierChain>.* | <value> [AS <identifier>] <singleSource> ( <singleSource> ) | <identifierChain> [ [AS] <identifier> ] <joinSource> ( <joinSource> ) | { <singleSource> | <joinSource> } { INNER | {LEFT | RIGHT | FULL} [OUTER] } JOIN { <singleSource> | <joinSource> } ON <condition> <condition> ( <condition> ) | NOT <condition> | <condition> {{ AND | OR } <condition>}[,…n] | <value> <predicate2> | EXISTS ( <select> ) <predicate2> { = | != | < | <= | > | >= } <value> | IS [NOT] NULL | BETWEEN <value> AND <value> | IN ( <select> | <value> [,…n] ) | LIKE <value> | LIKEESCAPE <value> <value> NULL | ( <value> ) | { - | + } <value> | <value> { + | - | * | / | “||” } <value> | <identifierChain> | [<identifierChain>.] <FunktionsName> ( [ <value> [,…n] ] ) | <searchedCaseWhen> | <simpleCaseWhen> | \"[[\" <natives sql fragment> \"]]\" | <stringLiteral> | <integerValue> | <decimalValue> <searchedCaseWhen> CASE {WHEN <condition> THEN <value>}[,…n] [ ELSE <value> ] END <simpleCaseWhen> CASE <value> {WHEN {<predicate2> | <value>} THEN <value>}[,…n] [ ELSE <value> ] END <orderColumn> <value> [ASC | DESC] <identifierChain> <identifier>[.<identifier>][,…n] <identifier> \"[\" <beliebige Zeichenfolge> \"]\" | <Wort, mit einem Buchstaben beginnend>"
  },
  "doc/sql/alpha-funktionen.html": {
    "href": "doc/sql/alpha-funktionen.html",
    "title": "Alphanumerische Funktionen",
    "keywords": "Alphanumerische Funktionen LENGTH LENGTH ( <text> ) Liefert die Länge des Ausdrucks LOWER LOWER ( <text> ) Text in Kleinbuchstaben. UPPER UPPER ( <text> ) Text in Großbuchstaben. LTRIM LTRIM ( <text> ) Schneidet die linken Leerzeichen der Zeichenkette ab. RTRIM RTRIM ( <text> ) Schneidet die rechten Leerzeichen der Zeichenkette ab. REPLACE REPLACE ( <text>, <search text>, <replace text> ) Ersetzt im übergebenen Text den Search-Text durch Replace-Text. SUBSTRING SUBSTRING ( <text>, <number start>, <number length> ) Gibt den Teil einer Zeichenkette zurück."
  },
  "doc/sql/aggr-funktionen.html": {
    "href": "doc/sql/aggr-funktionen.html",
    "title": "Aggregat-Funktionen",
    "keywords": "Aggregat-Funktionen COUNT COUNT ( <Expression> ) Liefert die Anzahl. MIN MIN ( <Expression> ) Liefert das Minimum. MAX MAX ( <Expression> ) Liefert das Maximum. SUM SUM ( <Number Expression> ) Liefert den Summe. AVG AVG ( <Number Expression> ) Liefert den Durchschnitt. VAR VAR ( <Number Expression> ) Liefert die Varianz. STDEV STDEV ( <Number Expression> ) Liefert die Standardabweichung."
  },
  "doc/comp/components.html": {
    "href": "doc/comp/components.html",
    "title": "Components",
    "keywords": "Components"
  },
  "doc/code-editor/code-messages.html": {
    "href": "doc/code-editor/code-messages.html",
    "title": "Code-Messages",
    "keywords": "Code-Messages Wenn Sie eine Methode eines Forms bearbeiten, stehen Ihnen Editoren zum komfortablen Erstellen und Bearbeiten von mehrsprachigen Ausnahmen (Exceptions) und Meldungen (Message-Boxen) zur Verfügung. Diese können Sie über die Buttons Exception Editor Wizard und Message Box Editor Wizard aufrufen. Wenn Sie eine Textcollection ändern, indem Sie beispielsweise einen neuen Eintrag erzeugen oder einen bestehenden Eintrag ändern, dann muss die Textcollection dazu in der aktuellen Version für Sie ausgecheckt werden. Benutzen Sie dazu den Button Edit Message . Andere Benutzer können nun die Textcollection nicht bearbeiten. Beim Verlassen des Message Box Editors bzw. Exception Editors wird die Textcollection automatisch wieder eingecheckt, so dass auch andere Benutzer wieder auf die Textcollection zugreifen können. Beide Editoren weisen nur sehr geringfügige Unterschiede auf. Radiobutton ML Key Hier können sie einen MLKey angeben. Mit dem Auswahl-Button neben dem Textfeld öffnet sich der Dialog Select ML Key . Dies ist die Standard-Option. Neue Meldungen sollten immer über das Wörterbuch gezogen werden. Radiobutton New Message Wenn Sie diesen Radiobutton auswählen, wird ein neuer Text in die ausgewählte Textcollection eingetragen. Important Wenn Sie einen neuen Text hinzufügen, müssen Sie auch die Textcollection kompilieren, da es sonst beim Ausführen des Programms Fehlermeldungen gibt. Radiobutton Change Message Wenn Sie diesen Radiobutton auswählen, können Sie mit dem Button Choose existing Message einen bestehenden Eintrag aus der angegebenen Textcollection auswählen oder mit dem Button Search nach einem bestehenden Eintrag suchen. Button Change Collection Mit diesem Button kann die Textcollection geändert werden, aus der ein Text ausgewählt werden soll, bzw. in welcher der neue Text eingetragen werden soll. Als Default-Wert ist die Textcollection ctMessages ausgewählt. Button Choose existing Message Mit diesem Button kann aus der gewählten Textcollection ein existierender Eintrag ausgewählt werden. Feld Collection Zeigt an, welche Textcollection ausgewählt ist. Button Search Mit diesem Button öffnen Sie einen Suchdialog. In diesem Dialog wird die Suche auf die Textcollection, die im Exception Editor / Message Box Editor angegeben ist, eingeschränkt. Die Suchfunktionalität ist identisch mit den Möglichkeiten, die auf der Registerkarte Search im Framework-Designer zur Verfügung gestellt werden. Text-Grid Ist ein MLKey ausgewählt, wird hier nur der Text angezeigt. Der ML Key kann über das Textfeld bzw. den Auswahl-Button geändert werden. Die Bearbeitung der Texte-Inhalte erfolgt über das Wörterbuch . In diesem Grid kann der Text der Message in den verschiedenen Sprachen eingegeben werden. Wurde mit Choose existing Message ein Eintrag ausgewählt, wird dieser geändert und in die Textcollection zurückgeschrieben. Alle vorhandenen Message-Boxen, die diesen Eintrag verwenden, sind ebenfalls davon betroffen. Dem Text können Parameter zugewiesen werden. Die Parameter werden in der Form {0}, {1} usw. angegeben. Jeder Parameter kann mehrmals verwendet werden. Der Beleg {0} für Kunde {1} hat sich geändert. Wollen Sie den Beleg {0} speichern? Die Parameter werden in der Textbox String.Format... gefüllt. Combobox Icon (nur Message-Box) Gibt an, welches Icon verwendet werden soll Error Exclamation Information Question None Combobox Buttons (nur Message-Box) Gibt an, welche Buttons angezeigt werden sollen. Wird OK ausgewählt, ist es nicht notwendig, einen Event-Handler zu hinterlegen. Werden andere Buttons ausgewählt, muss ein Event-Handler hinterlegt werden. AbortRetryIgnore OK OKCancel RetryCancel YesNo YesNoCancel Combobox Default (nur Message-Box) Gibt den Button an, der beim Anzeigen der Message-Box ausgewählt sein soll. So kann z.B. bei den Buttons YesNo durch Angabe von Button2 das versehentliche Betätigen des Yes -Button verhindert werden. Button1 Button2 Button3 Die Nummer des Buttons entspricht der Angabe bei Buttons. z.B. YesNoCancel bedeutet Button1 = OK , Button2 = No , Button3 = Cancel Button Event Handler (nur Message Box Editor) Mit diesem Button kann angegeben werden, ob mit dem Klick in der Message-Box (z.B. auf OK oder Cancel ) ein Event angestoßen werden soll oder nicht. Ist der Button gedrückt, erscheint rechts daneben eine Combobox, mit der evtl. bestehende Methoden ausgewählt werden können. Mit dem Button New wird ein neuer Event-Handler angelegt. Es wird eine Methode OnMsgBoxClick1 angelegt. Der Parameter MsgBoxEventArgs hat ein Property DialogResult, damit abgefragt werden kann, welcher Button gedrückt wurde. public void OnMsgBoxClick1(object sender, MsgBoxEventArgs e) { if (e.DialogResult == DialogResult.OK) { //Code for Ok. } } Combobox Severity (nur Exception Editor) Hier können Sie den Schweregrad der Ausnahme (0-3) festlegen. Add Inner Exception (nur Exception Editor) Wenn die Checkbox gesetzt ist, können Sie das Property InnerException füllen. Geben Sie dazu die zu übergebende Variable im Textfeld an. Geben Sie dazu im Textfeld den Namen der lokalen Exception-Variable an. Textbox String.Format... In dieser Textbox können die Parameter der Message angegeben werden. Es ist möglich im Message Text Parameter anzugeben. Dies geschieht mit {0}, {1} usw. Diese Parameter können im Text auch mehrmals verwendet werden. Für jeden dieser Parameter kann hier, mit Komma getrennt, ein Wert angegeben werden. Der erste Parameter steht für {0} , der zweite für {1} usw. this.oOrder.lngOrderID, this.oOrder.lngCustomerID Button OK Schließt den Dialog und fügt den generierten Message-Code in den Code-Editor ein. Button Cancel Schließt den Dialog und verwirft die Änderungen. Wenn der Message-Box-Editor mit OK verlassen wird, wird an die Stelle im Code, an der sich der Cursor befindet der Code generiert. // FSCodeMessage: Really delete article {0}? MsgBox.Show(this.Global.FormatMLKeyText(MLKeys.MSG_9188180c5ac64a5384141b553eef8105, this.oSelectedArticle.sName), \"\", MsgBoxButtons.YesNo, MsgBoxIcons.Question, new MsgBoxEventHandler(OnDeleteQuestionMsgBoxClick)); Durch eine farbige Markierung ist dieser Code im Code-Editor gut zu erkennen. Um die Code-Message nachträglich zu ändern, setzen Sie den Fokus irgendwo in den generierten Code-Block und drücken erneut den entsprechenden Wizard-Button. Es öffnet sich wieder der Editor wie oben und die Daten der Code-Message werden angezeigt und können geändert werden. Bei Bedarf können auch einzelne Bestandteile wie z.B. der MLKey oder ein Enum-Wert direkt im Code geändert werden. Caution Die Struktur des Code darf jedoch nicht geändert werden, weil dieser sonst für eine spätere Bearbeitung mit dem Editor nicht geparsed werden kann. Der Code darf nicht mehrzeilig sein."
  },
  "doc/mlkey/woerterbuch.html": {
    "href": "doc/mlkey/woerterbuch.html",
    "title": "Wörterbuch",
    "keywords": "Wörterbuch Alle mehrsprachigen Texte der Anwendung werden in einem zentralen Wörterbuch abgelegt. Organisiert werden die Einträge mit einem eindeutigen alphanumerischen Schüssel - dem MLKey . Die MLKeys und deren Texte können folgendermaßen genutzt werden: In den MLString -Properties überall in Framework Studio Im selbst geschriebenen Methoden-Code (siehe Programmierung ) In den Code-Messages (Exceptions, Message-Boxen) Multilanguage Text Editor Die Bearbeitung des Wörterbuchs erfolgt über den Multilanguage Text Editor . Dieser wird über das Menü Tools / Multilanguage Text Editor geöffnet. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Die Bearbeitung des Wörterbuchs funktioniert ohne Checkout-Mechanismus. Wenn mehrere Benutzer zur gleichen Zeit an denselben MLKeys arbeiten sollten, dann gewinnt derjenige, der zuletzt den Button Save drückt. Der Editor sammelt alle vorgenommenen Änderungen (Add, Edit, Delete) im Hintergrund. Mit dem Button Save werden diese in das Repository gespeichert. Dabei wird in einer Transaktion zuerst der aktuelle Stand frisch aus dem Repository gelesen, dann die Änderungen erneut auf diesen (evtl. durch einen anderen Benutzer veränderten) Stand angewendet und zuletzt der neue Stand wieder zurück in das Repository gespeichert. Das hat die Folge, dass nach einem Save Änderungen sichtbar sind, die zuvor von einem anderen Benutzer vorgenommen wurden. Eine Ausnahme sind die Basis-Packages. Diese werden aus einem Stand gezogen, den der FrameworkCompiler zum Zeitpunkt des Compile-Laufs in den Workspace gespeichert hat. Suchen von MLKeys Essentiell für die tägliche Arbeit ist das Auffinden von existierenden MLKeys. Dazu wird das Search Feld angeboten. Die Suche scannt alle Felder des MLKeys: MLKey, Comment, Obsolete, Texte. Die Groß-Klein-Schreibung wird nicht berücksichtigt. Es können mehrere Worte eingegeben werden. Dann müssen alle Worte oder Wortteile in irgend einem Feld auftauchen. z.B. MSG_ Artikel Save sucht nach Messages die mit Artikel und Save zu tun haben. Generell wird nach Wortteilen gesucht. Wenn man das Wort oder den Text in Anführungszeichen setzt, wird nach einem exakten Treffer und ganzen Worten gesucht. Das funktioniert auch mit mehreren Worten und in Kombination mit der normalen Suche. z.B. LBL_ \"Kunde\" Ziel des Wörterbuches ist es, Texte wiederzuverwenden und die Anzahl der Einträge auf das Nötigste zu reduzieren. Aus diesem Grund sollte man immer zuerst nach einem MLKey suchen, bevor man einen neuen erfasst. Zu einem logischen Begriff sollen keine zwei MLKeys existieren. Tip Die Suche sollte durchaus kreativ gestaltet werden - besonders bei Texten die eigentlich schon vorhanden sein müssten. Ein Beispiel dafür ist das Wort Einfügen . Möchte man dieses mit der englischen Bezeichnung Add nutzen, stellt man fest, dass es Einfügen schon mit mehreren Übersetzungen gibt, jedoch keine mit der englischen Bezeichnung Add . Sucht man dann aber direkt nach Add , so findet man den statt Einfügen zu verwendenden deutschen Text Hinzufügen . Erfassen neuer MLKeys Mit dem Button Add öffnet sich ein Dialog, in dem der neue MLKey erfasst werden kann. MLKey : Hier wird der MLKey angegeben. Im Customizing-Package wird der Package-Code automatisch vorbelegt. Note Der MLKey kann zu einem späteren Zeitpunkt nicht mehr geändert werden. Der MLKey kann frei vergeben werden, es gibt jedoch ein paar Regeln und Empfehlungen: Es handelt sich um einen C#-Identifier, der auch im Quellcode verwendet wird. Buchstaben, Zahlen, Unterstrich Groß-Klein-Schreibung ist relevant Der sprechende Name sollte sich nach Möglichkeit an den englischen Text anlehnen. z.B. LBL_Article Wenn der Text zu komplex ist - z.B. bei Messages oder Tooltips, dann kann der Name eine Guid enthalten. Diese kann mit dem Button Generate Guid angefügt werden. z.B. MSG_1c9f3024dfc340dfba0651cb92d90ad6 In Customizing-Packages erhält der MLKey einen Package-Code. Dieser wird automatisch vorbelegt. z.B. LBL_K87_SpecialArticle In der eNVenta/WS Standard-Entwicklung sind entsprechende Namensregeln einzuhalten. Wird dieser Dialog aus der MLKey-Suche heraus geöffnet, dann wird abhängig vom jeweiligen Context auch ein passender Präfix vorbelegt: LBL_ / LBL_<PackageCode>_ : Der Suchdialog wurde z.B. aus einem Caption- oder Default-Label-Property aufgerufen. TTT_ / TTT_<PackageCode>_ : Der Suchdialog wurde aus dem Tooltip-Property aufgerufen. MSG_ / MSG_<PackageCode>_ : Der Suchdialog wurde aus dem MessageBox- bzw. Exception-Wizard aufgerufen. Comment : Der Kommentar beschreibt bei Bedarf den MLKey genauer. Das ist sinnvoll, wenn der Text oder auch der MLKey erklärungsbedürftige Abkürzungen beinhaltet oder wenn es ähnliche Texte mit verschiedenen Verwendungszwecken gibt. Obsolete : Ein MLKey kann durch die Eingabe einer Obsolete-Message als veraltet markiert werden. Der Compiler wird bei Verwendung dieses MLKeys diese Message als Warning ausgeben. Weil das Löschen von MLKeys vor allem im Hinblick auf Customizing-Packages Compile-Errors erzeugt, sollte davon abgesehen und stattdessen diese Obsolete-Message verwendet werden. Ein Hinweis auf einen alternativ zu verwendenden MLKey ist empfehlenswert. German : Die Eingabe eines deutschen Textes ist Pflicht, weil Deutsch immer der letzte Fallback ist, wenn eine Fremdsprache nicht gepflegt ist. Fremdsprachen : Über die Radio-Buttons kann festgelegt werden, welche Sprache im 2. Textfeld angezeigt oder bearbeitet werden soll. Diese Texte sind optional. Die angebotenen Fremdsprachen und deren Reihenfolge kann in den Options mit der Einstellung Languages in designer eingestellt werden. German lässt sich in diesem Dialog aber nicht steuern - diese Sprache wird immer im separaten Feld angezeigt. In der eNVenta/WS Standard-Entwicklung muss der englische Text gepflegt werden. Button Untranslatable : Es gibt Texte, die nicht übersetzt werden können wie z.B. Eigennamen oder Einheiten. Dieser Button löscht alle Fremdsprachen-Texte und Schreibt den Text untranslatable in das Comment Feld. Mit der Routine MLKeys Cleanup kann diese Aktion systematisch für das komplette Wörterbuch ausgeführt werden. Bearbeiten von MLKeys Mit dem Button Edit wird für den selektierten MLKey der Bearbeitungs-Dialog geöffnet. Durch einen Doppelklick in das Grid kann der Bearbeitungs-Dialog ebenfalls geöffnet werden. Dabei wird der Fokus automatisch in das Feld gesetzt, das der angeklickten Grid-Zelle entspricht. Das ist praktisch, wenn man z.B. gezielt eine Fremdsprache bearbeiten möchte. Außerdem können einzeilige Texte direkt im Grid bearbeitet werden. Note Die logische Bedeutung des MLKeys darf zu einem späteren Zeitpunkt nicht mehr geändert werden. Der Dialog ist gleich aufgebaut wie der Add-Dialog. Es werden zusätzlich das Create Date des MLKeys und die Edit Dates der Fremdsprachen-Texte angezeigt. Der MLKey kann nicht bearbeitet werden. Wird im Customizing-Package ein MLKey aus dem Basis-Package geöffnet, dann sind einige weitere Felder für die Bearbeitung gesperrt: Comment / Button Untranslatable , Obsolete Die Texte können bearbeitet werden. Mit dem Button View History wird ein weiteres Fenster geöffnet, in dem die Version des Eintrages vor der letzten Bearbeitung angezeigt wird. Siehe Abschnitt History . Copy Entry / Paste Entry Wenn man ein oder mehrere Einträge selektiert hat, kann man mit dem Button Copy Entry diese in die Zwischenablage kopieren. Mit dem Button Paste Entry können diese Einträge z.B. in einer anderen Version des Packages eingefügt werden. Intern benutzt diese Funktion den Import- / Export-Mechanismus . Dieser verwendet ein XML im TMX-Format. Dadurch ist es möglich, das XML vor dem Paste Entry bei Bedarf in einem Text-Editor zu manipulieren, z.B. um den PackageCode des MLKey anzupassen. Mit Paste Entry werden neue MLKeys hinzugefügt. Enthält die Zwischenablage existierende Keys, dann wird vor dem Einfügen ein Auswahl-Dialog angezeigt. Ignore : Es werden keinerlei Einträge ersetzt. Lediglich unbekannte, neue MLKeys werden hinzugefügt. Replace : Es wird der komplette existierende Eintrag ersetzt. Wenn in der Zwischenablage ein Wert nicht gesetzt ist, dann wird dieser entfernt. Merge : Die beiden Einträge werden zusammengeführt. Dabei gewinnt jeweils der Text mit dem neueren Edit-Date. Mit dem Button Cancel wird die komplette Aktion abgebrochen. Dann werden auch keine MLKeys hinzugefügt. Customizing Jedes Customizing-Package verwaltet sein eigenes Wörterbuch. Es können neue MLKeys angelegt werden. Diese müssen den Package-Code enthalten, damit es in Zukunft keine Kollisionen mit Basis-Packages gibt. Bevor ein neuer MLKey angelegt wird, sollte immer geprüft werden, ob es nicht doch einen passenden MLKey gibt. Texte aus Basis-Packages können überschrieben bzw. ergänzt werden. So können z.B. Übersetzungen für Fremdsprachen gepflegt werden. Es muss darauf geachtet werden, dass die Bedeutung des MLKeys nicht geändert wird, weil dieser ggf. an mehreren Stellen in der Anwendung verwendet wird. Wird an einer bestimmten Stelle in der Anwendung ein anderer Text benötigt (in eNVenta kann das z.B. der Text \"Code1\" sein, der ersetzt werden soll) dann muss an dieser Stelle (jedoch möglichst weit unten in der DBColumn oder Metadatentyp) ein anderer MLKey zugeordnet werden. (siehe auch MLString-Vererbung ) Im Customizing-Package übersetzte Texte können exportiert und in das Basis-Package importiert werden. Zu einem späteren Zeitpunkt können die dann redundanten Übersetzung mit der MLKeys Cleanup Routine bereinigt werden. History Bei jeder Bearbeitung im Wörterbuch wird die Vorgänger-Version des MLKeys in einen separaten History-Bereich geschrieben. Aus dem Edit-Dialog heraus kann diese Information mit dem Button View History geöffnet werden. Gibt es keine Informationen, ist der Button deaktiviert. Die History arbeitet pro Sprache. Wird z.B. der englische Text bearbeitet, wird auch nur der alte englische Text mit seinem alten Änderungs-Datum in den History-Bereich übertragen. Die History-Informationen der anderen Sprachen bleiben unverändert. Eine leere Eigenschaft wird nicht historisiert - das gilt insbes. für Comment und Obsolete Message . Wird eine dieser Eigenschaften geleert, dann verbleibt der alte Text auch dann in der History, wenn später wieder ein neuer Text gesetzt wird. Wird ein MLKey gelöscht , wird der komplette Eintrag mit allen Sprachen in die History übertragen. Dieser kann jedoch zu einem späteren Zeitpunkt nicht mehr ohne weiteres gegriffen werden. Tip Wurde ein MLKey versehentlich gelöscht und es gibt einen Compile-Error mit dem entsprechenden MLKey, dann kann man diesen Eintrag wieder neu im Wörterbuch anlegen. Beim anschließenden Bearbeiten des MLKeys können dann die noch existierenden History-Informationen eingesehen werden. Gefüllt wird die History mit dem Save -Button. Framework Studio sammelt alle im Wörterbuch vorgenommenen Änderungen und speichert diese mit dem Save -Button in einem Rutsch. Dadurch kann ein Text auch mehrfach hintereinander geändert werden. Erst nach dem Save steht der alte Text in der History. Note Beim Labeln der Package-Version wird die History-Information nicht in die neue Package-Version übernommen. Die History-Informationen berücksichtigen nur das aktuelle Package. Weil für Basis-Packages das Wörterbuch aus dem letzten Framework-Compiler-Stand gelesen wird, enthält es keine History-Informationen."
  },
  "doc/mlkey/programmierung.html": {
    "href": "doc/mlkey/programmierung.html",
    "title": "Programmierung mit MLKeys",
    "keywords": "Programmierung mit MLKeys Klasse MLKeys Framework Studio generiert aus dem Wörtebuch eine Klasse MLKeys , die alle MLKeys beinhaltet. Sie wird im Compile-Schritt Ressource compiliert und steht somit in der kompletten Applikation zur Verfügung. Sie erbt die MLKeys aus dem Basis-Package - so z.B. auch die SYS_ -Keys aus dem System-Package. Die Klasse wird z.B. folgendermaßen verwendet: this.Global.GetMLText( MLKeys.LBL_Amount ); Alle Quellcodes, die mit MLKeys arbeiten, greifen auf diese Klasse zu - sowohl selbst geschriebener Methoden-Code als auch der von Framework Studio generierte Code. Dadurch findet der CSharp-Compiler alle Probleme, die im Zusammenhang mit MLKeys auftreten können: Compile-Error, wenn ein MLKey nicht mehr existiert. Auch wenn diese z.B. in einem Metadatentypen oder einem Form-Control verwendet werden. Eine Obsolete-Warning, wenn ein mit einer Obsolete-Message versehener MLKey verwendet wird. Die Obsolete-Message wird als Obsolete -Attribut vor den MLKey generiert. Eine Warning, wenn in einem Customizing-Package ein identischer MLKey definiert ist. Die generierte MLKeys -Klasse sieht in etwa so aus: public class MLKeys : BasisPackage_MLKeys { public static readonly MLKey LBL_Amount = new MLKey(\"LBL_Amount\"); public static readonly MLKey LBL_Article = new MLKey(\"LBL_Article\"); public static readonly MLKey TTT_Article = new MLKey(\"TTT_Article\"); public static readonly MLKey MSG_0da9815a719049ae806d3c0ba7d824ff = new MLKey(\"MSG_0da9815a719049ae806d3c0ba7d824ff\"); public static readonly MLKey MSG_0f2ad9d4385b49fc9667ed7eff2d925f = new MLKey(\"MSG_0f2ad9d4385b49fc9667ed7eff2d925f\"); [Obsolete(\"Please use LBL_Amount\")] public static readonly MLKey LBL_Amount2 = new MLKey(\"LBL_Amount2\"); } Warning Es sollten keine eigenen MLKey-Instanzen aus Strings erzeugt werden. Diese können vom Compiler nicht validiert werden. Code Editor Der Code-Editor bietet diverse Unterstützung bei der Arbeit mit der Klasse MLKeys . Im Intellisense werden alle MLKeys angeboten und im jeweiligen Tooltip wird zur besseren Orientierung der deutsche Text angezeigt. Fährt man mit der Maus über einen MLKey, dann wird ein Info-Tooltip mit dem deutschen Text angezeigt. Wird auf einem MLKey der Befehl Goto Definition (F12) ausgeführt, dann öffnet sich der Multilanguage Text Editor und es wird der entsprechende Eintrag selektiert. Methoden am Global-Object Das GlobalObject bietet mehrere Methoden an, mit denen ein MLKey in ein Text überführt werden kann. GetMLText public string GetMLText(MLKey mlkey) Diese Methode ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. public string GetMLText(MLKey mlkey, string iso) Bei dieser Variante wird der Iso-Code der gewünschten Sprache übergeben. Beispiel: FSstring sArticleLabel = this.Global.GetMLText( MLKeys.LBL_Article ); FSString sAmountEn = this.Global.GetMLText( MLKeys.LBL_Amount, \"en\" ); FormatMLText public string FormatMLText(MLKey mlkey, params object[] args) Diese Methode ermittelt für den übergebenen MLKey den Text. Es wird zudem ein String.Format() mit den übergebenen args ausgeführt. Beispiel: FSstring sFormattedText = this.Global.FormatMLText( MLKeys.LBL_MitFormat, \"Text1\", lngAmount ); GetMLKeyText public MLKeyText GetMLKeyText(MLKey mlkey) Diese Variante gibt ein MLKeyText Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please select only one article. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_1b6b9bea43304e2082d1162d75d9e317), 0); FormatMLKeyText public MLKeyText FormatMLKeyText(MLKey mlkey, params object[] args) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Diese Methode wird in den Code-Messages benutzt. Beispiel: // FSCodeMessage: Please specify {0} throw new FrameworkApplicationException(this.Global.FormatMLKeyText(MLKeys.MSG_24979a3d247546318dc673c5501d3b15, this.sName), 0); cGlobal EntryPoint In der Klasse cGlobal gibt es einen zentralen Entry-Point GlobalGetMLText . Dieser wird JEDES MAL aufgerufen, wenn aus einem MLKey ein Text erzeugt wird. public virtual string GlobalGetMLText(MLKey mlkey, string iso) Die Sprach-Hierarchie der Session, welche am GlobalObject hinterlegt ist, wird außerhalb dieser Methode aufgelöst. Besteht die Hierarchie aus mehreren Fallbacks (z.B. fr, en, de ), wird diese Methode auch ggf. mehrfach nacheinander mit den unterschiedlichen Iso-Codes aufgerufen. Liefert die Methode einen Wert ungleich null oder String.Empty zurück, wird dieser als Text verwendet und es erfolgt kein weiterer Aufruf. Es ist möglich, diese Methode am cGlobal zu überschreiben und die Ermittlung der Texte zu beeinflussen oder zu überwachen. Warning Diese Methode muss sehr performant gestaltet werden. Komplexe Logik kann die Performance der kompletten Anwendung sehr negativ beeinflussen. Der Basis-Aufruf muss sichergestellt werden. Ansonsten wird das komplette Wörterbuch ausgehebelt und es werden gar keine Texte mehr ermittelt."
  },
  "doc/documentation/doc2help.html": {
    "href": "doc/documentation/doc2help.html",
    "title": "Doc2Help",
    "keywords": "Doc2Help Important Da Framework Studio mittlerweile auch selbst in der Lage ist, mittels des HTML-Exports ( HTML ) komplette Online-Hilfen zu generieren, sollte diese Möglichkeit verwendet werden, da Doc2Help Größenbeschränkungen hat, die bei sehr umfangreichen Dokumentationen ggf. zu Fehlern führen können. Doc2Help ist eine Anwendung der Firma ComponentOne , die in der Lage ist, aus Word-Dateien Onlinehilfen in HTML zu generieren. Um normale docx-Dateien jedoch mit Doc2Help verarbeiten zu können, müssen einige Vorkehrungen getroffen werden. Framework Studio bietet die Möglichkeit, mit der Option Doc2Help in den Wizard-Optionen eben diese Vorkehrungen automatisch zu treffen. Um z.B. in einer von Doc2Help generierten Onlinehilfe über einen Url-Parameter ein bestimmtes Kapitel aufzurufen, muss an jede Überschrift in Word eine besondere Formatvorlage eingebunden werden und ein Parameter mit dem Namen asciiname definiert werden. Parameter am Kapitel für Doc2Help: Wird eine Dokumentation über den Export Wizard erstellt und die Option Doc2Help aktiviert ist, sind keine weiteren Anpassungen an der Word-Datei nötig. Die Dokumentation kann in Doc2Help importiert und sofort in eine Onlinehilfe konvertiert werden."
  },
  "doc/themes/verwalten.html": {
    "href": "doc/themes/verwalten.html",
    "title": "Verwalten",
    "keywords": "Verwalten Die Themes werden über den Theme Manager verwaltet. Dieser kann über das Menü Tools > Manage Themes aufgerufen werden. In der Liste werden alle verfügbaren Themes angezeigt. Sind Themes in einem oder mehreren Basis-Packages des aktuellen Packages definiert, werden diese mit dem jeweiligen Packagenamen in Klammern angezeigt, können aber nicht geändert werden. Menü: Über den Button wird ein neues Theme angelegt werden. Neue Themes erhalten ein (+) -Zeichen. Nur neu angelegte Themes können ohne die Aufräum-Routine gelöscht werden. Mit werden alle Änderungen gespeichert. Neue Themes mit (+) werden dann persistent gespeichert und können dann nur noch über die Aufräum-Routine gelöscht werden. Mit können noch nicht persistent gespeicherte Themes (mit (+) ) wieder gelöscht werden. Mit kann die Aufräum-Routine angestoßen werden. Properties: ID: Die ID wird beim Anlegen eines Themes generiert und ist eindeutig. Name: Name des Themes. Kann auch im Nachhinein noch geändert werden, da die Themes über die ID identifiziert werden. Der Name darf maximal 20 Zeichen lang sein. Deprecated: Wird ein Theme auf „Deprecated“ gesetzt, steht es in der Theme-Auswahl nicht mehr zur Verfügung. Es wird zudem auch bei Publish-Vorgängen nicht mehr beachtet. Deprecated gilt somit als Vorstufe zum Löschen des Themes mittels der Aufräum-Routine (siehe Aufräum-Routine ). Caution Sind in einem Package Themes auf Deprecated gesetzt, werden diese von der Aufräum-Routine endgültig aus dem Package gelöscht. Für Packages, die auf dem Package aufsetzen, in dem das Theme definiert war, ist das Theme dann auch nicht mehr verfügbar."
  },
  "doc/documentation/control-features.html": {
    "href": "doc/documentation/control-features.html",
    "title": "Control Features",
    "keywords": "Control Features Es gibt einige Einstellungen, die speziell an Controls verfügbar sind. Machne dieser Einstellungen sind an allen Controls verfügbar, andere wiederum nur an Controls eines bestimmten Typs. Wenn ein Control im Designer ausgewählt ist, sind alle verfügbaren Einstellungen unter der Kategorie Documentation zu finden. Alle Controls Documentation Öffnet den Dokumentations-Editor (siehe Editor ) HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. TabbedWindow ChaptersForTabs Gibt an, ob die Registerkarten des TabbedWindow als eigenständige Kapitel in die Dokumentation gerendert werden sollen. Dieser Schalter ist nur für TabbedWindows auf oberster Ebene vorgesehen. Er zieht also nicht für TabbedWindows, die z.B. in einem Panel verschachtelt sind. ImageButton ShowImageInDocumentation Gibt an, ob das am Control hinterlegte Bild in die Control-Überschrift in der Dokumentation gerendert werden soll oder nicht."
  },
  "doc/themes/properties-theme-abhaengig-aendern.html": {
    "href": "doc/themes/properties-theme-abhaengig-aendern.html",
    "title": "Properties Theme-abhängig ändern",
    "keywords": "Properties Theme-abhängig ändern Um in Applications oder Default Control Styles Properties Theme-abhängig ändern zu können, muss nur das entsprechende Theme ausgewählt werden. Wird nun ein Property modifiziert, wird die Information automatisch dem aktuell aktiven Theme zugeordnet. Properties ändern bei Applications Beispiel Wurde vom Benutzer kein Theme ausgewählt (d.h. das Default-Theme ist aktiv), sieht die FSDemoApplication im Design-Panel wie folgt aus: Application PropertyGrid im Default-Theme: Ein BackImage wurde definiert, IsTransparent aktiviert, SplitterBackColor und die Farben für Menüs wurden modifiziert. Wird nun ein anderes Theme (über Tools > Choose Theme ) ausgewählt, werden die Properties, bezogen auf das nun ausgewählte Theme, angezeigt und können geändert werden: Application PropertyGrid im angepassten Theme: Im Gegensatz zum Default-Theme wurde hier ein anderes BackImage definiert. Das Property „FocusHighlightColor“ ist auf einen Gelbton abgeändert worden (im Default-Theme war hier nichts definiert). Auch die SplitterBackColor wurde neu zugewiesen. Properties ändern bei Default Control Styles Das Theme-abhängige Modifizieren von Properties eines Default Control Styles gestaltet sich analog zu den Applications: Beispiel Im Folgenden wird der Default Control Style des Button-Controls angezeigt, während der Benutzer das Default-Theme ausgewählt hat: DefaultControlStyle PropertyGrid im Default-Theme: Die BackColor wurde auf ButtonFace , die Font auf Arial; 12pt und die ForeColor auf Red gesetzt. Wird nun wiederrum ein Theme ausgewählt, könnten die Properties z.B. wie folgt umdefiniert werden: DefaultControlStyle PropertyGrid im angepassten Theme: Bild ändern bei Ressourcen Ist das Default-Theme aktiv, kann ein Bild über den Button Import File an die Resource gebunden werden. Der Name der Resource wird dabei standardmäßig auf den Namen der importierten Datei angepasst: Bild-Resource im Default-Theme: Wird nun ein Theme vom Benutzer ausgewählt, hat der Benutzer die Möglichkeit über den Button Import File erneut eine Bilddatei zu importieren. Diese wird dann jedoch dem Theme zugeordnet und das Bild des Default-Themes (der graue Buttonhintergrund) bleibt erhalten. Resource mit angepasstem Bild: In dieser Grafik wurde für die Resource NVButton1.gif ein neues Bild für das ausgewählte Theme importiert. Dass das Bild im aktiven Theme überschrieben ist, zeigt sich an der fetten Schrift des Relative Path und daran, dass der Reset-Button aktiv ist. In der Resource wurde der graue Button-Hintergrund durch einen bläulichen ausgetauscht. Wird wieder zum Default-Theme gewechselt, würde die Resource wieder den grauen Button-Hintergrund anzeigen. Bild zurücksetzen Ist einer Resource für ein Theme ein abweichendes Bild zugeordnet, kann dies durch den Reset-Button wieder auf das Default-Bild zurückgesetzt werden. Beispiel Der Resource ist im Default-Theme, wie in den obigen Grafiken zu sehen, der graue Button-Hintergrund zugewiesen und im Theme der bläuliche. Befindet sich der Benutzer nun im Theme und klickt den Reset-Button, wird der bläuliche Buttonhintergrund aus der Resource für das Theme entfernt und der graue Button-Hintergrund würde auch für das Theme verwendet werden (siehe Hierarchie bei mehreren Packages und Themes ). Important Wird einer Resource bei aktiviertem Theme ein Bild zugewiesen und ist das Bild für das Default-Theme noch nicht gesetzt, wird das im Theme importierte Bild auch als Bild für das Default-Theme hinzugefügt."
  },
  "doc/sql/funktionen.html": {
    "href": "doc/sql/funktionen.html",
    "title": "SQL-Funktionen",
    "keywords": "SQL-Funktionen GETGUID GETGUID ( ) Liefert eine neue Guid mit folgendem Format: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server LOWER( REPLACE ( NEWID ( ), '-', '' ) ) Oracle LOWER( SYS_GUID ( ) )"
  },
  "doc/mlkey/migration.html": {
    "href": "doc/mlkey/migration.html",
    "title": "MLKey Migration",
    "keywords": "MLKey Migration Ziel ist es, dass alle Texte aus den Records entfernt und in das Wörterbuch übertragen werden. Die Records erhalten dafür Verweise auf Einträge im Wörterbuch, die MLKeys . Generell teilt sich die Migration in zwei große Phasen auf: MLKeys erzeugen und zuordnen : Diese Phase kann parallel zur Weiterentwicklung durchgeführt werden. Es werden zum Einen neue Einträge im Wörterbuch angelegt und zum Anderen vorgemerkt, wo diese später verwendet werden sollen. MLKeys übertragen : In dieser Phase werden primär die vorbereiteten Zuordnungen an die Elemente übertragen: angegebene Texte werden entfernt und statt dessen die gewünschten MLKeys eingetragen. Dazu müssen alle betroffenen Elemente ausgecheckt werden. Zusätzlich werden weitere Umstellungen (z.B. bestehende Messages und Exceptions) durchgeführt. Abwärts-Kompatibilität Texte, die bisher an den Records definiert sind, funktionieren auch weiterhin, weil jeder MLString neben dem MLKey explizit gesetzte Texte versteht. So kann man nach dem Update auf die Version 4.2 die Migration in aller Ruhe angehen. Note In Kunden-Packages ist die Umstellung der eigenen Texte auf MLKeys empfohlen. Sie ist aber nicht zwingend notwendig. Das hat aber langfristig einige Nachteile zur Folge - insbesondere in Hinblick auf die Mehrsprachigkeit der Anwendung: Der Language Export / Import funktioniert nur für das Wörterbuch. Individuelle Texte an Records werden nicht (mehr) berücksichtigt. Das Pflegen von Fremdsprachen an den Records ist sehr aufwändig. Die MLKeys aus dem Wörterbuch bringen hingegen die Übersetzungen automatisch in alle Bereiche der Anwendung. Important Funktionale Packages, die als Produkt an mehrere Kunden vertrieben werden, sollten in jedem Fall migriert werden. MLKeys erzeugen und zuordnen Diese erste Phase der MLKey Migration dient zum Einen der Erzeugung der benötigten Einträge im Wörterbuch (MLKeys) und zum Anderen der Zuordnung, wo diese später verwendet werden sollen. Zentrales Werkzeug für diese Phase ist der Dialog Multilanguage Text Migration , welcher über das Menü Tools / Multilanguage Text Migration geöffnet werden kann. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Alle durch den Benutzer definierten Zuordnungen werden in der Ressource Migration.xml im Verzeichnis FSGeneral/Resources/lang gespeichert, welche automatisch bei der ersten Benutzung angelegt wird. Ist diese Datei bei der Bearbeitung mit dem Multilanguage Text Migration Dialog nicht ausgecheckt, so wird beim Speichern mit dem Button Save automatisch die neueste Version ausgecheckt, die Änderungen ergänzt und anschließend sofort wieder eingecheckt. Dieses Verhalten ist dann hilfreich, wenn mehrere Benutzer gleichzeitig mit dem Multilanguage Text Migration Dialog arbeiten. Andernfalls empfiehlt es sich, die Datei vor Beginn der Arbeit auszuchecken und erst nach Beendigung der Arbeit wieder einzuchecken. So werden unnötige Checkin- und Checkout-Vorgänge vermieden. Beim Speichern werden außerdem ggf. ungespeicherte Änderungen am Wörterbuch gespeichert. Generelles Vorgehen Die zu leistende Arbeit besteht in erster Linie darin, logisch identische Begriffe zusammenzuführen und logisch unterschiedliche Begriffe, die ggf. in einzelnen Sprachen Überlappungen mit anderen Begriffen haben, zu trennen. Beispiel: Die Begriffe Suche mit SQL , Suchen mit SQL , SQL Suche , SQL-Suche , Suchen SQL , Sql Suche und weitere Varianten sollten zu einem einzigen Eintrag zusammengefasst werden. (1) Load Data Important Zunächst sollten Tooltips außen vor gelassen werden. Dazu darf die Checkbox Include Tooltips NICHT gesetzt sein, wenn mit dem Button Load Data alle im Package angegebenen Texte eingelesen werden. Erst wenn allen Texten ein MLKey zugeordnet wurde, werden die im Folgenden beschriebenen Schritte nach dem erneuten Laden der Daten inklusive Tooltips ein zweites Mal durchgeführt. Note Wenn durch ein Basis-Package bereits Einträge im Wörterbuch existieren, so wird Framework Studio nach dem Laden automatisch einem mehrsprachigen Text aus dem Custom-Package den MLKey zuweisen, der mindestens in den angegebenen Sprachen die Texte in exakt der Schreibweise enthält. Die mit dem Button Load Data eingelesenen Texte werden in einer Tabelle angezeigt. Die einzelnen Spalten haben folgende Bedeutung: Record : Name des Elements, an dem der Text angegeben ist, z.B. frmArticle . Element : Name des Unterelements, an dem der Text angegeben ist, z.B. edtsName . Type : Typ des Unterelements, z.B. FormControl . Property : Eigenschaft, an der der Text angegeben ist, z.B. Caption . MLKey : Der MLKey, welcher zugeordnet werden soll, z.B. LBL_Name . {Sprachen...} , z.B. German , English usw.: Der Text, welcher in der jeweiligen Sprache angegeben ist, z.B. Name . Die Spalten können durch anklicken der Spaltenüberschrift sortiert werden. Meist wird man nach deutschem Text sortiert arbeiten. Ein Doppelklick in die Spalten Record oder Element öffnet das Designerfenster für das Element und springt soweit möglich zum Unterelement. In allen anderen Spalten wird beim Doppelklick der Text der Zelle als Filterkriterium in das Feld Search: gesetzt. Für die Filterfunktion mit dem Feld Search: gelten folgende Regeln: Groß-Kleinschreibung wird ignoriert Es wird in allen Spalten gesucht Es werden nur die Zeilen angezeigt, die ALLE der durch ein Leerzeichen getrennten Buchstabenfolgen enthalten In Anführungsstriche \" gekapselte Buchstabenfolgen müssen genau so in der Zeile enthalten sein, damit diese angezeigt wird Beispiel: Die Suche nach LBL_Quantity \" geliefert\" zeigt nur die Zeilen an, welche geliefert mit einem führenden Leerzeichen und LBL_Quantity in irgendeiner Spalte enthalten. (2) Auto Create MLKeys Nach dem Einlesen der Daten (zunächst ohne Tooltips, siehe Load Data ) sollten einmalig mit dem Button Auto Create MLKeys alle automatisch erzeugbaren MLKeys in das Wörterbuch eingefügt werden. Automatisch erzeugt werden MLKeys dann, wenn es zu gleichen Texten in einer Sprachen keine abweichenden Texte in anderen Sprachen gibt. Note Framework Studio weist danach automatisch den Zeilen einen MLKey zu, die nur Texte enthalten, welche zu einem MLKey aus dem Wörterbuch keinen Wiederspruch aufweisen. (3) Manuelle Zuweisungen Ist die Checkbox Show only missing keys gesetzt, so wird die Anzeige aller Texte in der Tabelle auf die Einträge reduziert, welchen bisher noch kein MLKey zugewiesen wurde - die noch zu bearbeitenden Einträge. Im unteren Bereich des Multilanguage Migration Dialogs werden im Bereich Details zum aktuell in der Tabelle selektierten Eintrag alle Eigenschaften angezeigt. Ist bereits ein MLKey zugewiesen, werden die Texte des MLKeys in der Tabellenspalte In MLKey angezeigt. In der oberen Tabelle können auch mehrere Zeilen gleichzeitig ausgewählt werden. So kann mehreren Zeilen gleichzeitig ein MLKey zugewiesen werden. Für die Zuweisung stehen mehrere Optionen zur Verfügung: Mit dem Button im Bereich Details kann ein bereits existierender MLKey ausgewählt werden, siehe Multilanguage Text Editor , insbesondere Suchen von MLKeys . Wurde bereits ein MLKey zugewiesen, so wird ein weiterer Button Set ... angeboten, mit dem der zuletzt zugewiesene MLKey den aktuell selektierten Zeilen zugewiesen werden kann. Mit dem Button im Bereich Details kann ein neuer MLKey (basierend auf den selektierten Zeilen) erzeugt werden. Wenn beim Erzeugen eines neuen MLKeys mehrere Zeilen ausgewählt wurden und diese in einzelnen Sprachen abweichende Texte enthalten, so wird pro Sprache bei Bedarf der folgende Dialog geöffnet: In diesem werden alle Varianten, sortiert nach Häufigkeit absteigend, aufgeführt. Durch Selektion und Bestätigung mit dem Button OK oder durch Doppelklick wird die Auswahl als Vorbelegung für den neuen MLKey verwendet (siehe Erfassen neuer MLKeys ). Important Bei der Zuweisung und Erzeugung von MLKeys sind die eNVenta Regeln für MLKeys zu beachten. Mit dem Button Rename MLKey ist es im Rahmen der Migration möglich, einen bestehenden MLKey umzubenennen. Alle manuellen Zuordnungen dieses MLKeys werden automatisch angepasst. (4) Bereinigungen Im Wörterbuch werden sich durch die vorangegangenen Schritte (z.B. durch die von Framework Studio automatisch generierten MLKeys) einige Unsauberkeiten eingeschlichen haben. Daher sind die folgenden Maßnahmen empfehlenswert: Maßnahmen im Wörterbuch: Sortierung nach MLKey: Folgen aufeinander logisch identische Begriffe? Suche Nach _1 , _2 , _3 usw: Sind diese Varianten nötig oder sollten anders benannt werden? Sortierung nach deutschem Text: Folgen aufeinander logisch identische Begriffe? In Custom-Packages sind dabei nur die MLKeys aus dem eigenen Package (zu erkennen an der Fettschreibung) und ihre Vorgänger und Nachfolger interessant. Außerdem können im Multilanguage Text Migration Dialog mit dem Button Find unused MLKeys alle MLKeys aus dem eigenen Package aufgelistet werden, welche im Wörterbuch existieren, jedoch nirgendwo zugeordnet sind. Diese gilt es, kritisch zu prüfen. (5) Abschluss Phase 1 Wurden die vorigen Schritte (zunächst ohne Tooltips, danach mit Tooltips) abgeschlossen, so kann nun mit Phase 2 ( MLKeys übertragen ) fortgefahren werden. MLKeys in Custom-Packages Im Customizing kann man grundsätzlich 2 verschiedene Arten von überschriebenen Texten unterscheiden: Texte, die eine ganz neue Bedeutung haben. Wenn z.B. ein relativ allgemeiner Metadatentyp in einem Component-Property verwendet wird, wird dort am Default-Label ein neuer Text formuliert. In diesen Fällen sollte auf jeden Fall ein entsprechender (ggf. neuer) MLKey zugeordnet werden. Ändern eines bestehenden Textes. Es wird z.B. ein Metadatentyp customized und das Default-Label geändert - aus dem Begriff \"Angebot\" wird z.B. \"Offerte\". Die Bedeutung bleibt aber dieselbe. In solchen Fällen gilt es zu prüfen, ob es evtl. ratsam ist, diese Änderung direkt im Wörterbuch vorzunehmen. So zieht diese für die gesamte Anwendung. Bei der Migration weist man dann diesen Einträgen den existierenden MLKey zu - auch wenn er identisch mit dem bereits zugeordneten MLKey aus dem Basis-Package sein sollte. In einem späteren Schritt der Migration wird eine redundante Zuordnung dann automatisch eliminiert. MLKeys übertragen Ist das Wörterbuch komplett vorbereitet (siehe MLKeys erzeugen und zuordnen ), ist es an der Zeit, die MLKeys in die Records zu übertragen. In diesem Schritt werden alle Aktionen ausgeführt, die einen Checkout der Records zur Folge haben. So wird die ggf. erhebliche Menge an Checkouts auf das nötigste reduziert. (1) Als FCUser anmelden Weil nach der Konvertierung sehr viel kompiliert werden muss, ist es empfehlenswert als FCUser zu arbeiten. So kann direkt nach dem Kompilieren der Complete Framework Compiler aufgerufen werden und es ist kein zusätzlicher FrameworkCompiler nötig. Mit dem Benutzer FrameworkCompiler anmelden - mit Refresh Workspace. Get DLLs ist nicht notwendig. Framework Studio direkt wieder beenden. Jetzt als FC-User anmelden - mit Refresh Workspace. Das übernimmt den Workspace vom Benutzer FrameworkCompiler. (2) Apply MLKeys Im Fenster Multilanguage Text Migration mit dem Button Load Data (inkl. den Tooltips) alle Daten einlesen. Es sollte jetzt keine offenen Zuordnungen mehr geben - wenn man die Checkbox Show only missing keys setzt, dürfen keine Einträge angezeigt werden. Mit dem Button Apply MLKeys wird die Routine gestartet. Es werden alle zugeordneten MLKeys an die entsprechenden Properties der Records übertragen. Dabei werden ALLE in den jeweiligen Sprachen gesetzten Texte aus den Records entfernt. Somit ziehen ab diesem Zeitpunkt die Texte nur noch aus dem Wörterbuch. (3) Convert Messages Mit dem Button Convert Messages im Fenster Multilangage Text Migration wird die Routine gestartet. Für diese Routine müssen keine Daten eingelesen werden - das gilt auch, wenn sie zu einem späteren Zeitpunkt erneut gestartet wird. Es werden alle Methoden-Codes analysiert und nach Exceptions- und MessageBox-Aufrufen gesucht. Diese werden in das neue Message-Format umgewandelt und die Verweise auf die Text-Collections werden durch den entsprechenden MLKey ersetzt. Warning Die Routine Apply MLKeys muss zuvor ausgeführt worden sein, damit die Message-TextCollections sauber zugeordnete MLKeys besitzen. Alter Exception-Code vor der Konvertierung: #region Required for Exception Editor support. Do not modify manually. //Component type is required. //Severity: 0 ; Buttons: OK; Icon:Error throw new FrameworkApplicationException (String.Format(FSGeneral.ctMessagesFactory.Get(this.Global,3550).Value[Global.SelectedLanguage],new object []{}),0 ); //<ExceptionEditor TextColl=\"Messages\" ID =\"832e0e50c2b748068ba38a2c4422aaab\" Severity=\"0\" EHID=\"\" ></ExceptionEditor> #endregion End of generated section Neuer Exception-Code nach der Konvertierung: // FSCodeMessage: Component type is required. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_445559f2ca44452e8d49ca9515b3a83e), 0); Es ist relativ wahrscheinlich, dass Warnings oder sogar Errors ausgegeben werden. Diese können erst einmal ignoriert werden. Es handelt sich dabei um inhaltliche Probleme und nicht um Compile-Errors. Die Convert Code Messages Routine kann zu einem späteren Zeitpunkt erneut ausgeführt und diese Probleme dann behoben werden. Important Damit sind die Message-Text-Collections jetzt obsolete. Sie dürfen aber nicht gelöscht oder geleert werden, weil sie ggf. noch von Customizing-Packages referenziert werden. (4) MLStrings Cleanup Nachdem alle MLKeys übertragen wurden, können jetzt noch einige Bereinigungen durchgeführt werden. Über das Menü Tools / Checks / MLStrings Cleanup kann das Cleanup-Fenster geöffnet werden. Dort stehen mehrere Routinen zur Auswahl. Diese sollten einer nach der anderen ausgeführt werden. Dabei ist es ratsam zuerst den Button Analyze zu benutzen. Erst nach der Sichtung der Infos und Warnings wird die Routine mit dem Button Cleanup ausgeführt. Clean MLKeys Wird in einem Record (z.B. DBColumn, Form-Control) der MLKey mit demselben Wert überschrieben, wie er in der Basis (z.B. Metadatentyp, Basis-Package) definiert ist, dann wird diese Überschreibung entfernt. Transfer translations Wurden trotz vererbtem MLKey Übersetzungen nur an Records gepflegt, dann wurden diese mit der Migration ggf. nicht in das Wörterbuch übertragen. Das wird mit dieser Routine nachgeholt. Wird an einem Record, der einen MLKey besitzt, eine Übersetzung gefunden und das Wörterbuch kennt diese noch nicht, wird diese in das Wörterbuch übertragen und der Text vom Record entfernt. Dabei gewinnt pro MLKey der erste Record. Wird ein weiterer Record mit gleichem MLKey aber einer anderen Übersetzung gefunden, dann wird dieser als Warning ausgegeben. Beim Cleanup verbleibt dieser Text am Record. Bei einem weiteren Lauf würde dieser Record mit der Routine Clean individual texts gefunden werden. Clean individual texts Die MLKey-Migration berücksichtigt nur Texte, die mindestens in Deutsch und Englisch gepflegt sind. Sind an einem Record nur andere Sprachen definiert, dann wird dieser Text nicht migriert. Oftmals erben diese Records schon einen Text aus der Basis und es sind nur einige Übersetzungen gepflegt. Diese sollen hier bereinigt werden. Es werden Texte, die identisch mit dem Wörterbuch sind, entfernt. Vom Wörterbuch abweichende Texte werden als Warning ausgegeben und NICHT entfernt. Diese müssen in einem weiteren Schritt bearbeitet werden. Warnings bearbeiten Jetzt müssen die aufgetretenen Warnings begutachtet und ggf. manuell bearbeitet werden. Clean individual texts mit Remove different Wurden im vorherigen Schritt die Warnings begutachtet, können mit dieser Aktion alle abweichenden Texte entfernt werden. (5) Compile und CheckIn Jetzt müssen alle Änderungen compiliert werden. Menü Compile / Compile Changes . Nachdem der Compiler erfolgreich beendet wurde, werden alle Elemente eingecheckt. Dabei sollte ein CheckIn-Kommentar z.B. MLKey Migration angegeben werden. Zum Abschluss noch über den Compile-Manager den Button Complete Framework Compiler aufrufen."
  },
  "doc/documentation/export-wizards.html": {
    "href": "doc/documentation/export-wizards.html",
    "title": "Export Wizards",
    "keywords": "Export Wizards Die wichtigste Funktion des Dokumentationssystems ist der Export in ein gängiges Format. Framework Studio bietet die Möglichkeit, automatisiert alle Dokumentationen, die an Forms, Controls, Metadatentypen usw. getätigt wurden, anhand der im Chapter Tree definierten Kapitelstruktur zu exportieren. Die Dokumentation kann als HTML Webapplikation (zum Hosten auf einem Webserver) oder als Word-Datei (.docx) exportiert werden. Zusätzlich dazu gibt es einen besonderen Modus, mit dem ausschließlich Dokumentationen von Component-Properties exportiert werden können, um diese mittels des Browser-Controls in der Endanwendung anzeigen zu können. HTML Dieser Export-Modus exportiert die gesamte Dokumentation oder ein ausgewähltes Kapitel als Webapplikation, welche auf einem beliebigen Webserver (z.B. IIS, Apache, Nginx) gehostet werden kann und somit von nahezu allen Endgeräten mit Webbrowser erreichbar ist. Der Modus HTML (Properties) ist in diesem Export-Modus integriert. Es werden alle Component-Properties von Components, die mit dem Marker {ExportDoc} markiert sind, exportiert. Der Wizard für den Export der Dokumentation als HTML Webapplikation befindet sich im Menü Tools > Documentation > Export > HTML . Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe ( orange für Warnungen, rot für Fehler). Webapplikation Nach dem Export-Vorgang befindet sich die Webapplikation im zuvor ausgewählten Ausgabeordner. Die Webapplikation ist eine HTML 5 Anwendung, die ausschließlich auf den Technologien HTML, JavaScript und CSS basiert. Damit ist sie kompatibel zu nahezu allen Endgeräten mit einem Browser ( Webapplikation Vorraussetzungen beachten). Inhalt Nach dem Öffnen der Webapplikation im Browser ist standardmäßig der Bereich Contents selektiert. Hier kann im Baum auf der linken Seite das gewünschte Kapitel ausgewählt werden, welches dann rechts im Viewer angezeigt wird. Bei einem Klick auf einen Link wird der Baum automatisch aktualisiert und zum neuen Kapitel gesprungen. Index Im Bereich Index kann der gesamte Index der Dokumentation durchsucht werden. Ist einem Index-Eintrag nur ein einziges Kapitel zugeordnet, wird dieses sofort nach dem Klick in den Baum ausgewählt. Sind einem Index-Eintrag mehrere Kapitel zugeordnet, kann das gewünschte Kapitel im Bereich Select Chapter links unten im Baum ausgewählt werden. Suche Mit Hilfe der Suchfunktion können alle Kapitel nach Wörtern durchsucht werden. In der Ergebnisliste werden dann alle Kapitel angezeigt, die das eingegebene Wort enthalten. Drucken Um den Inhalt des gerade angezeigten Kapitels zu drucken, steht der Button Print zur Verfügung. Anders als die Druckfunktion des Browsers, welche die gesamte Webapplikation inkl. Baum drucken würde, wir über den Button Print nur der Inhalt des Viewers berücksichtigt. Webapplikation Vorraussetzungen Um die von Framework Studio generierte Webapplikation zu hosten, wird einer der folgenden Webserver vorrausgesetzt: IIS 7 oder höher Apache 2.2.x oder höher Nginx 1.9 oder höher Es wird empfohlen, einen der folgenden Browser zur Anzeige der Webapplikation zu verwenden: Google Chrome Mozilla Firefox Microsoft Edge Microsoft Internet Explorer 11 Warning Internet Explorer 10 und niedriger werden NICHT unterstützt. Export mit FSConsole Neben dem Export-Wizard kann die Webapplikation auch über die FSConsole.exe ( FSConsole ) generiert werden. Hierzu gibt es die neuen Parameter \\DOCUMENTATION, \\ISO und \\OUTPUT. \\DOCUMENTATION Dieser Parameter ist nur ein Marker für die FSConsole, dass die Dokumentation gerendert werden soll. \\ISO Gibt die Sprache an, in der die Dokumentation gerendert werden soll. Der Parameter hat auch Einfluss auf die automatisch generierten Screenshots. \\OUTPUT Gibt das Verzeichnis an, in welches die Webapplikation gerendert werden soll. Zusätzlich zu den neuen Parametern müssen die obligatorischen Connection- und Package-Version Parameter angegeben werden ( \\LABELID , \\SERVER , \\DBUSER usw.) Beispiel: FSConsole.exe \\DOCUMENTATION \\ISO de \\OUTPUT „C:\\Temp\\Dokumentation“ \\PACKAGE MyPackage \\VERSION 3.8 \\CONNECTIONTYPE SqlServer \\SERVER Server01 \\DBUSER demo \\DBPASSWORD demo123 Word Der Wizard für den Export der Dokumentation als Word-Datei (.docx) befindet sich im Menü Tools > Documentation > Export > Word . Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Title Page Wird diese Option aktiviert, wird in der Word-Datei zusätzlich ein Deckblatt mit dem definierten Titel und Info Text generiert. Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Create TOC Erstellt ein Inhaltsverzeichnis für alle in der Dokumentation enthaltenen Kapitel am Anfang der Word-Datei. Create Index Erstellt einen Index für alle Kapitel und manuell in den Dokumentationen definierten Indexeinträgen am Ende der Word-Datei. Die Überschrift jedes Kapitels aus dem Chapter Tree wird automatisch zum Index hinzugefügt. Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Doc2Help Zusätzlich zum Indexeintrag wird jede Kapitelüberschrift mit einer zusätzlichen Formatvorlage versehen, die es Doc2Help erlaubt, einen Verweis über eine Url in der Onlinehilfe auf das jeweilige Kapitel zu generieren. Für mehr Information hierzu siehe Kapitel Doc2Help . Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe ( orange für Warnungen, rot für Fehler). Besonderheit bei TOC und Index Wurde im Export Wizard eine der Optionen Create TOC oder Create Index ausgewählt, muss Microsoft Word (2007 oder höher) auf dem PC installiert sein, um das Inhaltsverzeichnis oder den Index nach einem erfolgreichem Exportvorgang zu aktualisieren. Zu diesem Zweck wird nach dem Speichern der docx-Datei auf der Festplatte diese automatisch von Framework Studio aus mit Word geöffnet (als Prozess - es wird kein Fenster geöffnet) und eine Aktualisierung der jeweiligen Kataloge angestoßen. Anschließend wird die Datei nochmals gespeichert und Word geschlossen. Im Ausgabefenster des Export-Vorgangs ist zu erkennen, dass seitens Framework Studio geprüft wird, ob Word installiert ist. Sollte dies nicht der Fall sein, werden im exportierten Dokument zwar ein Inhaltsverzeichnis und ein Index enthalten sein, die jedoch aufgrund der fehlenden Aktualisierung keine Einträge enthalten. In diesem Fall muss die Aktualisierung der Kataloge manuell mit Word durchgeführt werden. HTML (Properties) Zusätzlich zu den anderen Modi steht ein weiterer Export-Modus zur Verfügung. Dieser ist in der Lage, ausschließlich Dokumentationen von Component-Properties in einzelne HTML-Dateien zu rendern. Er renderd also nicht wie der HTML- oder Word-Exporter die gesamte zur Verfügung stehende Dokumentation, sondern nur ausgewählte Component-Properties. Soll die Dokumentation eines Component-Properties z.B. an der Oberfläche der Endanwendung angezeigt werden, ist dies nun mit Hilfe des Browser-Controls möglich. Der neue Export-Modus befindet sich wie nun auch der bisherige Word-Export-Modus im Menü Tools > Documentation > Export > HTML (Properties) . Markieren der Components Eine Endanwendung besteht im Normalfall aus extrem vielen Components und Component-Properties. Der neue Export-Modus wird aber meist nur für einen gewissen Bereich der Anwendung benötigt. Deshalb muss auf Component-Ebene definiert werden, welche Components beim neuen Export-Modus beachtet werden sollen. Um eine Component für den neuen Modus zu markieren, muss die Zeichenfolge \"{ExportDoc}\" in das Description-Feld der Component eingetragen werden. Nun werden beim Export alle dokumentierten Properties der markierten Component exportiert. Wizard-Optionen Wird der neue Export-Dialog aufgerufen, wird eine Übersicht mit allen markierten Components angezeigt. Language Definiert die Sprache, in der die Component-Properties gerendert werden sollen Include Tooltips Definiert, ob an den Component-Properties definierte Tooltips zuzüglich zur eigentlichen Dokumentation gerendert werden sollen. Output Directory Über den Button […] muss ein Zielverzeichnis für den HTML-Export definiert werden. Dieses Verzeichnis muss leer sein. Export-Vorgang Es kann nachvollzogen werden, welche Properties Dokumentationen beinhalten und gerendert werden. Sollte nach dem Export-Vorgang festgestellt werden, dass keine Bilder gerendert wurden, wird das zuvor erstellte Verzeichnis images wieder gelöscht. Ausgabe Beim Export wird jedes Property einer markierten Component durchlaufen und in eine separate .html-Datei geschrieben. Der Name dieser Dateien setzt sich allein aus dem Namespace-Pfad des Properties zusammen. Wird der Export-Ordner nun an einem im Netzwerk zugänglichen Pfad abgelegt (vorzugsweise auf dem Webserver, auf dem auch schon die bisherige Dokumentation liegt), können die Property-Dokumentationen in der Endanwendung mittels eines Browser-Controls eingebunden werden. Struktur der Ausgabe Der größte Vorteil der Generierung der Anwendungsdokumentation mit Framework Studio ist die strukturierte Ausgabe. Ziel ist es, jedes Kapitel bzw. Formular in genau demselben Schema auszugeben. Dokumentations-Elemente sind hier sehr einfach gehalten, da sie nur eine Dokumentation enthalten. Sie werden als einzelnes Kapitel mit dem zugehörigen Text gerendert. Formulare hingegen bestehen aus vielen Steuerelementen und ggf. Menüeinträgen, die wiederum ihre eigene Dokumentation beinhalten. Hier folgt Framework Studio folgendem Schema: Die Dokumentation eines Formulars beginnt wie ein Documentation-Element mit einem eigenen Kapitel. Danach folgt die Formular-Dokumentation. Die Steuerelemente werden anhand ihrer Position auf dem Form abgearbeitet. Es wird von links nach rechts und von oben nach unten gearbeitet. Wenn ein Steuerelement andere Steuerelemente beinhaltet (z.B. Registerkarten oder Tabellen) werden diese inneren Steuerelemente nach demselben Schema abgearbeitet. Sind alle Steuerelemente gerendert, folgt zum Schluss die Ausgabe der Menüeinträge. Zur Verdeutlichung folgen einige Beispiele in Microsoft Word. Ausgabe einer Dokumentation eines Documentation-Elements: Ausgabe eines Formulars unterhalb eines Documentation-Elements: In diesem Beispiel ist zu sehen, dass im Chapter Tree das Formular Kassenparameter unterhalb des Documentation-Elements Kasse eingefügt wurde. In der Formular-Dokumentation wurde ein automatisch generierter Screenshot eingefügt. Ausgabe der Steuerelemente eines Formulars: In diesem Beispiel ist die Ausgabe der Steuerelemente eines Formulars zu sehen. Ist ein Steuerelement ein Container (d.h. beinhaltet andere Steuerelemente) wird dies mit horizontalen Linien verdeutlicht. Es ist zu erkennen, dass die Buttons Speichern , Schließen , Customizing und Hilfe innerhalb des Panels Haupt-Buttonleiste liegen. Zusätzlich ist erkennbar, dass die Bezeichnungsfelder Gutsch.kürzel und Rechn.kürzel Tooltip-Informationen enthalten, die automatisch mit in die Dokumentation aufgenommen wurden (Checkbox Include Tooltips in den Wizard-Optionen ). Ausgabe der Bilder bei Steuerelementen Es gibt einige Steuerelemente in Framework Studio, die Bilder anzeigen (z.B. ImageButtons). Um das Auffinden eines solchen Steuerelements in der Dokumentation zu vereinfachen, kann in der Ausgabe des Steuerelements das zugehörige Bild mit angezeigt werden. ImageButtons mit Bild in der Dokumentation: Ob das Bild in der Dokumentation des Steuerelements mit angezeigt wird oder nicht, hängt von einem Schalter direkt am Steuerelement ab. Einstellung zur Anzeige des Bildes in der Dokumentation des Steuerelements: Diese Einstellung kann auch global über die DefaultControlStyles für den jeweiligen Control-Typ definiert werden. Einstellung der Bildanzeige am DefaultControlStyle: Registerkarten als separate Kapitel ausgeben Registerkarten beinhalten in Anwendungen oft Funktionalitäten, die in einer Dokumentation als separates Kapitel betrachtet werden sollte. Standardmäßig werden Registerkarte in der Dokumentation genauso wie andere Container-Steuerelemente in der Liste der Steuerelemente des Formulars mit ausgegeben. Dieses Verhalten ist nicht immer gewünscht, vor allem wenn eine Registerkarte sehr viele Steuerelemente und komplexere Vorgänge beinhaltet. Um für jede Registerkarte eines Registerkartes unterhalb eines Formulars ein eigenes Kapitel in der Dokumentation zu eröffnen, gibt es die Option ChaptersForTabs am Registerkarte. Registerkarten als separate Kapitel Ausgeben: Wird diese Option auf True gesetzt, werden beim Exportieren des Formulars für jede Registerkarte des Registerkartes ein eigenes Kapitel mit eigenem Indexeintrag erstellt. Generierung separater Kapitel für Registerkarten: In der Liste der Steuerelemente, in der die Registerkarten normalerweise ausgegeben werden, befindet sich dann nur noch ein Link auf das entsprechende Unterkapitel. Caution Die Option ChapterForTabs kann je Formular nur für ein einziges Registerkarte auf True gesetzt werden. Vorschau eines ganzen Formulars Die Preview-Ansicht des Dokumentations-Editors zeigt immer nur die Ausgabe des im Editor befindlichen DocML . Um eine Vorstellung zu bekommen, wie ein ganzes Formular in der Endfassung aussieht, kann dieses komplett mit der Steuerelementauflistung und den Menüeinträgen in ein Vorschaufenster gerendert werden. Hierzu reicht im Documenation-Editor ein Klick auf den Link View Render Chapter . Es wird die in der Combobox Language angegebene Sprache verwendet. Dieser Link steht auch im Documentation-Editor der TabPage zur Verfügung. Diese bilden in der Regel ein eigenes Chapter und werden nicht in der Preview des Forms angezeigt. Vollständige Voransicht eines Formulars rendern: Unterstützung von Themes Die Einstellung des Themes in Framework Studio hat unmittelbare Auswirkungen auf die Ausgabe der Dokumentation mittels des Export Wizards. Diese Abhängigkeit betrifft in Framework Studio eingebundene Ressourcen sowie auch die automatisch generierten Screenshots über das Screenshot-Tag (siehe Screenshot ) in der Formular-Dokumentation. Im folgenden Beispiel wurde eine Dokumentation eines Formulars mit zwei unterschiedlichen Themes exportiert, was zu anderen automatisch generierten Screenshots in der Dokumentation führt. Dokumentation exportiert mit Theme 1: Dokumentation exportiert mit Theme 2: fsconsole! Warning TODO fsconsole link!"
  },
  "doc/documentation/chapter-tree.html": {
    "href": "doc/documentation/chapter-tree.html",
    "title": "Chapter Tree",
    "keywords": "Chapter Tree Allgemein Der Chapter Tree ist die zentrale Instanz, welche alle Form- und Documentation-Elemente in Kapitel organisiert. Zu erreichen ist der Chapter Tree über das Menü Tools -> Documentation -> Chapter Tree . Ein Form- oder Documentation-Element spiegelt in einer exportierten Dokumentation genau ein Kapitel mit eigener Kapitelnummer wider. Chapter Tree für die Organisation der Kapitel: Es gibt zwei Abschnitte im Chapter Tree. Der Documentation (Preparation) -Knoten beinhaltet alle Formulare und Documentation-Elemente, die in einer Anwendung neu hinzugekommen oder noch nicht in die Dokumentation eingebunden wurden. Sie werden alphabetisch aufsteigend aufgelistet. Der Documentation (Release) -Knoten spiegelt den Kapitelbaum der Dokumentation wieder, die mit dem Export Wizard gerendert werden kann. Als Text wird die im Dokumentations-Editor angegebene Caption des Formulars oder Documentation-Elements angezeigt. Ist diese nicht definiert wird in Klammern hinter dem Namen des Formulars oder Documentation-Elements der Zusatz “caption not set” angezeigt. Die Form- oder Documentation-Elemente können aus dem Chapter Tree mit einem Doppelklick auf den Knoten oder mit der Entertaste direkt geöffnet werden. Die Textbox am unteren Rand zeigt den vollen Namespace des aktuell ausgewählten Knoten an. Kapitelstruktur Wird die Dokumentation wie in der Abbildung mit dem Export Wizard in eine Word-Datei exportiert, folgt die Kapitelnummerierung der Ebene des Documentation (Release) -Knotens. Wie im Beispiel zu sehen hätten die folgenden Kapitel die angegebenen Kapitelnummern: Einführung in das Programm eNVenta = 1. eNVenta ERP = 2. Initialisierung = 5. eNVenta Init = 5.1 Da Word bis zu 9 Ebenen unterstützt, können auch im Chapter Tree die Formulare und Documentation-Elemente in bis zu 9 Ebenen (x.x.x.x.x.x.x.x.x) verschachtelt werden. Um ein Kapitel an eine andere Stelle einzufügen bzw. ein Kapitel aus dem Preparation- in den Release-Knoten zu verschieben, muss nur der entsprechende Knoten per Drag&Drop an die richtige Position gezogen werden. Sind nicht alle beteiligten Elemente im Framework Studio ausgecheckt, wird eine entsprechende Meldung angezeigt. Auschecken von beteiligten Elementen: Im Beispiel wurde der Knoten CSV Format Konversion aus dem Preparation-Knoten in den Release-Bereich unter das Kapitel eNVenta ERP -> Wv-Übersicht gezogen. Keines der Elemente war zu diesem Zeitpunkt ausgecheckt."
  },
  "doc/database/ml-column.html": {
    "href": "doc/database/ml-column.html",
    "title": "ML-Column",
    "keywords": "ML-Column Framework Studio bietet einen Mechanismus, um Dateninhalte in mehreren Sprachen zu speichern. Eine beliebige Tabellen-Spalte, in der eine Zeichenkette abgelegt ist, kann im Tabelleneditor als MLColumn markiert werden. Vorraussetzung ist jedoch, dass die Tabelle die Spalte FSRowID enthält, weil diese als eindeutige Referenz auf den Datensatz benötigt wird. Ist eine Tabellen-Spalte als MLColumn gekennzeichnet, dann werden die fremdsprachigen Texte in der Tabelle dbRun_MLStrings abgelegt. Die normale Tabellen-Spalte beinhaltet die Texte in Default-Sprache. Caution Fehlt einer Component das Property ROWID (mit Mapping auf die DB-Column FSRowID ), ist der Mechanismus für diese Component deaktiviert. Join-Components können keine ML-Columns aus mehreren Tabellen verabreiten, da die Component lediglich ein ROWID-Property betrachtet. Werden mehrere ROWID-Properties aus verschiedenen Tabellen eingebunden, dann ist es Zufall, welche ROWID für den MLColumn-Mechanismus herangezogen wird. Customizing-Package Die Eigenschaft MLColumn kann im Customizing-Package gesetzt werden. Somit kann man in Kunden-Umgebungen den Mechanismus gezielt für die gewünschten Tabellen-Spalten aktivieren. Anwendung in Default-Sprache Die Default-Sprache ist de - außer man definiert über die Tabelle ML_Config eine andere Default-Sprache. Wird die Anwendung in der Default-Sprache gestartet, dann arbeitet Framework Studio mit der ganz normalen Spalte der Tabelle - ohne jegliche Sonder-Logik. Die fremdsprachigen Texte können nicht beeinflusst werden. Ändert man einen Text, dann bleiben die ggf. existierenden Übersetzungen unverändert erhalten. Bei Bedarf müsste man die Anwendung anschließend in den Fremdsprachen starten und den gewünschten Text dort ebenfalls anpassen. Anwendung in Fremdsprache Startet man die Anwendung mit einer Fremdsprache, dann greifen besondere Mechanismen. Die entsprechenden Component-Properties behandeln dann ausschließlich den fremdsprachigen Text mit einem Fallback auf die Default-Sprache. Die ML-Column-Logik wird von den ganz normalen Component-Properties behandelt. Dadurch wirkt sie sich automatisch auf alle Bereiche der Anwendung aus - inkl. Form-Databinding und Reporting. Load : Beim Zugriff auf das entsprechende Component-Property wird der Text aus der Tabelle dbRun_MLStrings gelesen. Existiert dort kein Eintrag, wird der Text der Default-Sprache aus der normalen Tabellen-Spalte verwendet. Update : Wird der Text geändert, dann wird der Eintrag in der entsprechenden Fremdsprache überschrieben. Der Text in der Default-Sprache kann nicht verändert werden. Wird der fremdsprachige Text geleert, dann wird beim Save der Component der Eintrag aus der Übersetzungs-Tabelle gelöscht und das Component-Property fällt auf die Default-Sprache zurück. Insert : Beim Anlegen eines neuen Datensatzes wird der eingegebene Text sowohl in der normalen Tabelle als auch in der Fremdsprache gespeichert. Delete : Wird der Datensatz aus der Datenbank gelöscht, dann werden auch alle zu dieser FSROWID gespeicherten Texte aus der Übersetzungs-Tabelle gelöscht. Important Die Sprache ist mit dem Start der Anwendung am GlobalObject festgelegt. Es gibt keine Möglichkeit, zur Laufzeit auf die Sprache Einfluss zu nehmen oder die Texte in einer spezifischen Sprache zu behandeln. Tips für Entwickler Finden von MLColumns Wird eine DBColumn als MLColumn gekennzeichnet wird dafür der folgende Code generiert: public class Package_FSColumnName : FS.Demo.MDT.ArticleName { public Package_FSColumnName() { this.m_IsMLColumn = true; } } Dadurch können alle MLColumns mit dem Text this.m_IsMLColumn = true; über die Code-Suche gefunden werden. Dabei die Suche auf die DBTables einschränken."
  },
  "doc/documentation/indicators.html": {
    "href": "doc/documentation/indicators.html",
    "title": "Dokumentationsstatus von Steuerelementen",
    "keywords": "Dokumentationsstatus von Steuerelementen Da die Dokumentation der Steuerelemente eines Formulars über den Designer stattfindet, ist nicht immer ersichtlich, welches Steuerelement schon eine Dokumentation beinhaltet oder ob das Steuerelement beim Rendern eine Dokumentation aus der Basis erhält. Um dies zu visualisieren, gibt es in den Framework Studio Optionen die Option Documentation Indicators . Wird diese Checkbox aktiviert, werden für alle Steuerelemente kleine Vierecke in der rechten oberen Ecke angezeigt. Die Quadrate können dabei zwei Farben annehmen: Gelb Das Steuerelement enthält in diesem Formular keine Dokumentation. Es steht aber eine Dokumentation aus der DataSource des Steuerelements (Component Property, DBColumn, Metadatentyp) oder aus einem Basis-Package zur Verfügung und würde bei einem Export ausgegeben. Grün Das Steuerelement enthält in diesem Formular eine Dokumentation. Wenn an einem Steuerelement kein Quadrat existiert, gibt es an diesem Steuerelement keine Dokumentation sowie auch keine Dokumentation aus der DataSource bzw. eines Basis-Packages."
  },
  "doc/documentation/customizing.html": {
    "href": "doc/documentation/customizing.html",
    "title": "Customizing",
    "keywords": "Customizing Sections sind nur in Dokumentationen von Forms und Documentation-Elementen verfügbar und dienen dazu, längere Texte in Abschnitte zu unterteilen, die in Customizations dieser Elemente ausgetauscht oder ergänzt werden können. Beispiel: Eine Dokumentation eines Forms in Package P1 sieht wie folgt aus: Es ist zu sehen, dass der Text in zwei Sections unterteilt ist, die jeweils mit einer einmaligen ID ausgestattet sind. Wird dieses Form nun in einem Package P2 gecustomized und an der Funktion des Forms Änderungen vorgenommen, die danach nicht mehr mit der Dokumentation aus der Basis übereinstimmen, muss die Dokumentation der Customization ebenfalls angepasst werden. Meistens ist es jedoch der Fall, dass nur einzelne Teile oder nur wenige Sätze aus der bisherigen Dokumentation geändert werden müssen, um die Dokumentation zu korrigieren. Im konkreten Beispiel könnte im gecustomizten Form die Möglichkeit geschaffen worden sein, Auftragspositionen auch kopieren zu können. Diese Information sollte nun in die Dokumentation des neuen gecustomizten Forms eingefügt werden. Praktisch wäre natürlich eine Ergänzung nach dem ersten Satz „…editiert oder gelöscht werden.“ . Während in einem einzelnen Package die Sections funktionslos sind, stellen sie beim Customizing von Forms oder Documentation-Elementen einen Einsprungpunkt für zusätzliche Dokumentationen bereit. Um die zusätzliche Information in die Dokumentation einzufügen, muss im gecustomizten Form eine neue Section über den Button in der Werkzeugleiste erstellt werden: Customizing einer Section: Framework Studio erkennt, dass das Form gecustomized wurde und listet in der Combobox Base Section alle in der Basis verfügbaren Section-ID’s auf. Über das Panel Other des Editors kann zur Kontrolle der zu editierenden Section(-ID) die Basis-Dokumentation des Formulars angezeigt werden. Im Dialog für die Section-Auswahl gibt es drei Möglichkeiten, eine Section zu überschreiben: Override Die Section aus der Basis wird durch den neuen Text ersetzt. Before Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars vor dem Text aus der Basis eingefügt. After Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars nach dem Text aus der Basis eingefügt. Wird der Dialog geschlossen, wird eine neue Section erstellt, die ein customize -Attribut beinhaltet, in der die ausgewählte Customizing-Methode steht. Die zusätzliche Information (Auftragspositionen können kopiert werden) kann nun eingegeben werden. Wird eine Vorschau der Dokumentation gerendert, erscheint der neue Text an der gewünschten Stelle in der Basis-Dokumentation (in diesem Fall hinter dem ersten Satz aus der Basis)."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public string FormatPattern { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxSize { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html",
    "title": "Property MaxScale",
    "keywords": "Property MaxScale MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxScale { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsEditable { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. Declaration public GridColumnDefinition.ColumnTextAlign? TextAlign { get; set; } Property Value Nullable < GridColumnDefinition.ColumnTextAlign >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html",
    "title": "Property Width",
    "keywords": "Property Width Width Gibt die initiale Spaltenbreite zurück oder legt diese fest. Declaration public int? Width { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. Declaration public string Caption { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. Declaration public DevMLString MLCaption { get; set; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html",
    "title": "Property ToolTip",
    "keywords": "Property ToolTip ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Declaration public string ToolTip { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html",
    "title": "Property MLToolTip",
    "keywords": "Property MLToolTip MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Declaration public DevMLString MLToolTip { get; set; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. Declaration public bool? DependsDataSourceOnRowData { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html",
    "title": "Property List",
    "keywords": "Property List List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. Declaration public ColumnListDataSource List { get; set; } Property Value ColumnListDataSource"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. Declaration public GridColumnDefinition.ColumnSortOrder ListSortOrder { get; set; } Property Value GridColumnDefinition.ColumnSortOrder"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html",
    "title": "Property ComponentType",
    "keywords": "Property ComponentType ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. Declaration public Type ComponentType { get; set; } Property Value Type"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html",
    "title": "Class GridColumnDefinition",
    "keywords": "Class GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Inheritance Object GridColumnDefinition Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class GridColumnDefinition Constructors GridColumnDefinition() Properties Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Width Gibt die initiale Spaltenbreite zurück oder legt diese fest."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetGrantedLanguages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetGrantedLanguages.html",
    "title": "Method GetGrantedLanguages",
    "keywords": "Method GetGrantedLanguages GetGrantedLanguages() Gibt eine Liste mit ISO Kürzeln der Sprachen zurück, die zur Verfügung stehen und durch die verwendeten Lizenzen freigegeben sind. Declaration public List<string> GetGrantedLanguages() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html",
    "title": "Method GetApplicationRoles",
    "keywords": "Method GetApplicationRoles GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles(bool reload) Parameters reload Boolean Mit true wird ein neues Laden der Rollen vom Authentication Service erzwungen. Returns List < String > GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html",
    "title": "Method GetUserRoles",
    "keywords": "Method GetUserRoles GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. Declaration public List<string> GetUserRoles() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html",
    "title": "Method GetRoleDescription",
    "keywords": "Method GetRoleDescription GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleDescription(string roleName) Parameters roleName String Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html",
    "title": "Method GetRoleCaption",
    "keywords": "Method GetRoleCaption GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleCaption(string roleName) Parameters roleName String Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html",
    "title": "Method GetUserUnits",
    "keywords": "Method GetUserUnits GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Declaration public List<string> GetUserUnits() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html",
    "title": "Interface IFSType",
    "keywords": "Interface IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung. Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax public interface IFSType : IComparable Remarks Siehe auch: FS-Datentypen Properties DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. IsNull Gibt an, ob der Wert der Variable Null ist. ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Methods EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter."
  },
  "doc/html-client/geraete-funktionen.html": {
    "href": "doc/html-client/geraete-funktionen.html",
    "title": "Gerätespezifische Funktionen",
    "keywords": "Gerätespezifische Funktionen Nachfolgend werden diejenigen Funktionen erläutert, die nur auf spezifischen Geräten verfügbar sind. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem zuzugreifen. Dadurch hat der HTML Client auf mobilen Geräten mehr Möglichkeiten als im Browser. Barcode Scanner (nur mobile Geräte) Über die in einem mobilen Gerät integrierte Kamera können im HTML Client Barcodes unterschiedlicher Formate eingescannt werden. Unterstützte Formate Name Beispiel AZTEC CODABAR CODE_39 CODE_93 CODE_128 DATA_MATRIX EAN_8 EAN_13 ITF PDF_417 QR_CODE UPC_A UPC_E Action ScanBarcode() In Framework Studio wird ein Scan über folgende Action am Form gestartet: ScanBarcode( Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat ) oder ScanBarcode( Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat, string identifier ) Beispiel: protected virtual void FE_btnScan_OnClick(FrameworkButtonClickEventArgs e) { this.ScanBarcode( this.ScanBarcodeCallback, BarcodeFormat.CODE_128 | BarcodeFormat.ITF, \"Article\" ); } Parameter Action callback Wenn der Scanvorgang am Client abgeschlossen ist, wird der übergebene Callback aufgerufen. Der Callback ist vom Typ Action<IFrameworkBarcodeScanInfo> IFrameworkBarcodeScanInfo Properties Property Typ Beschreibung Cancelled bool true wenn der Scanvorgang am Client abgebrochen wurde ErrorMessage string Fehlermeldung bei einem gescheiterten Scanvorgang Format BarcodeFormat Das Format des gescannten Barcodes HasError bool true wenn beim Scanvorgang ein Fehler aufgetreten ist Identifier string Der in ScanBarcode() übergebene Wert, sonst null Value string Der Wert des gescannten Barcodes Beispiel: public virtual void ScanBarcodeCallback(IFrameworkBarcodeScanInfo e) { this.Reset(); this.sIdentifier = e.Identifier; if (e.HasError) { this.sValue = e.ErrorMessage; } else if (e.Cancelled) { this.sValue = \"Cancelled\"; } else { this.sValue = e.Value; this.sFormat = e.Format.ToString(); } } Parameter BarcodeFormat allowedFormat Definiert, welches Barcode-Format am Client bei einem Scanvorgang unterstützt wird. Note Es wird dringend empfohlen, nur diejenigen Barcode-Formate zu übergeben, die auch tatsächlich beim Scanvorgang unterstützt werden sollen, um Fehler beim Scannen zu vermeiden. Je geringer die Anzahl der unterstützten Formate ist, desto unwahrscheinlicher ist es, dass der Scan fehlschlägt. Beispiel: Wenn am Client z.B. CODE_128 und ITF unterstützt werden soll, so können diese per bitweiser Oder-Verknüpfung übergeben werden. protected virtual void FE_btnScan_OnClick(FrameworkButtonClickEventArgs e) { this.ScanBarcode( this.ScanBarcodeCallback, BarcodeFormat.CODE_128 | BarcodeFormat.ITF, \"Article\" ); } Parameter string identifier Es kann vorkommen, dass auf einem Form mehrere Buttons einen Scan initiieren können. Beispielsweise könnte erst ein Auftrag und nachfolgend eine Menge eingescannt werden. Es ist aber oft nicht praktikabel, für jeden Scanvorgang einen separaten Callback zu implementieren. Anstatt dessen kann der ScanBarcode() -Action einfach ein beliebiger string mitgegeben werden, über den der Scanvorgang im Callback identifiziert werden kann. Beispiel: public virtual void ScanBarcodeCallback(IFrameworkBarcodeScanInfo e) { this.Reset(); this.sIdentifier = e.Identifier; if (e.HasError) { this.sValue = e.ErrorMessage; } else if (e.Cancelled) { this.sValue = \"Cancelled\"; } else { if (e.Identifier == \"Article\") { this.sArticle = e.Value; } else { this.sAmount = e.Value; } this.sFormat = e.Format.ToString(); } } Berechtigung für Kamera Der Barcode Scanner benötigt auf dem mobilen Gerät Zugriff auf die Kamera. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden:"
  },
  "doc/html-client/android-app.html": {
    "href": "doc/html-client/android-app.html",
    "title": "Android App",
    "keywords": "Android App Für die volle Integration des HTML-Clients in die mobile Welt, stellen wir im Google Play Store den Client als Android App zur Verfügung. Diese ist vom Funktionsumfang equivalent zur Browser-Version. Name der App : Framework Studio Mobile Client Store Link : https://play.google.com/store/apps/details?id=com.fs.htmlclient Note Wir können derzeit noch keine Aussagen zu einer Veröffentlichung der App für iOS treffen. Einrichten eines Brokers Es muss natürlich definiert werden, mit welchem Broker sich der Mobile Client verbinden soll. Nach dem Start der App wird der Login angezeigt. Über den Button „+ New“ können beliebig viele Broker zur Liste hinzugefügt werden. Es ist auch möglich, Urls von Development Brokern hinzuzufügen. Dabei ist zu beachten, dass der Mobile Client nur auf den Development Broker zugreifen kann, wenn dieser über das Netzwerk erreichbar ist. Dazu muss Framework Studio mit Administrator-Rechten ausgeführt werden. Ob der Development Broker vom Netzwerk aus zugreifbar ist, kann über das Tray-Icon geprüft werden:"
  },
  "doc/documentation/vererbung.html": {
    "href": "doc/documentation/vererbung.html",
    "title": "Vererbung",
    "keywords": "Vererbung Ähnlich wie bei den Tooltips für Steuerelemente bietet auch die Dokumentation eine Vererbung bis auf Metadatentyp-Ebene an. Diese Vererbung soll dazu beitragen, Dokumentationen für Steuerelemente mit derselben Funktion nicht mehrmals verfassen oder kopieren zu müssen. Vererbung einer Dokumentation: Die Abbildung zeigt die Möglichkeit der Vererbung vom Steuerelement auf dem Form bis zum Metadatentyp ggf. auch über mehrere Packages hinweg, gesetzt den Fall, dass dem jeweiligen Steuerelement eine DataSource zugewiesen wurde. Eingebunden werden kann eine Dokumentation aus einem darunter liegenden Element mit Hilfe des base-Tags (siehe Base ). Vererbung in einem einzigen Package Im folgenden Beispiel wird gezeigt, wie mit Hilfe der Vererbung in der Dokumentation des Textfelds T die Dokumentationen aus dessen Component Properties (DataSource), der dazu gehörigen DBColumn und des wiederum damit verbundenen Metadatentyps eingebunden werden kann. Betrachtet wird das Szenario eines einzelnen Packages P1 (blaue Pfeile). Die Dokumentation des Metadatentyps M sieht wie folgt aus: Die Dokumentation der DBColumn D bindet mit Hilfe des base-Tags die Dokumentation des Metadatentyps ein. Beim Rendern wird an die Stelle des base-Tags somit die Dokumentation des Metadatentyps eingebunden: Am Component Property C ist dasselbe Verhalten zu erkennen: Letztlich bindet auch das Textfeld T die Basis-Dokumentation ein, was folgende Ausgabe ergibt: An der Dokumentation des Controls ist nun zu erkennen, dass die Information über das Drücken der F2 -Taste am Control auf dem Formular dokumentiert wurde. Dies könnte auf einem anderen Formular z.B. ein anderer Shortcut sein. Die restliche Dokumentation inklusive des rot markierten Beispiels würde aber automatisch übernommen werden. Diese Art der Vererbung ist also immer dann sinnvoll, wenn auf unterschiedlichen Formularen in der Anwendung Steuerelemente existieren, die genau dieselben DataSources verwenden. Beispiel In einer Anwendung gibt es auf 6 verschiedenen Formularen immer wieder ein Textfeld, welches eine Auftragsnummer anzeigt. Die Funktion des Textfeldes ist auf jedem Form dieselbe und beinhaltet auch immer die Daten desselben Component Properties (die Textfelder haben immer die gleiche DataSource), baut somit immer auf derselben DBColumn auf und ist damit auch vom selben Metadatentyp abhängig. Es wäre nun sehr umständlich, jedes Mal am Steuerelement selbst dieselbe Dokumentation zu hinterlegen. Sollte sich diese ändern, müssten alle 6 Stellen angepasst und erneut auf Fehler überprüft werden. Um dies zu vermeiden, kann die Vererbung genutzt werden. Da die 6 Textfelder immer auf demselben Component Property aufsetzen, kann die gesamte Dokumentation an diesem verfasst werden. Der große Vorteil dieses Vorgehens ist, wenn sich an der Dokumentation etwas ändert, muss nur die Dokumentation des Component Properties angepasst werden und beim nächsten Rendern haben alle abhängigen Textfelder die aktualisierte Dokumentation des Component Properties übernommen. Insgesamt gilt also: Die Dokumentation sollte so tief wie möglich im Framework Studio verfasst und auf möglichst viele Elemente vererbt werden. Entstehen in der Datasource Hierarchy an einer Stelle Lücken in der Dokumentation, wird die Dokumentation aus der nächst tieferen Ebene eingebunden. Befindet sich z.B. in der Dokumentation eines Textfelds T ein base-Tag, wird beim Rendern die Dokumentation aus dem Component Property verwendet. Ist jedoch keine Dokumentation an selbigem verfasst, wird automatisch in der tieferen Ebene nach einer Dokumentation geprüft. In diesem Fall würde die Dokumentation der DBColumn verwendet werden. Ist an selbiger auch keine Dokumentation verfasst, wird die des Metadatentyps eingebunden. Beispiel Eine leere Dokumentation verhält sich wie ein base-Tag: An einem Textfeld ist nicht explizit eine Dokumentation hinterlegt. Das per DataSource zugewiesene Component Property beinhaltet jedoch eine Dokumentation. Wie zu sehen ist, wird automatisch die Dokumentation des Component Properties für das Textfeld gerendert, wenn die Preview angezeigt wird. Eine nicht vohandene Dokumentation in einem Control, einem Property, einer DBColumn oder einem Metadatentyp verhält sich also genauso wie ein base-Tag ohne weiteres DocML. base-Tag ohne weiteres DocML: Das gezeigte base-Tag kann also entfernt werden, da sich die leere Dokumentation äquivalent verhält. Vererbung bei mehreren Packages Liegen mehrere Packages übereinander (grüne und orangene Pfeile), wird immer erst die höchste Customization des jeweiligen Elements betrachtet. Vererbung über mehrere Packages hinweg: Beispiel (grüne Pfeile): Wird die Dokumentation für die Customization vom Textfeld T im Package P2 gerendert, wird für ein base-Tag in P1 nach einer Dokumentation gesucht. Wird dort nichts gefunden oder erfolgt dort ein weiterer Base-Aufruf, wird an der Customization des Component Properties C in P2 gesucht usw."
  },
  "doc/documentation/docml.html": {
    "href": "doc/documentation/docml.html",
    "title": "DocML",
    "keywords": "DocML Bei einer Dokumentation in Textform bedarf es grundsätzlich der Möglichkeit, den Text zu formatieren und zu strukturieren. Für diesen Zweck bedient sich Framework Studio der eigens entwickelten Dokumentationssprache DocML . Ein Vorteil dieser Sprache ist, dass sie in beliebige andere Formate konvertiert werden kann. So ist die Vorschau einer Dokumentation in Framework Studio z.B. in Form von HTML realisiert. Es besteht aber auch die Möglichkeit, die gesamte Dokumentation als Worddatei zu exportieren. Um einen ersten Eindruck der Sprache zu bekommen folgt ein kurzer Auszug einer Dokumentation eines Formulars: Und hier die Ausgabe im Preview-Fenster in Framework Studio (HTML): Aufbau der Sprache Die Sprache DocML besteht weitestgehend aus dem Text, welcher die Dokumentation widerspiegelt sowie Tags, die mit Attributen versehen sein können, um den beinhaltenden Text zu formatieren oder zu strukturieren. Tags Ein Tag definiert sich durch eine öffnende eckige Klammer [ , einem Bezeichner (um welches Tag es sich handelt), gefolgt von einer schließenden eckigen Klammer ] : [ + Bezeichner + ] Beispiele: [b] , [tbl] , [f] , [ac] Dabei wird zwischen öffnenden und schließenden Tags unterschieden. Das schließende Tag beinhaltet nach der öffnenden Klammer einen Schrägstrich / : [/ + Bezeichner + ] Beispiele: [/b] , [/tbl] , [/f] , [/ac] Angewendet wird ein Tag immer auf den Text, der zwischen dem öffnenden und schließenden Tag steht: [b] Dies ist ein fett gedruckter Text [/b] Tags können ineinander geschachtelt werden um mehrere Formatierungen auf einen Textabschnitt vorzunehmen: [b][i] Dies ist ein fett gedruckter und kursiver Text [/i][/b] Es ist zu beachten, dass öffnende Tags genau in der umgekehrten Reihenfolge geschlossen werden müssen. Folgende Beispiele sind korrekt: [b][i] Ein Text [/i][/b] [i][b] Ein Text [/b][/i] [b][i][u] Ein Text [/u][/i][/b] Folgende Beispiele sind nicht korrekt: [b][i] Ein Text [/b][/i] [i][b] Ein Text [/i][/b] [b][i][u] Ein Text [/b][/u][/i] Eine komplette Auflistung aller verfügbaren Tags in DocML und deren Funktion findet sich im Kapitel Tag Reference . Leere Tags Eine besondere Untergruppe der Tags bilden die leeren Tags. Dies sind öffnende und schließende Tags in einem. Leere Tags können keinen Text oder andere Tags beinhalten. Leere Tags definieren sich durch eine öffnende eckige Klammer [ , den Bezeichner, einen Schrägstrich / und die schließende eckige Klammer ] : [ + Bezeichner + / + ] Beispiele: [screenshot/] , [img/] , [br/] Diese leeren Tags dienen z.B. dem Einfügen eines Bildes oder Zeilenumbruch in die Dokumentation. Tag-Attribute Die meisten Tags können in ihrem Verhalten durch Attribute gesteuert werden. Ein Attribut definiert sich durch einen Bezeichner gefolgt, von einem Gleichheitszeichen = sowie dem Attributwert in Hochkommas. Attribute können in öffnenden und leeren Tags vorkommen: In öffnendem Tag: [f bg=\"ff0000\" ] Text mit roter Hintergrundfarbe [/f] In leerem Tag: [screenshot caption=\"Auftragserfassung\" /] Im Kapitel Tag Reference ist ausführlich beschrieben, welcher Tag mit welchen Attributen gesteuert werden kann. Tag Reference Nachfolgend werden alle verfügbaren Tags und die zugehörigen Attribute der DocML -Sprache beschrieben. Die Tags unterscheiden sich in zwei Klassen, Inline-Tags und Block-Tags . Inline-Tags werden meist für Formatierungszwecke genutzt wie z.B. Fettschrift oder Textfarbe, während Block-Tags Strukturen wie Tabellen, Listen oder Abschnitte definieren. Warning Grundsätzlich gilt: Inline-Tags können keine Block-Tags beinhalten Inline-Tags Font Eigenschaften: Bezeichner: [f] Leeres Tag: nein Funktion: Wendet Schriftart, Schriftgröße, Schriftfarbe und Hintergrundfarbe auf den beinhaltenden Text an Attributes: Bez. Benötigt Mögliche Werte Funktion style nein Normal, Code Stellt die Schriftart zwischen Arial und einer Code-Schriftart um size nein XXXL, XXL, XL, L, Normal, S, XS, XXS oder XXXS Schriftgröße fc nein Systemfarben wie red , black , blue oder Farbangaben in HEX wie z.B. #FF00000 Textfarbe bc nein Systemfarben wie red , black , blue oder Farbangaben in HEX wie z.B. #FF00000 Hintergrundfarbe Beispiel: [f style=\"code\" size=\"xl\" fc=\"red\" bc=\"#00ff00\"]Möglichkeiten des Font-Tags[/f] Bold Eigenschaften: Bezeichner: [b] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als fett geschrieben Attributes: Keine Beispiel: [b]Dieser Text ist fett geschrieben[/b] Italic Eigenschaften: Bezeichner: [i] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als kursiv geschrieben Attributes: Keine Beispiel: [i]Dieser Text ist kursiv geschrieben[/i] Underline Eigenschaften: Bezeichner: [u] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als unterstrichen Attributes: Keine Beispiel: [u]Dieser Text ist unterstrichen[/u] Strikethrough Eigenschaften: Bezeichner: [s] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als durchstrichen Attributes: Keine Beispiel: [s]Dieser Text ist durchstrichen[/s] Subscript Eigenschaften: Bezeichner: [sub] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als tiefgestellt Attributes: Keine Beispiel: [sub]Dieser Text ist tiefgestellt[/sub] Superscript Eigenschaften: Bezeichner: [sup] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als hochgestellt Attributes: Keine Beispiel: [sup]Dieser Text ist hochgestellt[/sup] Align Left Eigenschaften: Bezeichner: [al] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als linksbündig Attributes: Keine Beispiel: [al]Dieser Text ist linksbündig[/al] Center Eigenschaften: Bezeichner: [ac] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als zentriert Attributes: Keine Beispiel: [ac]Dieser Text ist zentriert[/ac] Align Right Eigenschaften: Bezeichner: [ar] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als rechtsbündig Attributes: Keine Beispiel: [ar]Dieser Text ist rechtsbündig[/ar] Justify Eigenschaften: Bezeichner: [aj] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als Blocksatz Attributes: Keine Beispiel: [aj]Dieser Text ist im Blocksatz geschrieben[/aj] Image Eigenschaften: Bezeichner: [img] Leeres Tag: ja Funktion: Bindet eine Bildressource aus Framework Studio in die Dokumentation ein Besonderheiten: Wird nur das width- oder height-Attribut angegeben, wird das Seitenverhältnis des Bildes beibehalten. Werden keine Größenangaben gemacht, wird die Größe des Quellbildes verwendet. Eine Bildbezeichnung (caption-Attribut) kann nur definiert werden, wenn das inline-Attribut nicht definiert ist oder den Wert false hat. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja ID einer Framework Studio Bildressource Verweist auf das Bild, welches in der Framework Studio Resource eingebunden ist width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) height nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Höhe des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. height=“4.7in“) caption nein Text Bildbezeichnung inline nein true , false Wenn true wird das Bild wird ein Textzeichen im Textfluss behandelt, sonst wird eine neue Zeile eingefügt Beispiel: [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" height=\"1.5cm\" inline=\"true\"/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" caption=“Beispielbild“/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" width=“3cm“ height=\"1.5cm\" caption=“Test“/] Screenshot Eigenschaften: Bezeichner: [screenshot] Leeres Tag: ja Funktion: Bindet einen automatisch generierten Screenshot des Forms als Bild in die Dokumentation ein. Besonderheiten: Kann nur in Form-Dokumentationen verwendet werden. Werden keine Größenangaben gemacht, wird die Größe des Forms verwendet. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) caption nein Text Bezeichnung des Screenshots Beispiel: [screenshot/] [screenshot width=\"17cm\"/] [screenshot width=\"14.3in\" caption=\"Kostenrechnung\"/] caption=\"Test\"/] Link Eigenschaften: Bezeichner: [lnk] Leeres Tag: ja Funktion: Erstellt einen Querverweis auf ein anderes Kapitel oder einen Hyperlink auf eine Url. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja • ID eines Forms oder Documentation-Elements • Url mit führendem http:// Querverweis in der fertigen Dokumentation oder Hyperlink auf die angegebene Url text ja Text Der angezeigte Text des Links Beispiel: [lnk src=\"f037492b790d24c5b9f16cb4120465e25\" text=\"Artikeldetails\"/] [lnk src=\"http://www.google.de/\" text=\"Suchen mit Google\"/] Index Entry Eigenschaften: Bezeichner: [idx] Leeres Tag: ja Funktion: Erstellt einen Eintrag im Index der Dokumentation. Attributes: Bez. Benötigt Mögliche Werte Funktion entry ja text Definiert einen Haupteintrag im Index subentry nein Text Definiert einen Untereintrag unter dem Haupteintrag Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Base Eigenschaften: Bezeichner: [base] Leeres Tag: ja Funktion: Bindet die Basis-Dokumentation eines Controls, Component Properties, einer DBColumn oder eines Metadatentyps ein. Besonderheiten: Wird nur an Control, Component Property, DBColumn und Metadatentyp unterstützt. Mehr Information in den Kapiteln Vererbung und Customizing . Attributes: Keine Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Line Eigenschaften: Bezeichner: [line] Leeres Tag: ja Funktion: Erstellt eine Line als Absatztrenner über die komplette Seitenbreite. Attributes: Keine Beispiel: [line/] Break Eigenschaften: Bezeichner: [br] Leeres Tag: ja Funktion: Erstellt einen Zeilenumbruch. Attributes: Keine Beispiel: [br/] Block-Tags Section Eigenschaften: Bezeichner: [section] Leeres Tag: optional Funktion: Definiert einen Textabschnitt in einer Form-Dokumentation oder einem Documentation-Element, der durch die angegebene ID customizing-fähig ist. Siehe Customizing . Besonderheiten: Kann sich nur auf oberster Ebene und somit nicht in anderen Tags befinden. Wird nur in Form- und Documentation-Elementen unterstützt. Attributes: Bez. Benötigt Mögliche Werte Funktion id ja 32-stellige GUID Eindeutige ID des Textabschnitts customize Im Custom-Package before, after, override Überschreibungsart der gecustomizten Section Beispiel: [section id=“ f0bcfd1621444f6f9f24bc9305120809“/] [section id=“ f0bcfd1621444f6f9f24bc9305120809“ customize=“after“/] List Eigenschaften: Bezeichner: [lst] Leeres Tag: nein Funktion: Erstellt eine geordnete oder ungeordnete Liste von ListItems (li-Tags). Besonderheiten: Kann nur li-Tags beinhalten. Das Symbol kann nur definiert werden, wenn das type-Attribut als „unordered“ definiert ist. Attributes: Bez. Benötigt Mögliche Werte Funktion type ja ordered, unordered Definiert den Listentyp symbol nein disk, circle, square Definiert das Listensymbol bei ungeordneten Listen Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] [lst type=\"ordered\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] ListItem Eigenschaften: Bezeichner: [li] Leeres Tag: nein Funktion: Erstellt einen Eintrag in einer Liste. Besonderheiten: Kann nur innerhalb von lst-Tags verwendet werden. Attributes: Keine Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]Ein ListItem[/li] [li]Noch ein ListItem[/li] [/lst] Table Eigenschaften: Bezeichner: [tbl] Leeres Tag: nein Funktion: Erstellt eine Tabelle. Besonderheiten: Die Breite der Tabelle kann absolut als auch prozentual angegeben werden. Wird keine Breite angegeben, definiert sich die Tabellenbreite über die Summe der Spaltenbreiten. Ist die Tabellenbreite in Prozent angegeben, müssen auch die Spaltenbreiten in Prozent angegeben werden. Ist keine Tabellenbreite angegeben, müssen die Spaltenbreiten in absoluten Werten angegeben werden. Eine Tabelle muss eine Spaltendefinition (coldef-Tag) inkl. Spalten (col-Tags) sowie mindestens eine Zeile (row-Tag) beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. Beispiel: Ausgabe: Column Definition Eigenschaften: Bezeichner: [coldef] Leeres Tag: nein Funktion: Beinhaltet die Spaltendefinition einer Tabelle. Besonderheiten: Muss ein oder mehrere Spalten (col-Tags) beinhalten. Kann nur innerhalb eines tbl-Tags vorkommen. Kann innerhalb eines tbl-Tags nur einmal vorkommen. Kann nur col-Tags beinhalten. Muss innerhalb des tbl-Tags als erstes auftreten (vor jeglichen Zeilendefinitionen bzw. row-Tags). Attributes: Keine Beispiel: [coldef] [col width=\"50%\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] [/coldef] Column Eigenschaften: Bezeichner: [col] Leeres Tag: ja Funktion: Definiert eine Spalte innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines coldef-Tags vorkommen. Die Breite der Spalte kann absolut oder prozentual angegeben werden. Ist die Tabellenbreite (im tbl-Tag) prozentual angegeben, muss die Spaltenbreite ebenfalls prozentual angegeben werden. Ist keine Tabellenbreite (im tbl-Tag) angegeben, muss die Spaltenbreite absolut angegeben werden. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein left, center, right Horizontale Ausrichtung der Spalte. Kann durch das colalign-Attribut an der Zelle überschrieben werden. Beispiel: [col width=\"4.5cm\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] Row Eigenschaften: Bezeichner: [row] Leeres Tag: nein Funktion: Definiert eine Zeile innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines tbl-Tags vorkommen. Muss innerhalb des tbl-Tags unterhalb des coldef-Tags stehen. Kann nur cell-Tags beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein top, middle, bottom Vertikale Ausrichtung der Zeile. Kann durch das rowalign-Attribut an der Zelle überschrieben werden. Beispiel: [row fc=“#ddee43“] [cell]Zelle links oben[/cell] [cell rowalign=“top“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row] Cell Eigenschaften: Bezeichner: [cell] Leeres Tag: nein Funktion: Definiert eine Zelle innerhalb einer Zeile. Besonderheiten: Kann nur innerhalb eines row-Tags vorkommen. Muss innerhalb eines row-Tags genauso oft vorkommen wie die Anzahl der Spalten im coldef-Tag der Tabelle. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. rowalign nein top, middle, bottom Vertikale Ausrichtung der Zelle. colalign nein left, center, right Horizontale Ausrichtung der Zelle. Beispiel: [row fc=“#ddee43“] [cell fc=“#3434ee“]Zelle links oben[/cell] [cell colalign=“center“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row]"
  },
  "doc/konzepte/fs-types.html": {
    "href": "doc/konzepte/fs-types.html",
    "title": "FS-Datentypen",
    "keywords": "FS-Datentypen FS-Datentypen verhalten sich fast genauso wie die .NET-Datentypen mit ähnlich lautenden Namen. Der Unterschied zu den .NET-Datentypen besteht darin, dass sie einen Null-Wert verstehen. Die FS-Datentypen sind die Basis für die Metadatentypen. Sie können aber auch als Datentyp für Properties oder einfach frei im Code verwendet werden. Sie sollten immer dann verwendet werden, wenn die Null-Information nicht verloren gehen darf. Mit diesen Datentypen ist es möglich, Null-Werte aus einer Datenbank auszuwerten und auch wieder in die Datenbank zurückzuschreiben. Außerdem können z.B. Datenfelder in Forms, die eine Zahl oder ein Datum enthalten, komplett leer sein, was z.B. bei Suchfeldern wichtig ist. Bei den FS-Datentypen handelt es sich ebenfalls um Structs. Die Wertzuweisungen zwischen verschiedenen FS-Datentypen erfolgen also ByValue – wie bei den .NET-Datentypen auch. Variablen und Properties von einem FS-Datentyp können genauso verwendet werden wie Variablen und Properties von .NET-Datentypen. Es können auch Zuweisungen zwischen den verschiedenen Datentypen erfolgen. Es erfolgt in den meisten Fällen eine implizite Konvertierung der Datentypen. Die Null-Information geht dabei aber verloren. Properties der FS-Datentypen Value: (Property) Wert des FS-Datentyps als .NET-Datentyp. D.h.: FSdecimal.Value liefert einen Wert vom Typ dezimal. Dieser Wert kann sowohl gelesen als auch geschrieben werden. Ist der Wert der Variable Null, liefert Value den in der folgenden Tabelle angegebenen Wert aus der Spalte Null-Value zurück. Das Setzen des Wertes der Variable auf einen Null-Value hat aber nicht zur Folge, dass die Variable Null wird. Einzige Ausnahme ist FSstring: IsNull bedeutet Value=““ und Value=““ bedeutet IsNull. Beispiel: FSdecimal decVar1 = 0; // Wert auf 0 oder Null prüfen if (decVar1.Value == 0) { … } // Variante ohne Value if (decVar1.IsNull || decVar1 == 0 ) { … } // Wert zuweisen: decVar1 = 5; //oder decVar1.Value = 5; IsNull (Property) Ist vom Typ bool . Gibt an, ob der Wert der Variable Null ist. Um einem FS-Datentypen explizit ein Null zuzuweisen, gibt es zwei Möglichkeiten: Sie weisen dem Property IsNull true zu, oder Sie weisen der Variable FSxxx.Null zu FSdecimal decVar1 = 0; // Wert nur auf Null prüfen if (decVar1.IsNull) { … } // Wert auf Null setzen decVar1.IsNull = true; // oder decVar1 = FSdecimal.Null; Null (Statisches Property) Liefert eine Variable mit einem Null-Wert. // Variable mit Null initialisieren FSdecimal decVar2 = FSdecimal.Null; Es folgt eine Tabelle mit allen FS-Datentypen und deren Null-Value. .NET-Datentyp FS-Datentyp Null-Value bool FSBool false byte FSbyte 0 DateTime FSDateTime DateTime.MinValue decimal FSdecimal 0 double FSdouble 0 float FSfloat 0 int FSint 0 long FSlong 0 short FSshort 0 string FSstring String.Empty HasValue (Property) Ist vom Typ bool . Man kann mit IsNull prüfen, ob ein FSType ( FSstring , FSdecimal , …) null ist. Wenn das Gegenteil geprüft werden soll, kann das Property HasValue verwendet werden. So wird der Code deutlich lesbarer, vor allem dann, wenn das zu prüfende Property tief verschachtelt ist. Beispiel: // herkömmlicher Weg (Das Ausrufezeichen wird schnell überlesen): if (!this.oOrder.oCustomer.sCompany1.IsNull) // neuer Weg: if (this.oOrder.oCustomer.sCompany1.HasValue) FSDateTime.Now Statisches Property am Typ FSDateTime , welches das aktuelle System-Datum sekundengenau zurückgibt. Wenn man mit der Datenbank oder auch mit Benutzer-Eingaben arbeitet, werden in der Regel sekundengenaue Werte verarbeitet. Wenn man mit dem System.DateTime.Now arbeitet, erhält man einen um mehrere Zehnerpotenzen genaueren Wert. Bei Vergleichen mit Benutzereingaben weichen diese dann von System.DateTime.Now ab. Es wird daher empfohlen, alle Daten, die mit dem aktuellen Datum initialisiert werden sollen, mit FSDateTime.Now zu initialisieren. Beispiel: // Variable mit sekundengenauem Wert der aktuellen Zeit initialisieren FSDateTime dtMyDate = FSDateTime.Now; Wenn mit genaueren Werten gearbeitet werden soll, ist die folgende Initialisierung ebenfalls möglich: // Variable möglichst genau mit der aktuellen Zeit initialisieren FSDateTime dtMyAccurateDate = DateTime.Now;"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Metadatatype",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Metadatatype Classes MLContainer TODO! Structs FSbool Summary description for FSbool. FSbyte TODO! Summary description for FSbyte. FSbyteArray TODO! Summary description for FSbyteArray. FSDateTime TODO! Summary description for FSDateTime. FSdecimal TODO! Summary description for FSdecimal. FSdouble TODO! Summary description for FSdouble. FSfloat TODO! Summary description for FSfloat. FSint TODO! Summary description for FSint. FSlong TODO! Summary description for FSlong. FSshort TODO! Summary description for FSshort. FSstring TODO! Summary description for FSstring. FSSystemGuid TODO! Summary description for FSSystemGuid. Interfaces IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html",
    "title": "Struct FSfloat",
    "keywords": "Struct FSfloat TODO! Summary description for FSfloat. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSfloat : IFSfloat, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html",
    "title": "Constructor FrameworkProgress",
    "keywords": "Constructor FrameworkProgress FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Declaration public FrameworkProgress(IGlobalObjects global) Parameters global IGlobalObjects"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html",
    "title": "Property Id",
    "keywords": "Property Id Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. Declaration public guid Id { get; } Property Value FrameworkSystems.FrameworkDataProvider.BaseObjects.guid"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html",
    "title": "Property CanCancel",
    "keywords": "Property CanCancel CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Declaration public bool CanCancel { get; set; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html",
    "title": "Property Canceled",
    "keywords": "Property Canceled Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. Declaration public bool Canceled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Der Text, der über dem ProgressBar angezeigt werden soll. Declaration public string Text { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html",
    "title": "Property DetailText",
    "keywords": "Property DetailText DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Declaration public string DetailText { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html",
    "title": "Property MaxValue",
    "keywords": "Property MaxValue MaxValue Der Maximalwert des Fortschrittsbalken. Declaration public long MaxValue { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Declaration public long Value { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html",
    "title": "Method Dispose",
    "keywords": "Method Dispose Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client. Declaration public void Dispose()"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html",
    "title": "Class FrameworkProgress",
    "keywords": "Class FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. Inheritance Object FrameworkProgress Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FrameworkProgress : IDisposable Remarks Es können auch mehrere FrameworkProgress Objekte zeitgleich verwendet werden. Die angezeigten Balken werden untereinander angeordnet. Examples using(FrameworkProgress progress = new FrameworkProgress(this.Global)) { // gibt an, ob der Cancel-Button überhaupt angezeigt werden soll progress.CanCancel = true; // sonstige Eigenschaften progress.Text = \"Fortschritt ...\"; progress.MaxValue = 1000; for(int i = 0; i <= progress.MaxValue; i++) { // breche ab, falls progress.Canceled = true if(progress.Canceled) { break; } progress.Value = i; progress.DetailText = \"i hat den Wert \" + i; // Aktion ... } } Anzeige auf dem Client: Constructors FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Properties CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. MaxValue Der Maximalwert des Fortschrittsbalken. Text Der Text, der über dem ProgressBar angezeigt werden soll. Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Methods Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client."
  },
  "api/FrameworkSystems.FrameworkControls.html": {
    "href": "api/FrameworkSystems.FrameworkControls.html",
    "title": "Namespace FrameworkSystems.FrameworkControls",
    "keywords": "Namespace FrameworkSystems.FrameworkControls Classes ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Enums GridColumnDefinition.ColumnSortOrder GridColumnDefinition.ColumnTextAlign"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html",
    "title": "Enum FrameworkFormatMask",
    "keywords": "Enum FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben) Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FrameworkFormatMask Fields Name Description DateOnlyLong DateOnlyMedium DateOnlyShort DateTimeLong DateTimeMedium DateTimeShort Decimal Integer LowerCase NegativeInteger None PositiveInteger TimeOnlyLong TimeOnlyMedium TimeOnlyShort UpperCase UserDefined"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html",
    "title": "Field Image",
    "keywords": "Field Image Stellt ein Bild dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string Image = \"image/x-java-image\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html",
    "title": "Field FileList",
    "keywords": "Field FileList Stellt Dateien dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string FileList = \"application/x-java-file-list\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html",
    "title": "Field TextXml",
    "keywords": "Field TextXml Stellt Text im XML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextXml = \"text/xml\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html",
    "title": "Field TextHtml",
    "keywords": "Field TextHtml Stellt Text im HTML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextHtml = \"text/html\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html",
    "title": "Property ImageByteArray",
    "keywords": "Property ImageByteArray ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde. Declaration public byte[] ImageByteArray { get; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html",
    "title": "Class ImageFlavorData",
    "keywords": "Class ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. Inheritance Object FlavorData ImageFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ImageFlavorData : FlavorData Properties ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html",
    "title": "Field BROKER_TAG",
    "keywords": "Field BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string BROKER_TAG = \"fsbroker://\" Returns Type Description String Remarks Ressourcen mit fsbroker://RelativerPfad werden von dem Browser ausgewertet und durch den absoluten Pfad ersetzt."
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html",
    "title": "Method CreateCommand",
    "keywords": "Method CreateCommand CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, IDictionary<string, string> args = null) Parameters commandName String args IDictionary < String , String > Returns String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: //Command-Args erstellen Dictionary<string, string> linkCommandArgs = new Dictionary<string, string>(); linkCommandArgs.Add(\"Key1\", \"1235\"); linkCommandArgs.Add(\"Key2\", \"Test\"); linkCommandArgs.Add(\"Key3\", \"Test 1234\"); // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", linkCommandArgs); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\"; CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, params KeyValuePair<string, string>[] args) Parameters commandName String args KeyValuePair < String , String >[] Returns String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die einzelnen Argumente können mit der Methode CreateArgument(String, Object) erzeugt werden, um die Konvertierung verschiedener Typen korrekt vorzunehmen. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", new KeyValuePair<string, string>(\"Key1\", \"Wert1\"), BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html",
    "title": "Method CreateArgument",
    "keywords": "Method CreateArgument CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. Declaration public static KeyValuePair<string, string> CreateArgument(string key, object value) Parameters key String value Object Returns KeyValuePair < String , String > Remarks So können z.B. die FS-Datentypen wie in dem nachfolgenden Beispiel als Wert übergeben werden: string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); Die FrameworkOnLinkClickEventArgs bieten Methoden GetArgument -Methoden (z.B. GetArgumentFSlong ) um mit dem richtigen Schlüssel einen Wert im entsprechenden FSTyp wieder auszulesen. Auslesen der Argumente im Browser-Event OnLinkClick : if (e.IsCommand && e.Command == \"TestCommand\") { FSlong lngDocumentID = e.GetArgumentFSlong(\"Belegnummer\"); FSstring sDocumentType = e.GetArgumentFSstring(\"Belegart\"); FSDateTime dtDate = e.GetArgumentFSDateTime(\"Datum\"); }"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html",
    "title": "Method TryParseCommand",
    "keywords": "Method TryParseCommand TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben. Declaration public static bool TryParseCommand(string url, out string commandName, out Dictionary<string, string> args) Parameters url String commandName String args Dictionary < String , String > Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html",
    "title": "Method CreateRessourcesUrl",
    "keywords": "Method CreateRessourcesUrl CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. Declaration public static string CreateRessourcesUrl(string relativePath) Parameters relativePath String Returns String Remarks Diese Url kann dann, wie im nachfolgendem Beispiel, in Verbindung mit HTML z.B. als Link zu einer Datei verwendet warden: // Link zu einer CSS-Datei sStyle = \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + BrowserCommand.CreateRessourcesUrl(\"test.css\") + \"\\\" />\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.html",
    "title": "Class BrowserCommand",
    "keywords": "Class BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. Inheritance Object BrowserCommand Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class BrowserCommand Fields BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Methods CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data Enums ComboEditStyle TODO!"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html",
    "title": "Struct FSdouble",
    "keywords": "Struct FSdouble TODO! Summary description for FSdouble. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdouble : IFSdouble, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html",
    "title": "Property ValueAsObject",
    "keywords": "Property ValueAsObject ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Declaration object ValueAsObject { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html",
    "title": "Property IsNull",
    "keywords": "Property IsNull IsNull Gibt an, ob der Wert der Variable Null ist. Declaration bool IsNull { get; set; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. Declaration bool HasValue { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html",
    "title": "Method GetFromObject",
    "keywords": "Method GetFromObject GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter. Declaration IFSType GetFromObject(object val) Parameters val Object Returns IFSType"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html",
    "title": "Property DBValue",
    "keywords": "Property DBValue DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. Declaration object DBValue { get; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html",
    "title": "Method EqualsValue",
    "keywords": "Method EqualsValue EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. Declaration bool EqualsValue(string value2) Parameters value2 String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html",
    "title": "Class DevFrameworkObject",
    "keywords": "Class DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. Inheritance Object FrameworkSystems.FrameworkBase.DevFrameworkBaseObject DevFrameworkObject Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public abstract class DevFrameworkObject : DevFrameworkBaseObject, ICloneable, IFSRebind, IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, IGuidObject, IGuidObjectBase"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html",
    "title": "Enum GridColumnDefinition.ColumnSortOrder",
    "keywords": "Enum GridColumnDefinition.ColumnSortOrder Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnSortOrder Fields Name Description Ascending Descending Unsorted"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html",
    "title": "Struct FSSystemGuid",
    "keywords": "Struct FSSystemGuid TODO! Summary description for FSSystemGuid. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSSystemGuid : IFSSystemGuid, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html",
    "title": "Struct FSshort",
    "keywords": "Struct FSshort TODO! Summary description for FSshort. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSshort : IFSshort, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html",
    "title": "Struct FSbyte",
    "keywords": "Struct FSbyte TODO! Summary description for FSbyte. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyte : IFSbyte, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html",
    "title": "Field XML_NULL",
    "keywords": "Field XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string XML_NULL = \"\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html",
    "title": "Field XMLNumberFormat",
    "keywords": "Field XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo XMLNumberFormat Returns Type Description CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html",
    "title": "Field DateTimeNumberFormat",
    "keywords": "Field DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo DateTimeNumberFormat Returns Type Description CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html",
    "title": "Property Get",
    "keywords": "Property Get Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Declaration public static XmlConverter Get { get; } Property Value XmlConverter"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html",
    "title": "Method IsConvertible",
    "keywords": "Method IsConvertible IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). Declaration public bool IsConvertible(Type type) Parameters type Type Returns Boolean IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. Declaration public bool IsConvertible(string typeName) Parameters typeName String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public T FromXml<T>(string xml) Parameters xml String Returns T Type Parameters Name Description T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml<T>(T value) Parameters value T Returns String Type Parameters Name Description T ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml(object value) Parameters value Object Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html",
    "title": "Class XmlConverter",
    "keywords": "Class XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Inheritance Object XmlConverter Implements IXmlConverter < FSbool > IXmlConverter < FSbyte > IXmlConverter < FSbyteArray > IXmlConverter < FSDateTime > IXmlConverter < FSdecimal > IXmlConverter < FSdouble > IXmlConverter < FSfloat > IXmlConverter < FSint > IXmlConverter < FSlong > IXmlConverter < FSshort > IXmlConverter < FSstring > IXmlConverter < FSSystemGuid > IXmlConverter < Boolean > IXmlConverter < Byte > IXmlConverter < Byte []> IXmlConverter < DateTime > IXmlConverter < Decimal > IXmlConverter < Double > IXmlConverter < Single > IXmlConverter < Int32 > IXmlConverter < Int64 > IXmlConverter < Int16 > IXmlConverter < String > IXmlConverter < Guid > Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class XmlConverter : IXmlConverter<FSbool>, IXmlConverter<FSbyte>, IXmlConverter<FSbyteArray>, IXmlConverter<FSDateTime>, IXmlConverter<FSdecimal>, IXmlConverter<FSdouble>, IXmlConverter<FSfloat>, IXmlConverter<FSint>, IXmlConverter<FSlong>, IXmlConverter<FSshort>, IXmlConverter<FSstring>, IXmlConverter<FSSystemGuid>, IXmlConverter<bool>, IXmlConverter<byte>, IXmlConverter<byte[]>, IXmlConverter<DateTime>, IXmlConverter<decimal>, IXmlConverter<double>, IXmlConverter<float>, IXmlConverter<int>, IXmlConverter<long>, IXmlConverter<short>, IXmlConverter<string>, IXmlConverter<Guid> Remarks Ein Objekt dieser Klasse wird als Singleton-Instanz angeboten. Note Im Java-Client gibt es ein entsprechendes Gegenstück, die Klasse FrameworkSystems.FSJavaClient.UIWrapper.DotNetTypes , welche statische Methoden zum Umwandeln von Objekten in einen String und umgekehrt anbietet. Unterstützte Typen Die Klasse unterstützt die Konvertierung ausschließlich für die im Folgenden aufgeführten Typen und implementiert für jeden der Typen T das entsprechende Interface IXmlConverter<T> : FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring FSSystemGuid bool byte byte[] DateTime decimal double float int long short string Guid Fields DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Properties Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Methods FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException ."
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html",
    "title": "Enum FrameworkCloseMode",
    "keywords": "Enum FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll. Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Flags] public enum FrameworkCloseMode Fields Name Description Close KeepUserLogin Restart"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html",
    "title": "Struct FSint",
    "keywords": "Struct FSint TODO! Summary description for FSint. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSint : IFSint, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Converter",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Converter Classes XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Interfaces IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T ."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.AccessControl",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.AccessControl Classes AccessUnit TODO! AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html",
    "title": "Constructor GridColumnDefinition",
    "keywords": "Constructor GridColumnDefinition GridColumnDefinition() Declaration public GridColumnDefinition()"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html",
    "title": "Property Property",
    "keywords": "Property Property Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Declaration public string Property { get; set; } Property Value String Examples Werden im Grid Elemente vom Typ cDynObj angezeigt, so bedeutet Property=\"oDevObj.sName\" , dass die Spalte Daten des Propertys sName des Unterobjekts oDevObj an cDynObj darstellt."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html",
    "title": "Property PropertyMdt",
    "keywords": "Property PropertyMdt PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer PropertyMdt { get; set; } Property Value MLContainer Remarks Wenn die Eigenschaft ComponentType nicht gesetzt werden muss, muss diese Eigenschaft ebenfalls nicht gesetzt werden. Die Werte können dann automatisch über Reflection ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. Declaration public EditorStyle? EditorStyle { get; set; } Property Value Nullable < EditorStyle >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Declaration public ComboEditStyle? EditStyle { get; set; } Property Value Nullable < ComboEditStyle >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html",
    "title": "Class TextFlavorData",
    "keywords": "Class TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. Inheritance Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class TextFlavorData : FlavorData Remarks In einem Drag&Drop-Vorgang können mehrere TextFlavorData Objekte (zu unterschiedlichen Textformaten) enthalten sein. Properties Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html",
    "title": "Enum FileFlavorData.FileType",
    "keywords": "Enum FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FileType Fields Name Description Directory Ordner / Verzeichnis. File Datei."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Gibt die Anzahl der enthaltenen URIs zurück. Declaration public int Count { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Declaration public override string Text { get; protected set; } Property Value String Overrides TextFlavorData.Text"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück. Declaration public IEnumerator<string> GetEnumerator() Returns IEnumerator < String > Examples UriListFlavorData oUriListFlavorData = oExternalTransferObject.GetUriListFlavordata(); foreach (string sUri in oUriListFlavorData) { // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html",
    "title": "Class UriListFlavorData",
    "keywords": "Class UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Inheritance Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class UriListFlavorData : TextFlavorData, IEnumerable<string>, IEnumerable Remarks Die Klasse ist enumerierbar ( IEnumerator<String> ). Diese Klasse ist eine Spezialisierung von TextFlavorData , da der URI-Listen-Flavor ein spezieller Text-Flavor ist. Properties Count Gibt die Anzahl der enthaltenen URIs zurück. Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html",
    "title": "Method GetSupportedFlavorTypes",
    "keywords": "Method GetSupportedFlavorTypes GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedFlavorTypes() Returns IEnumerable < String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html",
    "title": "Method GetSupportedTextFlavorTypes",
    "keywords": "Method GetSupportedTextFlavorTypes GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedTextFlavorTypes() Returns IEnumerable < String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html",
    "title": "Method IsFlavorTypeSupported",
    "keywords": "Method IsFlavorTypeSupported IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können. Declaration public bool IsFlavorTypeSupported(string flavorType) Parameters flavorType String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html",
    "title": "Method GetFlavorData",
    "keywords": "Method GetFlavorData GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . Declaration public FlavorData GetFlavorData(string flavorType) Parameters flavorType String Returns FlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html",
    "title": "Method GetTextFlavorData",
    "keywords": "Method GetTextFlavorData GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . Declaration public TextFlavorData GetTextFlavorData(string textFlavorType) Parameters textFlavorType String Returns TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html",
    "title": "Method GetBestTextFlavorType",
    "keywords": "Method GetBestTextFlavorType GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. Declaration public string GetBestTextFlavorType() Returns String Remarks Zu dem Daten zur Verfügung gestellt werden: TextXml TextHtml TextUriList TextPlain Ein unbekanntes Textformat, soweit eines unterstützt wird null , falls gar kein Textformat unterstützt wird"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html",
    "title": "Method GetBestTextFlavorData",
    "keywords": "Method GetBestTextFlavorData GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. Declaration public TextFlavorData GetBestTextFlavorData() Returns TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html",
    "title": "Method GetImageFlavorData",
    "keywords": "Method GetImageFlavorData GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . Declaration public ImageFlavorData GetImageFlavorData() Returns ImageFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html",
    "title": "Method GetFileListFlavorData",
    "keywords": "Method GetFileListFlavorData GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . Declaration public FileListFlavorData GetFileListFlavorData() Returns FileListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html",
    "title": "Method GetUriListFlavorData",
    "keywords": "Method GetUriListFlavorData GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . Declaration public UriListFlavorData GetUriListFlavorData() Returns UriListFlavorData"
  }
}