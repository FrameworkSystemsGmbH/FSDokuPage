{
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html",
    "title": "Property Name",
    "keywords": "Property Name | Improve this Doc View Source Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Declaration public string Name { get; protected set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html",
    "title": "Property FullName",
    "keywords": "Property FullName | Improve this Doc View Source FullName Gibt den Dateinamen inklusive Pfad zurück. Declaration public string FullName { get; protected set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html",
    "title": "Property LastModified",
    "keywords": "Property LastModified | Improve this Doc View Source LastModified Gibt das letzte Änderungsdatum der Datei zurück. Declaration public DateTime LastModified { get; protected set; } Property Value DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html",
    "title": "Property Content",
    "keywords": "Property Content | Improve this Doc View Source Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. Declaration public byte[] Content { get; protected set; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html",
    "title": "Class FileFlavorData",
    "keywords": "Class FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). Inheritance Object FileFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileFlavorData Properties Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. FullName Gibt den Dateinamen inklusive Pfad zurück. LastModified Gibt das letzte Änderungsdatum der Datei zurück. Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Type Gibt den Typ der Datei zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AUPermissionType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AUPermissionType.html",
    "title": "Enum AUPermissionType",
    "keywords": "Enum AUPermissionType Kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public enum AUPermissionType Fields Name Description Access Is general access allowed? AccessDerived Is access of an AccessUnit, which is derived from this AccessUnit, possible? Delete Is deleting allowed? Insert Is inserting allowed? Update Is updating allowed?"
  },
  "api/FrameworkSystems.FrameworkBase.HorizontalAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.HorizontalAlignment.html",
    "title": "Enum HorizontalAlignment",
    "keywords": "Enum HorizontalAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum HorizontalAlignment Fields Name Description Center Left Right Stretch"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html",
    "title": "Constructor FrameworkProgress",
    "keywords": "Constructor FrameworkProgress | Improve this Doc View Source FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Declaration public FrameworkProgress(IGlobalObjects global) Parameters global IGlobalObjects"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html",
    "title": "Property Id",
    "keywords": "Property Id | Improve this Doc View Source Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. Declaration public guid Id { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html",
    "title": "Property CanCancel",
    "keywords": "Property CanCancel | Improve this Doc View Source CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Declaration public bool CanCancel { get; set; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html",
    "title": "Property Canceled",
    "keywords": "Property Canceled | Improve this Doc View Source Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. Declaration public bool Canceled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html",
    "title": "Property Text",
    "keywords": "Property Text | Improve this Doc View Source Text Der Text, der über dem ProgressBar angezeigt werden soll. Declaration public string Text { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html",
    "title": "Property DetailText",
    "keywords": "Property DetailText | Improve this Doc View Source DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Declaration public string DetailText { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html",
    "title": "Property MaxValue",
    "keywords": "Property MaxValue | Improve this Doc View Source MaxValue Der Maximalwert des Fortschrittsbalken. Declaration public long MaxValue { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html",
    "title": "Property Value",
    "keywords": "Property Value | Improve this Doc View Source Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Declaration public long Value { get; set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html",
    "title": "Method Dispose",
    "keywords": "Method Dispose | Improve this Doc View Source Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client. Declaration public void Dispose()"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html",
    "title": "Class FrameworkProgress",
    "keywords": "Class FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. Inheritance Object FrameworkProgress Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FrameworkProgress : IDisposable Remarks Es können auch mehrere FrameworkProgress Objekte zeitgleich verwendet werden. Die angezeigten Balken werden untereinander angeordnet. Examples using(FrameworkProgress progress = new FrameworkProgress(this.Global)) { // gibt an, ob der Cancel-Button überhaupt angezeigt werden soll progress.CanCancel = true; // sonstige Eigenschaften progress.Text = \"Fortschritt ...\"; progress.MaxValue = 1000; for(int i = 0; i <= progress.MaxValue; i++) { // breche ab, falls progress.Canceled = true if(progress.Canceled) { break; } progress.Value = i; progress.DetailText = \"i hat den Wert \" + i; // Aktion ... } } Anzeige auf dem Client: Constructors FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Properties CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. MaxValue Der Maximalwert des Fortschrittsbalken. Text Der Text, der über dem ProgressBar angezeigt werden soll. Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Methods Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ListViewControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ListViewControlAction.html",
    "title": "Class ListViewControlAction",
    "keywords": "Class ListViewControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ListView angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ListViewControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ListViewControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ListViewDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ComboBoxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ComboBoxControlAction.html",
    "title": "Class ComboBoxControlAction",
    "keywords": "Class ComboBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Combobox angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ComboBoxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ComboBoxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ComboboxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkBase.GridRowHeader.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GridRowHeader.html",
    "title": "Enum GridRowHeader",
    "keywords": "Enum GridRowHeader Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum GridRowHeader Fields Name Description DisplayRowNumber DisplayRowStatus DisplayRowStatusAndNumber Inherit"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.PictureControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.PictureControlAction.html",
    "title": "Class PictureControlAction",
    "keywords": "Class PictureControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Picture angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction PictureControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class PictureControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also PictureDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TabPageControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TabPageControlAction.html",
    "title": "Class TabPageControlAction",
    "keywords": "Class TabPageControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TabPageControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TabPageControlAction : EditableControlAction, ISerializable, ITabPageControlAction, IFrameworkControlActionBase"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TabbedWindowControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TabbedWindowControlAction.html",
    "title": "Class TabbedWindowControlAction",
    "keywords": "Class TabbedWindowControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TabbedWindowControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TabbedWindowControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FieldRowControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FieldRowControlAction.html",
    "title": "Class FieldRowControlAction",
    "keywords": "Class FieldRowControlAction Inheritance Object FrameworkControlActionBase FieldRowControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class FieldRowControlAction : FrameworkControlActionBase, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FieldPanelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FieldPanelControlAction.html",
    "title": "Class FieldPanelControlAction",
    "keywords": "Class FieldPanelControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction FieldPanelControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class FieldPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.BackColor2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.BackColor2.html",
    "title": "Property BackColor2",
    "keywords": "Property BackColor2 | Improve this Doc View Source BackColor2 Bestimmt die zeilenweise alternierende Hintergrundfarbe einer Tabelle. Für den Hintergrund der Grid-Zeilen wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Grid-Zeilen die BackColor verwendet Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor2 { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridColor.html",
    "title": "Property GridColor",
    "keywords": "Property GridColor | Improve this Doc View Source GridColor !TODO Farbe der Tabellenteiler Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color GridColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.HeaderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.HeaderColor.html",
    "title": "Property HeaderColor",
    "keywords": "Property HeaderColor | Improve this Doc View Source HeaderColor !TODO Gibt an, die Hintergrundfarbe der Tabellenüberschrift. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color HeaderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridRowHeight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.GridRowHeight.html",
    "title": "Property GridRowHeight",
    "keywords": "Property GridRowHeight | Improve this Doc View Source GridRowHeight Definiert die Höhe einer Zeile. Die Angabe erfolgt in Pixeln. Wenn kein Wert angegeben ist, dann berechnet der Client die Höhe der Zeile anhand der Schriftart. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? GridRowHeight { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowHorizontalLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowHorizontalLines.html",
    "title": "Property ShowHorizontalLines",
    "keywords": "Property ShowHorizontalLines | Improve this Doc View Source ShowHorizontalLines Gibt an, ob die horizontalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowHorizontalLines { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowVerticalLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.ShowVerticalLines.html",
    "title": "Property ShowVerticalLines",
    "keywords": "Property ShowVerticalLines | Improve this Doc View Source ShowVerticalLines Gibt an, ob die vertikalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowVerticalLines { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.NewRowIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.NewRowIcon.html",
    "title": "Property NewRowIcon",
    "keywords": "Property NewRowIcon | Improve this Doc View Source NewRowIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile neu hinzugefügt wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert New hat. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string NewRowIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerClick.html",
    "title": "Event OnGridCornerClick",
    "keywords": "Event OnGridCornerClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte in die linke, obere Ecke geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnGridCornerClick Returns Type Description EventHandler < FrameworkEventArgs > Examples"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnGridCornerDoubleClick.html",
    "title": "Event OnGridCornerDoubleClick",
    "keywords": "Event OnGridCornerDoubleClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte doppelt in die linke, obere Ecke geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnGridCornerDoubleClick Returns Type Description EventHandler < FrameworkEventArgs > Examples"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnCellDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnCellDoubleClick.html",
    "title": "Event OnCellDoubleClick",
    "keywords": "Event OnCellDoubleClick Tritt auf, wenn doppelt in eine Gridzelle (nicht RowHeader und nicht ColumnHeader) geklickt wurde. Das Event Argument stellt Spaltennummer ( ColNum ) und Datensatznummer ( RowID ) zur Verfügung. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCellDoubleClickEventArgs> OnCellDoubleClick Returns Type Description EventHandler < FrameworkCellDoubleClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowsReloadEntry.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowsReloadEntry.html",
    "title": "Event OnRowsReloadEntry",
    "keywords": "Event OnRowsReloadEntry Tritt auf, wenn Grid-Zeilen erstmalig an den Client übertragen werden, sowohl bei der initialien Übertragung als auch beim Nachladen von Zeilen. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnReloadEventArgs> OnRowsReloadEntry Returns Type Description EventHandler < FrameworkOnReloadEventArgs > Remarks Das Event Argument stellt zwei Listen zur Verfügung: RowList : Diese Liste enthält die Zeilennummern der betroffenen Datensätze. RowIDList : Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). Warning In diesem Event dürfen keine Daten manipuliert werden! Es eignet sich insbesondere für die Färbung oder das Deaktivieren von Gridzellen, abhängig von den dargestellten Daten."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnTableValidate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnTableValidate.html",
    "title": "Event OnTableValidate",
    "keywords": "Event OnTableValidate !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnTableValidateEventArgs> OnTableValidate Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnTableValidateEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.html",
    "title": "Class GridDesignViewModel",
    "keywords": "Class GridDesignViewModel Diese Klasse repräsentiert das Control Grid . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel GridDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class GridDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BackColor2 Bestimmt die zeilenweise alternierende Hintergrundfarbe einer Tabelle. Für den Hintergrund der Grid-Zeilen wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Grid-Zeilen die BackColor verwendet DataSource Gibt den Datasource an, dessen Daten im Grid angezeigt werden sollen. Es ist wichtig, dass Sie hier eine Collection angeben. GridColor !TODO Farbe der Tabellenteiler GridRowHeight Definiert die Höhe einer Zeile. Die Angabe erfolgt in Pixeln. Wenn kein Wert angegeben ist, dann berechnet der Client die Höhe der Zeile anhand der Schriftart. HeaderColor !TODO Gibt an, die Hintergrundfarbe der Tabellenüberschrift. IsEditable Gibt an, ob am Grid Daten geändert werden dürfen. Ist IsEditable auf False gesetzt, wirkt sichdas auf alle Columns aus – egal, was dort angegeben ist. MainMemorySortingThreshold Grids bieten grundsätzlich die Möglichkeit, die dargestellten Daten nach einer Spalte zu sortieren oder zu filtern. Dazu stehen zwei Mechanismen ( Datenbanksortierung und Hauptspeichersortierung ) zur Verfügung. Multiselect Gibt an, ob mehrere Zeilen ausgewählt werden können. Bei False kann nur maximal eine Zeile ausgewählt werden. Bei True ist die Auswahl mehrerer Zeilen möglich. Welche Zeilen ausgewählt sind, lässt sich in der SelectRowsCollection auswerten und setzen (siehe Property SelectedRows ). NewRowIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile neu hinzugefügt wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert New hat. RowChangedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile geändert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert Changed hat. RowDeletedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile zum Löschen markiert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property StateBeforeUpdate den Wert true hat. RowHeader Bestimmt, ob im Row-Header die Zeilennummer oder der Status des Rows angezeigt wird. RowHeaderWidth Höhe der Spalten. SelectedRows Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Zeilen im Grid markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. ShowHorizontalLines Gibt an, ob die horizontalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. ShowVerticalLines Gibt an, ob die vertikalen Rasterlinien in einem Grid angezeigt werden sollen oder nicht. TransferReloadRowCount Definiert, wie viele Zeilen nachgelesen werden, wenn in der Tabelle in den entsprechenden Bereich gescrollt wurde. Bei 0 werden alle Zeilen zurückgegeben. TransferStartupRowCount Definiert, wie viele Zeilen bei einem Load zunächst an den Client zurückgegeben werden. Bei 0 werden alle Zeilen zurückgegeben. Es wird nicht empfohlen, sich standardmäßig alle Zeilen zurückgeben zu lassen, da dies bei großen Datenmengen zu starker Belastung des Clients und des Webservers kommt. Es ist deshalb besser, sich zunächst einen Block zurückgeben zu lassen und bei Bedarf die Daten dynamisch nachlesen zu lassen. Events OnAppendNewRow Dieser Vorgang wird ausgelöst, wenn in der letzten Zeile im letzten editierbaren Feld die Tab-Taste gedrückt wird. OnCellDoubleClick Tritt auf, wenn doppelt in eine Gridzelle (nicht RowHeader und nicht ColumnHeader) geklickt wurde. Das Event Argument stellt Spaltennummer ( ColNum ) und Datensatznummer ( RowID ) zur Verfügung. OnColumnChanged Wird ausgelöst, wenn sich der Inhalt einer Spalte geändert hat. Sie können über das EventArg e.RowID das Objekt ermitteln, bei dem das Event aufgetreten ist. OnGridCornerClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte in die linke, obere Ecke geklickt wurde. OnGridCornerDoubleClick Tritt auf, wenn bei sichtbarer RowHeader-Spalte doppelt in die linke, obere Ecke geklickt wurde. OnRowClick Tritt auf, wenn auf die Zeile geklickt wurde. OnRowDoubleClick Tritt auf, wenn auf die Zeile doppelt geklickt wurde. OnRowSelectionChanged Tritt auf, wenn sich die Selektion im Grid ändert - auch bei Deselektion von Datensätzen. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist, wird diese durch das Event aktualisiert. OnRowsReloadEntry Tritt auf, wenn Grid-Zeilen erstmalig an den Client übertragen werden, sowohl bei der initialien Übertragung als auch beim Nachladen von Zeilen. OnTableValidate !TODO See Also GridControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle | Improve this Doc View Source EditorStyle Bei Editfield wird die Spalte als ganz normales Eingabefeld dargestellt. Bei Checkbox wird in der Spalte eine Checkbox dargestellt. Ist der Wert der Spalte true oder 1 , wird die Checkbox gesetzt. Ist der Wert false oder 0 , wird die Checkbox nicht gesetzt. Bei Combobox wird die Spalte als Combobox dargestellt. Es müssen dazu noch weitere Einstellungen bei den Properties DependsDataSourceOnRowData und List vorgenommen werden. Declaration [ControlStylesBrowsable(true)] public EditorStyle? EditorStyle { get; set; } Property Value Nullable < EditorStyle >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle | Improve this Doc View Source EditStyle !TODO Declaration [Browsable(true)] public ComboEditStyle? EditStyle { get; set; } Property Value Nullable < ComboEditStyle >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Format.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Format.html",
    "title": "Property Format",
    "keywords": "Property Format | Improve this Doc View Source Format Eingabedatentyp. Wird hier ein Format angegeben, lassen die Felder nur die Eingabe von Zeichen zu, die diesem Format entsprechen. Declaration [ControlStylesBrowsable(true)] public FrameworkFormatMask? Format { get; set; } Property Value Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern | Improve this Doc View Source FormatPattern !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string FormatPattern { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign | Improve this Doc View Source TextAlign Gibt an, wie der Text in der Column ausgerichtet werden soll (links, rechts oder zentriert). Ist DatatypeDefault angegeben, werden Zahlen und Daten rechts und Text links ausgerichtet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MinWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MinWidth.html",
    "title": "Property MinWidth",
    "keywords": "Property MinWidth | Improve this Doc View Source MinWidth Minimale Breite der Column in Pixel. Declaration [ControlStylesBrowsable(true)] [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? MinWidth { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxWidth.html",
    "title": "Property MaxWidth",
    "keywords": "Property MaxWidth | Improve this Doc View Source MaxWidth Maximale Breite der Column in Pixel. Declaration [ControlStylesBrowsable(true)] [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? MaxWidth { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxDropDownSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.MaxDropDownSize.html",
    "title": "Property MaxDropDownSize",
    "keywords": "Property MaxDropDownSize | Improve this Doc View Source MaxDropDownSize !TODO Gibt an, die maximale Höre der DropDown-Listes. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Size? MaxDropDownSize { get; set; } Property Value Nullable < Size >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Property.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Property.html",
    "title": "Property Property",
    "keywords": "Property Property | Improve this Doc View Source Property !TODO Declaration [Browsable(true)] [TypeConverter(typeof(GridColRecordsConverter))] public PropertiesRecord Property { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Component.Properties.PropertiesRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.DependsDataSourceOnRowData.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData | Improve this Doc View Source DependsDataSourceOnRowData Ist als EditorStyle Combobox ausgewählt, können Sie im Property List einen DataSource für die Liste angeben. Dieses Property gibt an, ob sich die Liste auf ein Property des Collection-Objekts beziehen soll ( True ) oder nicht ( False ). Wenn True angegeben wird, werden unter List die Properties des Collection-Objekts angeboten. In diesem Fall wird für jede Zeile des Grids eine eigene Liste erstellt. Wenn False angegeben wurde, werden in List die Membervariablen des Forms angeboten. Es wird eine Liste für alle Zeilen des Grids erstellt. Declaration public bool? DependsDataSourceOnRowData { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkBase.ExtendedShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ExtendedShortcut.html",
    "title": "Enum ExtendedShortcut",
    "keywords": "Enum ExtendedShortcut ExtendedShortcut contains the same properties as the System.Windows.Forms.Shortcut enumeration. Furthermore it is extended by: Esc = 27 Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense(true)] public enum ExtendedShortcut Fields Name Description Alt0 Alt1 Alt2 Alt3 Alt4 Alt5 Alt6 Alt7 Alt8 Alt9 AltBksp AltDownArrow AltF1 AltF10 AltF11 AltF12 AltF2 AltF3 AltF4 AltF5 AltF6 AltF7 AltF8 AltF9 AltLeftArrow AltRightArrow AltUpArrow Ctrl0 Ctrl1 Ctrl2 Ctrl3 Ctrl4 Ctrl5 Ctrl6 Ctrl7 Ctrl8 Ctrl9 CtrlA CtrlB CtrlC CtrlD CtrlDel CtrlE CtrlF CtrlF1 CtrlF10 CtrlF11 CtrlF12 CtrlF2 CtrlF3 CtrlF4 CtrlF5 CtrlF6 CtrlF7 CtrlF8 CtrlF9 CtrlG CtrlH CtrlI CtrlIns CtrlJ CtrlK CtrlL CtrlM CtrlN CtrlO CtrlP CtrlQ CtrlR CtrlS CtrlShift0 CtrlShift1 CtrlShift2 CtrlShift3 CtrlShift4 CtrlShift5 CtrlShift6 CtrlShift7 CtrlShift8 CtrlShift9 CtrlShiftA CtrlShiftB CtrlShiftC CtrlShiftD CtrlShiftE CtrlShiftF CtrlShiftF1 CtrlShiftF10 CtrlShiftF11 CtrlShiftF12 CtrlShiftF2 CtrlShiftF3 CtrlShiftF4 CtrlShiftF5 CtrlShiftF6 CtrlShiftF7 CtrlShiftF8 CtrlShiftF9 CtrlShiftG CtrlShiftH CtrlShiftI CtrlShiftJ CtrlShiftK CtrlShiftL CtrlShiftM CtrlShiftN CtrlShiftO CtrlShiftP CtrlShiftQ CtrlShiftR CtrlShiftS CtrlShiftT CtrlShiftU CtrlShiftV CtrlShiftW CtrlShiftX CtrlShiftY CtrlShiftZ CtrlT CtrlU CtrlV CtrlW CtrlX CtrlY CtrlZ Del Esc F1 F10 F11 F12 F2 F3 F4 F5 F6 F7 F8 F9 Ins None ShiftDel ShiftF1 ShiftF10 ShiftF11 ShiftF12 ShiftF2 ShiftF3 ShiftF4 ShiftF5 ShiftF6 ShiftF7 ShiftF8 ShiftF9 ShiftIns"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html",
    "title": "Method FillOnDrop",
    "keywords": "Method FillOnDrop | Improve this Doc View Source FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. Declaration public virtual void FillOnDrop() Remarks Hintergrund: Einige Datenformate bringen unter Umständen sehr große Datenmengen mit sich. Beispielsweise können Dateien sehr groß sein. Daher werden beim ersten Request des Clients ( OnCanDrop ) nur Informationen wie der Speicherort, Name, Größe usw. übertragen und nur dann, wenn der Inhalt tatsächlich im OnDrop benötigt wird (und deshalb FillOnDrop() aufgerufen wurde), werden die ggf. großen Daten ausgelesen und übertragen."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html",
    "title": "Class FlavorData",
    "keywords": "Class FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. Inheritance Object FlavorData FileListFlavorData ImageFlavorData TextFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public abstract class FlavorData Remarks Die Klasse bietet die Methode FillOnDrop() . Durch den Aufruf dieser Methode wird gesteuert, dass beim Drop-Vorgang alle Daten vollständig gefüllt werden sollen. Methods FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. See Also FileFlavorData FileListFlavorData ImageFlavorData TextFlavorData UriListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.DeferRecursiveSaves.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.DeferRecursiveSaves.html",
    "title": "Method DeferRecursiveSaves",
    "keywords": "Method DeferRecursiveSaves | Improve this Doc View Source DeferRecursiveSaves() Gibt zurück, ob alle Save-Aufrufe an dieser Instanz, die während eines laufenden Save-Aufrufs an dieser Instanz erfolgen, direkt abgebrochen werden sollen und stattdessen nach dem initialen Save-Aufruf (innerhalb der Transaktion) ein weiterer Save-Aufruf erfolgen soll. Standardmäßig gibt die Methode \"false\" zurück. Der Mechanismus kann aktiviert werden, in dem die Methode mit \"return true;\" überschrieben wird. Declaration [HideForIntellisense] [HideForOverride(false)] [GenerateNoneOverrideMethod] protected virtual bool DeferRecursiveSaves() Returns Boolean Examples protected override bool DeferRecursiveSaves() { return true; }"
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.State.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.State.html",
    "title": "Property State",
    "keywords": "Property State | Improve this Doc View Source State Siehe State in IDevFrameworkObject . Declaration public FrameworkComponentState State { get; set; } Property Value FrameworkComponentState Implements IDevFrameworkObject.State"
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html",
    "title": "Class DevFrameworkObject",
    "keywords": "Class DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. Inheritance Object FrameworkSystems.FrameworkBase.DevFrameworkBaseObject DevFrameworkObject Implements IDevFrameworkObject Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public abstract class DevFrameworkObject : DevFrameworkBaseObject, ICloneable, IFSRebind, IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, IGuidObject, IGuidObjectBase Properties State Siehe State in IDevFrameworkObject . Methods DeferRecursiveSaves() Gibt zurück, ob alle Save-Aufrufe an dieser Instanz, die während eines laufenden Save-Aufrufs an dieser Instanz erfolgen, direkt abgebrochen werden sollen und stattdessen nach dem initialen Save-Aufruf (innerhalb der Transaktion) ein weiterer Save-Aufruf erfolgen soll. Standardmäßig gibt die Methode \"false\" zurück. Der Mechanismus kann aktiviert werden, in dem die Methode mit \"return true;\" überschrieben wird."
  },
  "api/FrameworkSystems.FrameworkBase.CameraSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.CameraSource.html",
    "title": "Enum CameraSource",
    "keywords": "Enum CameraSource Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum CameraSource Fields Name Description CAMERA Öffnet auf dem Endgerät die Kamera zum erstellen eines neuen Fotos GALLERY Öffnet auf dem Endgerät die Bildergalerie zur Auswahl eines Fotos"
  },
  "api/FrameworkSystems.FrameworkBase.TextEditorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.TextEditorType.html",
    "title": "Enum TextEditorType",
    "keywords": "Enum TextEditorType Used for example by the Editbox control to specify the kind of text to be handled by the control. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum TextEditorType Fields Name Description HTML Der über den Datasource bereit gestellte Inhalt wird als Html interpretiert. Note Diese Einstellung ist nur bei mehrzeiligen Editfields möglich (Multiline=true). PlainText Es soll unformatierter Text dargestellt werden."
  },
  "api/FrameworkSystems.FrameworkBase.StackPanelVAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StackPanelVAlignment.html",
    "title": "Enum StackPanelVAlignment",
    "keywords": "Enum StackPanelVAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum StackPanelVAlignment Fields Name Description Bottom Center Top"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.HasValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue | Improve this Doc View Source HasValue Declaration public bool HasValue { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.IsNone.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.IsNone.html",
    "title": "Property IsNone",
    "keywords": "Property IsNone | Improve this Doc View Source IsNone Declaration public bool IsNone { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.Value.html",
    "title": "Property Value",
    "keywords": "Property Value | Improve this Doc View Source Value Declaration public T Value { get; } Property Value T"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.Nonable-1.html",
    "title": "Struct Nonable<T>",
    "keywords": "Struct Nonable<T> Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax public struct Nonable<T> : Nonable.INonable where T : struct Type Parameters Name Description T Properties HasValue IsNone Value"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html",
    "title": "Struct FSdecimal",
    "keywords": "Struct FSdecimal TODO! Summary description for FSdecimal. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdecimal : IFSdecimal, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html",
    "title": "Property Size",
    "keywords": "Property Size | Improve this Doc View Source Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Declaration public long Size { get; protected set; } Property Value Int64"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html",
    "title": "Property Type",
    "keywords": "Property Type | Improve this Doc View Source Type Gibt den Typ der Datei zurück. Declaration public FileFlavorData.FileType Type { get; protected set; } Property Value FileFlavorData.FileType Remarks Mögliche Werte sind : File : Datei Directory : Verzeichnis"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html",
    "title": "Field BROKER_TAG",
    "keywords": "Field BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string BROKER_TAG = \"fsbroker://\" Returns Type Description String Remarks Ressourcen mit fsbroker://RelativerPfad werden von dem Browser ausgewertet und durch den absoluten Pfad ersetzt."
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html",
    "title": "Method CreateCommand",
    "keywords": "Method CreateCommand | Improve this Doc View Source CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, IDictionary<string, string> args = null) Parameters commandName String args IDictionary < String , String > Returns String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: //Command-Args erstellen Dictionary<string, string> linkCommandArgs = new Dictionary<string, string>(); linkCommandArgs.Add(\"Key1\", \"1235\"); linkCommandArgs.Add(\"Key2\", \"Test\"); linkCommandArgs.Add(\"Key3\", \"Test 1234\"); // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", linkCommandArgs); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\"; | Improve this Doc View Source CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, params KeyValuePair<string, string>[] args) Parameters commandName String args KeyValuePair < String , String >[] Returns String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die einzelnen Argumente können mit der Methode CreateArgument(String, Object) erzeugt werden, um die Konvertierung verschiedener Typen korrekt vorzunehmen. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", new KeyValuePair<string, string>(\"Key1\", \"Wert1\"), BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html",
    "title": "Method CreateArgument",
    "keywords": "Method CreateArgument | Improve this Doc View Source CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. Declaration public static KeyValuePair<string, string> CreateArgument(string key, object value) Parameters key String value Object Returns KeyValuePair < String , String > Remarks So können z.B. die FS-Datentypen wie in dem nachfolgenden Beispiel als Wert übergeben werden: string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); Die FrameworkOnLinkClickEventArgs bieten Methoden GetArgument -Methoden (z.B. GetArgumentFSlong ) um mit dem richtigen Schlüssel einen Wert im entsprechenden FSTyp wieder auszulesen. Auslesen der Argumente im Browser-Event OnLinkClick : if (e.IsCommand && e.Command == \"TestCommand\") { FSlong lngDocumentID = e.GetArgumentFSlong(\"Belegnummer\"); FSstring sDocumentType = e.GetArgumentFSstring(\"Belegart\"); FSDateTime dtDate = e.GetArgumentFSDateTime(\"Datum\"); }"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html",
    "title": "Method TryParseCommand",
    "keywords": "Method TryParseCommand | Improve this Doc View Source TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben. Declaration public static bool TryParseCommand(string url, out string commandName, out Dictionary<string, string> args) Parameters url String commandName String args Dictionary < String , String > Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html",
    "title": "Method CreateRessourcesUrl",
    "keywords": "Method CreateRessourcesUrl | Improve this Doc View Source CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. Declaration public static string CreateRessourcesUrl(string relativePath) Parameters relativePath String Returns String Remarks Diese Url kann dann, wie im nachfolgendem Beispiel, in Verbindung mit HTML z.B. als Link zu einer Datei verwendet warden: // Link zu einer CSS-Datei sStyle = \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + BrowserCommand.CreateRessourcesUrl(\"test.css\") + \"\\\" />\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.html",
    "title": "Class BrowserCommand",
    "keywords": "Class BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. Inheritance Object BrowserCommand Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class BrowserCommand Fields BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Methods CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html",
    "title": "Struct FSdouble",
    "keywords": "Struct FSdouble TODO! Summary description for FSdouble. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdouble : IFSdouble, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewSelectorPosition.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewSelectorPosition.html",
    "title": "Enum ListViewSelectorPosition",
    "keywords": "Enum ListViewSelectorPosition Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewSelectorPosition Fields Name Description BottomLeft BottomRight MiddleLeft MiddleRight TopLeft TopRight"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.HasError.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError | Improve this Doc View Source HasError true wenn beim Vorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Declaration bool HasError { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ErrorMessage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage | Improve this Doc View Source ErrorMessage Fehlermeldung bei einem gescheiterten Vorgang Declaration string ErrorMessage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBase64.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBase64.html",
    "title": "Property ImageBase64",
    "keywords": "Property ImageBase64 | Improve this Doc View Source ImageBase64 Das Bild im JPG-Format encodiert als Base64-String Declaration string ImageBase64 { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBytes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.ImageBytes.html",
    "title": "Property ImageBytes",
    "keywords": "Property ImageBytes | Improve this Doc View Source ImageBytes Das Bild im JPG-Format als Byte-Array Declaration byte[] ImageBytes { get; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.Identifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier | Improve this Doc View Source Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource,System.String) übergebene Wert, sonst null . Declaration string Identifier { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkPhotoInfo.html",
    "title": "Interface IFrameworkPhotoInfo",
    "keywords": "Interface IFrameworkPhotoInfo Eine Instanz dieses Typs wird nach einem mit der Action TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet die Bilddaten des neuen oder ausgewählten Bildes und Zusatzinformationen. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkPhotoInfo Properties ErrorMessage Fehlermeldung bei einem gescheiterten Vorgang HasError true wenn beim Vorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto(System.Action{FrameworkSystems.FrameworkBase.IFrameworPhotoInfo},FrameworkSystems.FrameworkBase.CameraSource,System.String) übergebene Wert, sonst null . ImageBase64 Das Bild im JPG-Format encodiert als Base64-String ImageBytes Das Bild im JPG-Format als Byte-Array"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html",
    "title": "Method CloseApplication",
    "keywords": "Method CloseApplication | Improve this Doc View Source CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. Declaration void CloseApplication() Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. | Improve this Doc View Source CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. Declaration void CloseApplication(FrameworkCloseMode closeMode) Parameters closeMode FrameworkCloseMode Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. | Improve this Doc View Source CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. Declaration void CloseApplication(string message) Parameters message String Die Meldung die am Client angezeigt werden soll. Wird String.Empty übergeben, wird die Anwendung ohne Meldung beendet. Wird null übergeben, verhält sich die Methode wie die parameterlose CloseApplication() . Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html",
    "title": "Property AUHelper",
    "keywords": "Property AUHelper | Improve this Doc View Source AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. Declaration AUHelper AUHelper { get; } Property Value AUHelper"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ocGlobal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ocGlobal.html",
    "title": "Property ocGlobal",
    "keywords": "Property ocGlobal | Improve this Doc View Source ocGlobal Declaration IcGlobalBase ocGlobal { get; } Property Value IcGlobalBase"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html",
    "title": "Property SelectedLanguage",
    "keywords": "Property SelectedLanguage | Improve this Doc View Source SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Declaration string SelectedLanguage { get; set; } Property Value String Remarks Beim Setzen der SelectedLanguage gibt es 2 Möglichkeiten: 1.) Es wird nur ein ISO-Code übergeben.Dieser wird an die erste Stelle der LanguageHierarchy gesetzt. Wenn dieser Code schon in der Hierarchie enthalten ist, dann wird dieser an die erste Stelle verschoben. 2.) Es wird eine Komma-separierte Liste von ISO-Codes übergeben.In diesem Fall wird aus dieser Liste eine neue LanguageHierarchy aufgebaut. Die Sprache wird beim Start im Client festgelegt. Der Broker wechselt beim Start der Anwendung ggf. auf die Default-Sprache der Anwendung, wenn die vom Client angefragte Sprache nicht zur Verfügung steht. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.MLColumnLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.MLColumnLanguage.html",
    "title": "Property MLColumnLanguage",
    "keywords": "Property MLColumnLanguage | Improve this Doc View Source MLColumnLanguage Gibt den Iso-Code der Sprache zurück, die aktuell für die MLColumn-Properties verwendet wird. Normalerweise handelt es sich dabei um die SelectedLanguage . Mit der Methode UseMLColumnLanguage(String, Action) kann die Sprache vorrübergebend geändert werden. Declaration string MLColumnLanguage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClientInfos.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClientInfos.html",
    "title": "Property ClientInfos",
    "keywords": "Property ClientInfos | Improve this Doc View Source ClientInfos In diesem Dictionary sind Informationen abgelegt, die der Client beim Start der Anwendung an den Broker übertragen hat. Declaration Dictionary<string, string> ClientInfos { get; } Property Value Dictionary < String , String >"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLText.html",
    "title": "Method GetMLText",
    "keywords": "Method GetMLText | Improve this Doc View Source GetMLText(MLKey) Ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. Declaration string GetMLText(MLKey mlkey) Parameters mlkey MLKey Returns String Examples FSstring sArticleLabel = this.Global.GetMLText( MLKeys.LBL_Article ); | Improve this Doc View Source GetMLText(MLKey, String) Diese Methode ermittelt für den übergebenen MLKey den Text für die übergebene Sprache. Es erfolgt kein Fallback auf eine andere Sprache. Declaration string GetMLText(MLKey mlkey, string iso) Parameters mlkey MLKey iso String Iso-Code der Sprache. Returns String Examples FSString sAmountEn = this.Global.GetMLText( MLKeys.LBL_Amount, \"en\" );"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLText.html",
    "title": "Method FormatMLText",
    "keywords": "Method FormatMLText | Improve this Doc View Source FormatMLText(MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. Declaration string FormatMLText(MLKey mlkey, params object[] args) Parameters mlkey MLKey MLKey aus dem Wörterbuch args Object [] Returns String Formatierter Text Examples FSstring sFormattedText = this.Global.FormatMLText( MLKeys.LBL_MitFormat, \"Text1\", lngAmount ); See Also GetClientCulture() | Improve this Doc View Source FormatMLText(IFormatProvider, MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Arumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. Declaration string FormatMLText(IFormatProvider culture, MLKey mlkey, params object[] args) Parameters culture IFormatProvider Die zu verwendende Culture. Bei null erfolgt ein Fallback auf die Client-Culture mlkey MLKey MLKey aus dem Wörterbuch args Object [] Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLKeyText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetMLKeyText.html",
    "title": "Method GetMLKeyText",
    "keywords": "Method GetMLKeyText | Improve this Doc View Source GetMLKeyText(MLKey) Diese Methode gibt ein MLKeyText -Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. Declaration MLKeyText GetMLKeyText(MLKey mlkey) Parameters mlkey MLKey Returns MLKeyText Examples Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please select only one article. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_1b6b9bea43304e2082d1162d75d9e317), 0);"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLKeyText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.FormatMLKeyText.html",
    "title": "Method FormatMLKeyText",
    "keywords": "Method FormatMLKeyText | Improve this Doc View Source FormatMLKeyText(MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. Declaration MLKeyText FormatMLKeyText(MLKey mlkey, params object[] args) Parameters mlkey MLKey MLKey aus dem Wörterbuch. args Object [] Returns MLKeyText Examples Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please specify {0} throw new FrameworkApplicationException(this.Global.FormatMLKeyText(MLKeys.MSG_24979a3d247546318dc673c5501d3b15, this.sName), 0); See Also GetClientCulture() | Improve this Doc View Source FormatMLKeyText(IFormatProvider, MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. Declaration MLKeyText FormatMLKeyText(IFormatProvider culture, MLKey mlkey, params object[] args) Parameters culture IFormatProvider Die zu verwendende Culture. Bei null erfolgt ein Fallback auf die Client-Culture mlkey MLKey MLKey aus dem Wörterbuch. args Object [] Returns MLKeyText"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.UseMLColumnLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.UseMLColumnLanguage.html",
    "title": "Method UseMLColumnLanguage",
    "keywords": "Method UseMLColumnLanguage | Improve this Doc View Source UseMLColumnLanguage(String, Action) Verwendet für MLColumn-Properties während der übergenenen Action die angegebene Sprache. Declaration void UseMLColumnLanguage(string iso, Action action) Parameters iso String action Action"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html",
    "title": "Method CreateComponent",
    "keywords": "Method CreateComponent | Improve this Doc View Source CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. Declaration object CreateComponent(string componentName) Parameters componentName String Returns Object Remarks Das zurückgegebene Objekt muss ggf. in einen anderen Typ umgewandelt werden, damit eine Weiterverarbeitung möglich ist. DevFrameworkObject oObject = this.Global.CreateComponent(\"Namespace.cdComponent\") as DevFrameworkObject; DevFrameworkObjectColl oColl = this.Global.CreateComponent(\"Namespace.cdComponentColl\") as DevFrameworkObjectColl; Der ComponentName entspricht dem FullName des Typs. Dieser kann auch zur Laufzeit ermittelt werden. sComponentName = oComponent.GetType().FullName; Warning Da der übergebene Parameter nicht kompiliert ist, sollte diese Funktion nur in Ausnahmefällen eingesetzt werden, um z.B. verallgemeinerte Logik umzusetzen."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html",
    "title": "Method GetCodeDirectory",
    "keywords": "Method GetCodeDirectory | Improve this Doc View Source GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. Declaration string GetCodeDirectory() Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html",
    "title": "Property LanguageHierarchy",
    "keywords": "Property LanguageHierarchy | Improve this Doc View Source LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. Declaration IEnumerable<string> LanguageHierarchy { get; set; } Property Value IEnumerable < String > Remarks Beim Setzen kann jeder Typ zugewiesen werden, der von IEnumerable<string> erbt. Es ist jedoch empfehlenswert, mit einer ReadOnlyCollection<string> zu arbeiten, um Manipulationen an dieser Liste zu verhindern. Diese kann zum Beispiel mit der Methode Liste<string>.AsReadOnly() erzeugt werden. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClearDynamicDragSources.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.ClearDynamicDragSources.html",
    "title": "Method ClearDynamicDragSources",
    "keywords": "Method ClearDynamicDragSources | Improve this Doc View Source ClearDynamicDragSources() Declaration void ClearDynamicDragSources()"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SetDynamicDragSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SetDynamicDragSource.html",
    "title": "Method SetDynamicDragSource",
    "keywords": "Method SetDynamicDragSource | Improve this Doc View Source SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, Object>) Declaration void SetDynamicDragSource(MLContainer mdt, Func<IDevFrameworkBaseObject, object> getterDelegate) Parameters mdt MLContainer getterDelegate Func < FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject , Object >"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.RemoveDynamicDragSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.RemoveDynamicDragSource.html",
    "title": "Method RemoveDynamicDragSource",
    "keywords": "Method RemoveDynamicDragSource | Improve this Doc View Source RemoveDynamicDragSource(MLContainer) Declaration bool RemoveDynamicDragSource(MLContainer mdt) Parameters mdt MLContainer Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html",
    "title": "Property SafeInitializing",
    "keywords": "Property SafeInitializing | Improve this Doc View Source SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. Declaration bool SafeInitializing { get; } Property Value Boolean Remarks Der Modus kann mithilfe der Methode EndSafeInitialize() zurückgesetzt werden. Wenn diese Methode einmal aufgerufen wurde, dann ist es nicht mehr möglich, den Modus wieder zu aktivieren. Wenn dieser Modus aktiv ist, dann können z.B. in einer Update-Sitation Exceptions unterbunden werden, die den Start der Anwendung verhindern würden. Examples try { [Aktion] } catch (Exception ex) { if (this.Global.SafeInitializing) { [Fehler behandeln] } else { // Exception weiter werfen. throw; } }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html",
    "title": "Field AssemblyPrefix",
    "keywords": "Field AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string AssemblyPrefix Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html",
    "title": "Field Name",
    "keywords": "Field Name Der Name des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Name Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html",
    "title": "Field Version",
    "keywords": "Field Version Die Version des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Version Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html",
    "title": "Field ProductName",
    "keywords": "Field ProductName Der an der Package-Version definierte Product Name. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string ProductName Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html",
    "title": "Field Manufacturer",
    "keywords": "Field Manufacturer Der im Package definierte Hersteller. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Manufacturer Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html",
    "title": "Field PublicKey",
    "keywords": "Field PublicKey Der öffenliche Schlüssel des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly RSAKeyPair PublicKey Returns Type Description FrameworkSystems.FrameworkBase.License.RSAKeyPair"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html",
    "title": "Field LastCompileDate",
    "keywords": "Field LastCompileDate Zeitpunkt des letzten Compiles. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly DateTime LastCompileDate Returns Type Description DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html",
    "title": "Field WasLastCompileBugFix",
    "keywords": "Field WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly bool WasLastCompileBugFix Returns Type Description Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html",
    "title": "Class AUHelper.PackageInfo",
    "keywords": "Class AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden. Inheritance Object AUHelper.PackageInfo Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class PackageInfo Remarks Warning Die Klasse darf nicht im eigenen Code instanziiert werden. Fields AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. ID Die eindeutige ID des Packages. LastCompileDate Zeitpunkt des letzten Compiles. Manufacturer Der im Package definierte Hersteller. Name Der Name des Packages. ProductName Der an der Package-Version definierte Product Name. PublicKey Der öffenliche Schlüssel des Packages. Version Die Version des Packages. WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer Classes ControlTreeNode"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Classes BrowserDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel Diese Klasse repräsentiert das Control Button . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. CheckBoxDesignViewModel Diese Klasse repräsentiert das Control CheckBox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ComboboxDesignViewModel Diese Klasse repräsentiert das Control Combobox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ContainerDesignViewModel TODO ContextMenuDesignViewModel Diese Klasse repräsentiert das Control ContextMenu . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ControlDesignViewModel TODO DashBoardContainerViewModel Diese Klasse repräsentiert das Control DashboardContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. DockPanelDesignViewModel EditboxDesignViewModel Diese Klasse repräsentiert das Control EditField . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. FieldPanelDesignViewModel FieldRowDesignViewModel FormContainerDesignViewModel Diese Klasse repräsentiert das Control FormContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. GridColDesignViewModel Diese Klasse repräsentiert das Control Grid-Column . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. GridDesignViewModel Diese Klasse repräsentiert das Control Grid . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ImageButtonDesignViewModel Diese Klasse repräsentiert das Control ImageButton . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. LabelDesignViewModel Diese Klasse repräsentiert das Control Label . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ListBaseDesignViewModel ListboxDesignViewModel Diese Klasse repräsentiert das Control Listbox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. ListViewDesignViewModel Diese Klasse repräsentiert das Control ListView . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. MainMenuDesignViewModel Diese Klasse repräsentiert das Control Menu-Item . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. PictureDesignViewModel Diese Klasse repräsentiert das Control Picture . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. RadioButtonDesignViewModel TabbedWindowDesignViewModel TabPageDesignViewModel TemplateControlDesignViewModel Diese Klasse repräsentiert das Control TemplateControl . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. TreeNodeDesignViewModel TreeViewDesignViewModel WrapPanelDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html",
    "title": "Constructor RowVersionInvalidException",
    "keywords": "Constructor RowVersionInvalidException | Improve this Doc View Source RowVersionInvalidException(String) Declaration public RowVersionInvalidException(string caption) Parameters caption String | Improve this Doc View Source RowVersionInvalidException(String, Exception) Declaration public RowVersionInvalidException(string caption, Exception ex) Parameters caption String ex Exception"
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html",
    "title": "Class RowVersionInvalidException",
    "keywords": "Class RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Inheritance Object Exception FrameworkSystems.FrameworkExceptions.FrameworkException RowVersionInvalidException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class RowVersionInvalidException : FrameworkException, ISerializable, _Exception Constructors RowVersionInvalidException(String) RowVersionInvalidException(String, Exception)"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.html",
    "title": "Namespace FrameworkSystems.FrameworkExceptions.MultiLanguage",
    "keywords": "Namespace FrameworkSystems.FrameworkExceptions.MultiLanguage Classes MLKey Diese Klasse verpackt einen MLKey. Der MLKey besteht aus einem String-Wert. MLKeyText Diese Klasse verpackt einen MLKey und den lokalisierten Text. So ist es möglich mit dem Text auch den MLKey zu transportieren. In der FrameworkApplicationException kann so der MLKey als \"Fehlercode\" verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.SelectedRowsCollection.html": {
    "href": "api/FrameworkSystems.FrameworkBase.SelectedRowsCollection.html",
    "title": "Class SelectedRowsCollection",
    "keywords": "Class SelectedRowsCollection !TODO Inheritance Object SelectedRowsCollection Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class SelectedRowsCollection : IList<guid>, ICollection<guid>, IEnumerable<guid>, IEnumerable, ICloneable"
  },
  "api/FrameworkSystems.FrameworkBase.SaveEntryPoints.html": {
    "href": "api/FrameworkSystems.FrameworkBase.SaveEntryPoints.html",
    "title": "Enum SaveEntryPoints",
    "keywords": "Enum SaveEntryPoints Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum SaveEntryPoints Fields Name Description CallAllways CallOnlyIfChanged"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnDrag.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnDrag.html",
    "title": "Event OnDrag",
    "keywords": "Event OnDrag Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnDrag Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.html",
    "title": "Class MainMenuDesignViewModel",
    "keywords": "Class MainMenuDesignViewModel Diese Klasse repräsentiert das Control Menu-Item . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel MainMenuDesignViewModel ContextMenuDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class MainMenuDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Hinterlegen Sie hier mehrsprachig die Bezeichnung, die für den Menüeintrag angezeigt werden soll. Soll ein Und-Zeichen(&) dargestellt werden, müssen zwei Und-Zeichen(&&) angegeben werden. Ist auf dem Label ein Datasource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der DataSource hat dann höhere Priorität. Checked Ist ein Property hinterlegt, welches als boolescher Wert ausgewertet werden kann (bool, FSbool , FSshort ,…), so wird vor der Bezeichnung des Menüeintrags ein Haken dargestellt, wenn das hinterlegte Property den Wert true repräsentiert. DataSource Ist ein Datasource hinterlegt, wird die Caption wie bei einem Label durch den Inhalt überschrieben. Image Gibt das Bild an, das vor der Bezeichnung des Menüeintrags angezeigt werden soll. Die URL kann einen zum Applikations-Verzeichnis relativen Pfad oder einen absoluten Pfad darstellen. Über die Drop-Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Ist die Eigenschaft Checked ebenfalls zugewiesen, so wird die Darstellung des Checked-Status durch das Image übersteuert. Shortcut Zur Anwahl des Menüeintrags über einen ShortCut, wird einfach die entsprechende Tastenkombination aus der Combobox ausgewählt. Events OnCanDrop Dieses Event wird nicht unterstützt. OnClick Wird bei einem Klick auf das Control ausgelöst. OnDrag Dieses Event wird nicht unterstützt. OnEnter Dieses Event wird nicht unterstützt. OnLeave Dieses Event wird nicht unterstützt. See Also MainMenuControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectionMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectionMode.html",
    "title": "Property SelectionMode",
    "keywords": "Property SelectionMode | Improve this Doc View Source SelectionMode Gibt an, ob und wie ListItems in einer ListView selektiert werden können. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewSelectionMode? SelectionMode { get; set; } Property Value Nullable < ListViewSelectionMode >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectorPosition.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectorPosition.html",
    "title": "Property SelectorPosition",
    "keywords": "Property SelectorPosition | Improve this Doc View Source SelectorPosition Der Selector ist ein kleines Häkchen, welches am ListItem anzeigt, ob es selektiert ist oder nicht. Abhängig vom individuellen Design des ListItems kann definiert werden, an welcher Stelle der Selector über dem ListItem angezeigt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewSelectorPosition? SelectorPosition { get; set; } Property Value Nullable < ListViewSelectorPosition > Remarks Das folgende Bild zeigt die möglichen Positionen:"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemArrangement.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemArrangement.html",
    "title": "Property ItemArrangement",
    "keywords": "Property ItemArrangement | Improve this Doc View Source ItemArrangement Definiert die Anordnung der ListItems abhängig von der Größe der ListView. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListViewItemArrangement? ItemArrangement { get; set; } Property Value Nullable < ListViewItemArrangement > Remarks Es stehen zwei Optionen zur Verfügung: List Die ListItems werden untereinander angeordnet. Dabei werden diese horizontal auf die gesamte Breite der ListView gestreckt. Die unter ItemSize . Width eingegebene Breite gilt als Mindestbreite. Die Höhe ( ItemSize . Height ) ist fix. Wrap Die ListItems werden abhängig von der ItemSize . Width und der Breite der ListView umgebrochen. Es werden pro Zeile so viele ListItems wie möglich angezeigt. Die ItemSize . Width gibt dabei die Mindestbreite eines ListItems an. Die Höhe ( ItemSize . Height ) ist fix. Die ListItems werden gleichmäßig gestreckt, um die gesamte Breite der ListView auszunutzen."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectedItems.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.SelectedItems.html",
    "title": "Property SelectedItems",
    "keywords": "Property SelectedItems | Improve this Doc View Source SelectedItems Membervariable oder Property, welches die selektierten ListItems beinhaltet. Muss von Typ SelectedRowsCollection sein. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedItems { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Spacing.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Spacing.html",
    "title": "Property Spacing",
    "keywords": "Property Spacing | Improve this Doc View Source Spacing Gibt den horizontalen und vertikalen Abstang zwischen den ListItems an. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ControlSpacing Spacing { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlSpacing"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.ItemSize.html",
    "title": "Property ItemSize",
    "keywords": "Property ItemSize | Improve this Doc View Source ItemSize Gibt die Größe eines ListItems an. Hierbei gilt die Width als Mindestbreite. Abhängig vom ItemArrangement werden ListItems gestreckt, um den vorhandenen Platz optimal auszunutzen. Die angegebene Height wird im Gegensatz zur Width nicht an die Größe der ListView angepasst und bleibt stabil. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize ItemSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Template.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.Template.html",
    "title": "Property Template",
    "keywords": "Property Template | Improve this Doc View Source Template Öffnet den ListView Template Editor . Declaration [Browsable(true)] public object Template { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Membervariable oder Property, welches an die ListView gebunden werden soll. Muss vom Typ FrameworkSystems.FrameworkBase.IDevFrameworkObjectColl sein. Bildet auch die Datengrundlage für das ListItem Template . Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemActivated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemActivated.html",
    "title": "Event OnItemActivated",
    "keywords": "Event OnItemActivated Dieses Event wird gefeuert, wenn ein ListItem angeklickt oder auf einem mobilen Gerät mit dem Finger angetippt wird. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnItemActivatedEventArgs> OnItemActivated Returns Type Description EventHandler < FrameworkOnItemActivatedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.OnItemSelectionChanged.html",
    "title": "Event OnItemSelectionChanged",
    "keywords": "Event OnItemSelectionChanged Dieses Event wird gefeuert, wenn sich die Anzahl der selektierten ListItems ändert. Die derzeit selektierten ListItems können über das an der ListView gebundene Property SelectedItems ausgelesen werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkSelectionChangedEventArgs> OnItemSelectionChanged Returns Type Description EventHandler < FrameworkSelectionChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListViewDesignViewModel.html",
    "title": "Class ListViewDesignViewModel",
    "keywords": "Class ListViewDesignViewModel Diese Klasse repräsentiert das Control ListView . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ListViewDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ListViewDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties DataSource Membervariable oder Property, welches an die ListView gebunden werden soll. Muss vom Typ FrameworkSystems.FrameworkBase.IDevFrameworkObjectColl sein. Bildet auch die Datengrundlage für das ListItem Template . ItemArrangement Definiert die Anordnung der ListItems abhängig von der Größe der ListView. ItemSize Gibt die Größe eines ListItems an. Hierbei gilt die Width als Mindestbreite. Abhängig vom ItemArrangement werden ListItems gestreckt, um den vorhandenen Platz optimal auszunutzen. Die angegebene Height wird im Gegensatz zur Width nicht an die Größe der ListView angepasst und bleibt stabil. SelectedItems Membervariable oder Property, welches die selektierten ListItems beinhaltet. Muss von Typ SelectedRowsCollection sein. SelectionMode Gibt an, ob und wie ListItems in einer ListView selektiert werden können. SelectorPosition Der Selector ist ein kleines Häkchen, welches am ListItem anzeigt, ob es selektiert ist oder nicht. Abhängig vom individuellen Design des ListItems kann definiert werden, an welcher Stelle der Selector über dem ListItem angezeigt wird. Spacing Gibt den horizontalen und vertikalen Abstang zwischen den ListItems an. Template Öffnet den ListView Template Editor . Events OnItemActivated Dieses Event wird gefeuert, wenn ein ListItem angeklickt oder auf einem mobilen Gerät mit dem Finger angetippt wird. OnItemSelectionChanged Dieses Event wird gefeuert, wenn sich die Anzahl der selektierten ListItems ändert. Die derzeit selektierten ListItems können über das an der ListView gebundene Property SelectedItems ausgelesen werden. See Also ListViewControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Gibt die Beschriftung des Buttons in den definierten Sprachen an. Siehe auch Caption in ControlDesignViewModel Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MapEnterToTabAction.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.MapEnterToTabAction.html",
    "title": "Property MapEnterToTabAction",
    "keywords": "Property MapEnterToTabAction | Improve this Doc View Source MapEnterToTabAction !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? MapEnterToTabAction { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut | Improve this Doc View Source Shortcut Legt ein Tastenkürzel(Tastenkombination) für den schnellen Zugriff auf den Button fest.Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, so wird das OnClick-Event des Buttons ausgelöst. Inherited(Bei der Auswahl dieses Wertes wird die Einstellung gelöscht und der Wert aus der Basis-Klasse oder den Default Control Styles gezogen) None(keine zugeordnet) Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.List.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.List.html",
    "title": "Property List",
    "keywords": "Property List | Improve this Doc View Source List Macht nur Sinn, wenn als EditorStyle Combobox ausgewählt ist. Gibt den Datasource an, aus welchem die Daten für die Liste gezogen werden sollen (analog zur Combobox ). Declaration [DevBrowsable(true)] [TypeConverter(typeof(DataBindingConverter))] public ListDataSource List { get; set; } Property Value ListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Name.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Name.html",
    "title": "Property Name",
    "keywords": "Property Name | Improve this Doc View Source Name Zeigt den Namen der Column an. Der Name wird generiert und kann nicht geändert werden. Er setzt sich zusammen aus der Bezeichnung des Grids und des Property-Namen, der die Spalte repräsentiert, verbunden durch einen Unterstrich _ . Heißt das Grid grdCustomer würde die Column lngCustomerID z.B. grdCustomer_lngCustomerID heißen. ( schreibgeschützt ) Declaration public override string Name { get; set; } Property Value String Overrides ControlTreeNode.Name"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Gibt das Label der Spalte in den definierten Sprachen an. Die Caption wird über das Property ermittelt und kann überschrieben werden. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnCellValidate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnCellValidate.html",
    "title": "Event OnCellValidate",
    "keywords": "Event OnCellValidate !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnCellValidateEventArgs> OnCellValidate Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnCellValidateEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStarting.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStarting.html",
    "title": "Event OnEditingStarting",
    "keywords": "Event OnEditingStarting Dieses Ereignis wird ausgelöst, sobald eine Zelle vom Nutzer bearbeitet wird. Bei der Verarbeitung dieses Events dürfen keine Dialoge geöffnet werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCellCancelEventArgs> OnEditingStarting Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellCancelEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStopped.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.OnEditingStopped.html",
    "title": "Event OnEditingStopped",
    "keywords": "Event OnEditingStopped Dieses Ereignis ist das Gegenstück zu OnEditingStarting. Es tritt auf, wenn der Benutzer die Bearbeitung einer Zelle beendet. Auch hier sollten keine Dialoge geöffnet werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCellEventArgs> OnEditingStopped Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridColDesignViewModel.html",
    "title": "Class GridColDesignViewModel",
    "keywords": "Class GridColDesignViewModel Diese Klasse repräsentiert das Control Grid-Column . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel GridColDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class GridColDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Gibt das Label der Spalte in den definierten Sprachen an. Die Caption wird über das Property ermittelt und kann überschrieben werden. DependsDataSourceOnRowData Ist als EditorStyle Combobox ausgewählt, können Sie im Property List einen DataSource für die Liste angeben. Dieses Property gibt an, ob sich die Liste auf ein Property des Collection-Objekts beziehen soll ( True ) oder nicht ( False ). Wenn True angegeben wird, werden unter List die Properties des Collection-Objekts angeboten. In diesem Fall wird für jede Zeile des Grids eine eigene Liste erstellt. Wenn False angegeben wurde, werden in List die Membervariablen des Forms angeboten. Es wird eine Liste für alle Zeilen des Grids erstellt. EditorStyle Bei Editfield wird die Spalte als ganz normales Eingabefeld dargestellt. Bei Checkbox wird in der Spalte eine Checkbox dargestellt. Ist der Wert der Spalte true oder 1 , wird die Checkbox gesetzt. Ist der Wert false oder 0 , wird die Checkbox nicht gesetzt. Bei Combobox wird die Spalte als Combobox dargestellt. Es müssen dazu noch weitere Einstellungen bei den Properties DependsDataSourceOnRowData und List vorgenommen werden. EditStyle !TODO Format Eingabedatentyp. Wird hier ein Format angegeben, lassen die Felder nur die Eingabe von Zeichen zu, die diesem Format entsprechen. FormatPattern !TODO List Macht nur Sinn, wenn als EditorStyle Combobox ausgewählt ist. Gibt den Datasource an, aus welchem die Daten für die Liste gezogen werden sollen (analog zur Combobox ). MaxDropDownSize !TODO Gibt an, die maximale Höre der DropDown-Listes. MaxWidth Maximale Breite der Column in Pixel. MinWidth Minimale Breite der Column in Pixel. Name Zeigt den Namen der Column an. Der Name wird generiert und kann nicht geändert werden. Er setzt sich zusammen aus der Bezeichnung des Grids und des Property-Namen, der die Spalte repräsentiert, verbunden durch einen Unterstrich _ . Heißt das Grid grdCustomer würde die Column lngCustomerID z.B. grdCustomer_lngCustomerID heißen. ( schreibgeschützt ) Property !TODO TextAlign Gibt an, wie der Text in der Column ausgerichtet werden soll (links, rechts oder zentriert). Ist DatatypeDefault angegeben, werden Zahlen und Daten rechts und Text links ausgerichtet. Events OnCellValidate !TODO OnEditingStarting Dieses Ereignis wird ausgelöst, sobald eine Zelle vom Nutzer bearbeitet wird. Bei der Verarbeitung dieses Events dürfen keine Dialoge geöffnet werden. OnEditingStopped Dieses Ereignis ist das Gegenstück zu OnEditingStarting. Es tritt auf, wenn der Benutzer die Bearbeitung einer Zelle beendet. Auch hier sollten keine Dialoge geöffnet werden. See Also GridColumnControlAction"
  },
  "api/FrameworkSystems.FrameworkBase.FieldRowLabelMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FieldRowLabelMode.html",
    "title": "Enum FieldRowLabelMode",
    "keywords": "Enum FieldRowLabelMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FieldRowLabelMode Fields Name Description Generated Generated_Merged None None_Aligned Das erste Control wird in die Label-Spalte platziert. None_Fill"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html",
    "title": "Field Image",
    "keywords": "Field Image Stellt ein Bild dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string Image = \"image/x-java-image\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html",
    "title": "Field FileList",
    "keywords": "Field FileList Stellt Dateien dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string FileList = \"application/x-java-file-list\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html",
    "title": "Field TextXml",
    "keywords": "Field TextXml Stellt Text im XML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextXml = \"text/xml\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html",
    "title": "Field TextHtml",
    "keywords": "Field TextHtml Stellt Text im HTML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextHtml = \"text/html\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html",
    "title": "Field TextRtf",
    "keywords": "Field TextRtf Stellt Text im RTF-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextRtf = \"text/rtf\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html",
    "title": "Field TextUriList",
    "keywords": "Field TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextUriList = \"text/uri-list\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html",
    "title": "Field TextPlain",
    "keywords": "Field TextPlain Stellt unformatierten Text dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextPlain = \"text/plain\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html",
    "title": "Method IsTextFlavor",
    "keywords": "Method IsTextFlavor | Improve this Doc View Source IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist. Declaration public static bool IsTextFlavor(string flavorType) Parameters flavorType String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.html": {
    "href": "api/FrameworkSystems.FrameworkControls.html",
    "title": "Namespace FrameworkSystems.FrameworkControls",
    "keywords": "Namespace FrameworkSystems.FrameworkControls Classes ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). GeneratedForm Basisklasse eines vom FrameworkStudio generierten Formulars. An dieser Klasse werden die Actions auf Form-Ebene angeboten. GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Enums GridColumnDefinition.ColumnSortOrder GridColumnDefinition.ColumnTextAlign"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html",
    "title": "Constructor GridColumnDefinition",
    "keywords": "Constructor GridColumnDefinition | Improve this Doc View Source GridColumnDefinition() Declaration public GridColumnDefinition()"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html",
    "title": "Property Property",
    "keywords": "Property Property | Improve this Doc View Source Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Declaration public string Property { get; set; } Property Value String Examples Werden im Grid Elemente vom Typ cDynObj angezeigt, so bedeutet Property=\"oDevObj.sName\" , dass die Spalte Daten des Propertys sName des Unterobjekts oDevObj an cDynObj darstellt."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html",
    "title": "Property PropertyMdt",
    "keywords": "Property PropertyMdt | Improve this Doc View Source PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer PropertyMdt { get; set; } Property Value MLContainer Remarks Wenn die Eigenschaft ComponentType nicht gesetzt werden muss, muss diese Eigenschaft ebenfalls nicht gesetzt werden. Die Werte können dann automatisch über Reflection ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle | Improve this Doc View Source EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. Declaration public EditorStyle? EditorStyle { get; set; } Property Value Nullable < EditorStyle >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle | Improve this Doc View Source EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Declaration public ComboEditStyle? EditStyle { get; set; } Property Value Nullable < ComboEditStyle >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html",
    "title": "Property Format",
    "keywords": "Property Format | Improve this Doc View Source Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public FrameworkFormatMask? Format { get; set; } Property Value Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern | Improve this Doc View Source FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public string FormatPattern { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize | Improve this Doc View Source MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxSize { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html",
    "title": "Property MaxScale",
    "keywords": "Property MaxScale | Improve this Doc View Source MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxScale { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable | Improve this Doc View Source IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsEditable { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible | Improve this Doc View Source IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign | Improve this Doc View Source TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. Declaration public GridColumnDefinition.ColumnTextAlign? TextAlign { get; set; } Property Value Nullable < GridColumnDefinition.ColumnTextAlign >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html",
    "title": "Property Width",
    "keywords": "Property Width | Improve this Doc View Source Width Gibt die initiale Spaltenbreite zurück oder legt diese fest. Declaration public int? Width { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. Declaration public string Caption { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption | Improve this Doc View Source MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. Declaration public DevMLString MLCaption { get; set; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html",
    "title": "Property ToolTip",
    "keywords": "Property ToolTip | Improve this Doc View Source ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Declaration public string ToolTip { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html",
    "title": "Property MLToolTip",
    "keywords": "Property MLToolTip | Improve this Doc View Source MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Declaration public DevMLString MLToolTip { get; set; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData | Improve this Doc View Source DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. Declaration public bool? DependsDataSourceOnRowData { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html",
    "title": "Property List",
    "keywords": "Property List | Improve this Doc View Source List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. Declaration public ColumnListDataSource List { get; set; } Property Value ColumnListDataSource"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder | Improve this Doc View Source ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. Declaration public GridColumnDefinition.ColumnSortOrder ListSortOrder { get; set; } Property Value GridColumnDefinition.ColumnSortOrder"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html",
    "title": "Property ComponentType",
    "keywords": "Property ComponentType | Improve this Doc View Source ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. Declaration public Type ComponentType { get; set; } Property Value Type"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html",
    "title": "Class GridColumnDefinition",
    "keywords": "Class GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Inheritance Object GridColumnDefinition Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class GridColumnDefinition Constructors GridColumnDefinition() Properties Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Width Gibt die initiale Spaltenbreite zurück oder legt diese fest."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ListBoxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ListBoxControlAction.html",
    "title": "Class ListBoxControlAction",
    "keywords": "Class ListBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Listbox angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ListBoxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ListBoxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ListboxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.LabelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.LabelControlAction.html",
    "title": "Class LabelControlAction",
    "keywords": "Class LabelControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Label angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction LabelControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class LabelControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable See Also LabelDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ButtonControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ButtonControlAction.html",
    "title": "Class ButtonControlAction",
    "keywords": "Class ButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Button angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction ImageButtonControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ButtonControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also ButtonDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.ReloadPage.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.ReloadPage.html",
    "title": "Method ReloadPage",
    "keywords": "Method ReloadPage | Improve this Doc View Source ReloadPage() Aktuelle Seite erneut laden. Declaration public virtual void ReloadPage()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.GenerateSnapshot.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.GenerateSnapshot.html",
    "title": "Method GenerateSnapshot",
    "keywords": "Method GenerateSnapshot | Improve this Doc View Source GenerateSnapshot() Erstellt einen Snapshot von der aktuellen Ansicht des Browser-Fensters. Declaration public virtual void GenerateSnapshot()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.CancelLoading.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.CancelLoading.html",
    "title": "Method CancelLoading",
    "keywords": "Method CancelLoading | Improve this Doc View Source CancelLoading() Sends an action to the client, which cancels the loading of the current page. Declaration public virtual void CancelLoading()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.SetZoomFactor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.SetZoomFactor.html",
    "title": "Method SetZoomFactor",
    "keywords": "Method SetZoomFactor | Improve this Doc View Source SetZoomFactor(Double) Setzt den Zoom-Faktor für den Content des Browser-Controls. Ein Wert von 1.0 entspricht 100%. Dieser bezieht sich auf die im Client eingestellte Skalierung. Bei 100% wird die Skalierung verwendet. Der maximale Zoomfaktor liegt bei 2.5 und der minimale Zoomfaktor bei 0.5. Declaration public virtual void SetZoomFactor(double zoomfactor) Parameters zoomfactor Double"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.BrowserControlAction.html",
    "title": "Class BrowserControlAction",
    "keywords": "Class BrowserControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction BrowserControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class BrowserControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Methods CancelLoading() Sends an action to the client, which cancels the loading of the current page. GenerateSnapshot() Erstellt einen Snapshot von der aktuellen Ansicht des Browser-Fensters. ReloadPage() Aktuelle Seite erneut laden. SetZoomFactor(Double) Setzt den Zoom-Faktor für den Content des Browser-Controls. Ein Wert von 1.0 entspricht 100%. Dieser bezieht sich auf die im Client eingestellte Skalierung. Bei 100% wird die Skalierung verwendet. Der maximale Zoomfaktor liegt bei 2.5 und der minimale Zoomfaktor bei 0.5."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetKey.html",
    "title": "Method GetKey",
    "keywords": "Method GetKey | Improve this Doc View Source GetKey() Liefert den zugeordneten MLKey. Ist kein MLKey zgeordnet, dann wird null zurückgegeben. Declaration public MLKey GetKey() Returns MLKey"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.HasKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.HasKey.html",
    "title": "Property HasKey",
    "keywords": "Property HasKey | Improve this Doc View Source HasKey Gibt zurück, ob dem DevMLString ein MLKey zugeordnet ist. Declaration public bool HasKey { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetString.html",
    "title": "Method GetString",
    "keywords": "Method GetString | Improve this Doc View Source GetString(IGlobalObjects, String) Ermittelt den Text in der übergebenen Sprache. Ist für diese Sprache kein Text vorhaden, wird string.Empty zurügkgegeben. Es erfolgt kein Fallback auf die Default-Sprache.. Declaration public string GetString(IGlobalObjects global, string iso) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global iso String Der 2-stellige Sprach-Iso-Code - z.B. \"en\" Returns String Der gefundene Text oder string.Empty | Improve this Doc View Source GetString(IGlobalObjects, IEnumerable<String>) Ermittelt den Text für die übergebene Sprach-Hierarchie. Dabei wird für jede Sprache eine Ermittlung wie in GetString(IGlobalObjects, String) vorgenommen und der erste gefundene Text zurückgegeben. Es erfolgt kein Fallback auf die Default-Sprache. Declaration public string GetString(IGlobalObjects global, IEnumerable<string> languageHierarchy) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global languageHierarchy IEnumerable < String > Enumeration mit 2-Selligen Sprach-Iso-Codes. Returns String Der gefundene Text oder string.Empty | Improve this Doc View Source GetString(IGlobalObjects) Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. Declaration public string GetString(IGlobalObjects global) Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global Returns String Der gefundene Text oder string.Empty"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.Item.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.Item.html",
    "title": "Property Item",
    "keywords": "Property Item | Improve this Doc View Source Item[IGlobalObjects] Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. Declaration public string this[IGlobalObjects global] { get; } Parameters global IGlobalObjects Das GlobalObject - z.B. this.Global Property Value String Der gefundene Text oder string.Empty"
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html",
    "title": "Class DevMLString",
    "keywords": "Class DevMLString Diese Klasse beschreibt einen mehrsprachigen String. Darüber können die in den Designern und im Wörterbuch gesetzten Texte zur Laufzeit ermittelt werden. Inheritance Object DevMLString DevMLStringWithGlobal Namespace : FrameworkSystems.FrameworkBase.MultiLanguage Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevMLString Properties HasKey Gibt zurück, ob dem DevMLString ein MLKey zugeordnet ist. Item[IGlobalObjects] Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. Methods GetKey() Liefert den zugeordneten MLKey. Ist kein MLKey zgeordnet, dann wird null zurückgegeben. GetString(IGlobalObjects) Ermittelt den Text mit der Sprach-Hierarchie des übergebenen GlobalObjects (siehe LanguageHierarchy ). Diese beinhaltet immer einen Fallback auf die Default-Sprache. GetString(IGlobalObjects, IEnumerable<String>) Ermittelt den Text für die übergebene Sprach-Hierarchie. Dabei wird für jede Sprache eine Ermittlung wie in GetString(IGlobalObjects, String) vorgenommen und der erste gefundene Text zurückgegeben. Es erfolgt kein Fallback auf die Default-Sprache. GetString(IGlobalObjects, String) Ermittelt den Text in der übergebenen Sprache. Ist für diese Sprache kein Text vorhaden, wird string.Empty zurügkgegeben. Es erfolgt kein Fallback auf die Default-Sprache.."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Metadatatype",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Metadatatype Classes MLContainer TODO! Structs FSbool Summary description for FSbool. FSbyte TODO! Summary description for FSbyte. FSbyteArray TODO! Summary description for FSbyteArray. FSDateTime TODO! Summary description for FSDateTime. FSdecimal TODO! Summary description for FSdecimal. FSdouble TODO! Summary description for FSdouble. FSfloat TODO! Summary description for FSfloat. FSint TODO! Summary description for FSint. FSlong TODO! Summary description for FSlong. FSshort TODO! Summary description for FSshort. FSstring TODO! Summary description for FSstring. FSSystemGuid TODO! Summary description for FSSystemGuid. Nonable<T> Interfaces IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung."
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.ScanBarcode.html",
    "title": "Method ScanBarcode",
    "keywords": "Method ScanBarcode | Improve this Doc View Source ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Declaration public void ScanBarcode(Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat) Parameters callback Action < IFrameworkBarcodeScanInfo > Die Methode, die nach dem Scan-Vorgang aufgerufen werden soll. allowedFormat BarcodeFormat Ein oder mehrere zulässige Formate. Umso qualifizierter das Format eingschränkt wird, desto geringer ist die Anfälligkeit für Fehler. Mit ALL sind alle bekannten Formate zulässig. Remarks Siehe Barcode | Improve this Doc View Source ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Diese Überladung bietet zusätzlich einen Identifier. Declaration public void ScanBarcode(Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat, string identifier) Parameters callback Action < IFrameworkBarcodeScanInfo > Die Methode, die nach dem Scan-Vorgang aufgerufen werden soll. allowedFormat BarcodeFormat Ein oder mehrere zulässige Formate. Umso qualifizierter das Format eingschränkt wird, desto geringer ist die Anfälligkeit für Fehler. Mit ALL sind alle bekannten Formate zulässig. identifier String Dieser string wird in IFrameworkBarcodeScanInfo dem Callback übergeben. Wird dieselbe Callback-Methode für verschiedene Scan-Aufrufe in einem Form verwendet, dann können diese mithlife des Identifiers auseinandergehalten werden. Remarks Siehe Barcode"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.TakePhoto.html",
    "title": "Method TakePhoto",
    "keywords": "Method TakePhoto | Improve this Doc View Source TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet. Declaration public void TakePhoto(Action<IFrameworkPhotoInfo> callback, CameraSource source) Parameters callback Action < IFrameworkPhotoInfo > Die Methode, die nach dem Vorgang aufgerufen werden soll. source CameraSource Bestimmt, ob ein neues Foto mit der Kamera erstellt oder ein bestehendes Foto von der Bildergalerie ausgewählt werden soll. Remarks Siehe Kamera"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation.html",
    "title": "Method GetGeoLocation",
    "keywords": "Method GetGeoLocation | Improve this Doc View Source GetGeoLocation(Action<IFrameworkGeoLocationInfo>) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. Declaration public void GetGeoLocation(Action<IFrameworkGeoLocationInfo> callback) Parameters callback Action < IFrameworkGeoLocationInfo > Die Methode, die nach dem Vorgang aufgerufen werden soll. Remarks Siehe Standortbestimmung | Improve this Doc View Source GetGeoLocation(Action<IFrameworkGeoLocationInfo>, String) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. Declaration public void GetGeoLocation(Action<IFrameworkGeoLocationInfo> callback, string identifier) Parameters callback Action < IFrameworkGeoLocationInfo > Die Methode, die nach dem Vorgang aufgerufen werden soll. identifier String Dieser string wird in IFrameworkGeoLocationInfo dem Callback übergeben. Wird dieselbe Callback-Methode für verschiedene Standortbestimmungen in einem Form verwendet, dann können diese mithlife des Identifiers auseinandergehalten werden. Remarks Siehe Standortbestimmung"
  },
  "api/FrameworkSystems.FrameworkControls.GeneratedForm.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GeneratedForm.html",
    "title": "Class GeneratedForm",
    "keywords": "Class GeneratedForm Basisklasse eines vom FrameworkStudio generierten Formulars. An dieser Klasse werden die Actions auf Form-Ebene angeboten. Inheritance Object GeneratedForm Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public abstract class GeneratedForm : IGeneratedForm, IDisposable Methods GetGeoLocation(Action<IFrameworkGeoLocationInfo>) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. GetGeoLocation(Action<IFrameworkGeoLocationInfo>, String) Über diese Action wird im Mobile-Client der aktuelle Standort bestimmt. ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) Über diese Action wird im Mobile-Client ein Scan-Vorgang eingeleitet. Diese Überladung bietet zusätzlich einen Identifier. TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) Über diese Action wird im Mobile-Client ein das erstellen eines Fotos auf dem Endgerät eingeleitet."
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html",
    "title": "Constructor ColumnListDataSource",
    "keywords": "Constructor ColumnListDataSource | Improve this Doc View Source ColumnListDataSource() Declaration public ColumnListDataSource()"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. Declaration public string DataSource { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry | Improve this Doc View Source ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. Declaration public bool? ContainsNullEntry { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember | Improve this Doc View Source DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string DisplayMember { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember | Improve this Doc View Source ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string ValueMember { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html",
    "title": "Property DisplayMdt",
    "keywords": "Property DisplayMdt | Improve this Doc View Source DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer DisplayMdt { get; set; } Property Value MLContainer"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html",
    "title": "Class ColumnListDataSource",
    "keywords": "Class ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). Inheritance Object ColumnListDataSource Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class ColumnListDataSource Constructors ColumnListDataSource() Properties ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCell.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCell.html",
    "title": "Method SetCell",
    "keywords": "Method SetCell | Improve this Doc View Source SetCell(guid) Setzt den Fokus auf ein Feld. Declaration public virtual void SetCell(guid rowID) Parameters rowID guid Gibt die GUID des Objekts an"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellEditable.html",
    "title": "Method SetCellEditable",
    "keywords": "Method SetCellEditable | Improve this Doc View Source SetCellEditable(guid, Boolean) Setzt ein Feld nicht editierbar. Declaration public virtual void SetCellEditable(guid rowID, bool isEditable) Parameters rowID guid Gibt die GUID des Objekts an isEditable Boolean Gibt an, ob das Feld editierbar ist"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellForeColor.html",
    "title": "Method SetCellForeColor",
    "keywords": "Method SetCellForeColor | Improve this Doc View Source SetCellForeColor(guid, Nullable<Color>) !TODO Declaration public virtual void SetCellForeColor(guid rowID, Color? color) Parameters rowID guid color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.SetCellBackColor.html",
    "title": "Method SetCellBackColor",
    "keywords": "Method SetCellBackColor | Improve this Doc View Source SetCellBackColor(guid, Nullable<Color>) !TODO Declaration public virtual void SetCellBackColor(guid rowID, Color? color) Parameters rowID guid color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridColumnControlAction.html",
    "title": "Class GridColumnControlAction",
    "keywords": "Class GridColumnControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid-Column angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction GridColumnControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class GridColumnControlAction : EditableControlAction, ISerializable, IGridColumnControlAction, IFrameworkControlActionBase Methods SetCell(guid) Setzt den Fokus auf ein Feld. SetCellBackColor(guid, Nullable<Color>) !TODO SetCellEditable(guid, Boolean) Setzt ein Feld nicht editierbar. SetCellForeColor(guid, Nullable<Color>) !TODO See Also GridColDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.SetVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.SetVisible.html",
    "title": "Method SetVisible",
    "keywords": "Method SetVisible | Improve this Doc View Source SetVisible(Boolean) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet. Declaration public virtual void SetVisible(bool value) Parameters value Boolean | Improve this Doc View Source SetVisible(Nullable<FSVisibility>) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet. Declaration public virtual void SetVisible(FSVisibility? value) Parameters value Nullable < FSVisibility >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.HidePermanent.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.HidePermanent.html",
    "title": "Method HidePermanent",
    "keywords": "Method HidePermanent | Improve this Doc View Source HidePermanent() !TODO Declaration public virtual void HidePermanent()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlActionBase.html",
    "title": "Class FrameworkControlActionBase",
    "keywords": "Class FrameworkControlActionBase Actions, die so ziemlich jedes Control besitzt. Inheritance Object FrameworkControlActionBase FieldRowControlAction FrameworkControlAction Implements IFrameworkControlActionBase Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class FrameworkControlActionBase : IFrameworkControlActionBase, ISerializable Methods HidePermanent() !TODO SetVisible(Boolean) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet. SetVisible(Nullable<FSVisibility>) Mit dieser Action kann ein Control zur Laufzeit ein- oder ausgeblendet werden. Ist IsVisible true , wird das Control eingeblendet und bei false ausgeblendet."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html",
    "title": "Struct FSshort",
    "keywords": "Struct FSshort TODO! Summary description for FSshort. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSshort : IFSshort, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html",
    "title": "Struct FSlong",
    "keywords": "Struct FSlong TODO! Summary description for FSlong. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSlong : IFSlong, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html",
    "title": "Struct FSbyte",
    "keywords": "Struct FSbyte TODO! Summary description for FSbyte. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyte : IFSbyte, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListSortOrder.html",
    "title": "Enum ListSortOrder",
    "keywords": "Enum ListSortOrder Sortierar Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListSortOrder Fields Name Description Ascending Aufsteigend Descending Absteigend Inherit Erbt von Vater-Control Unsorted Unsortiert"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness | Improve this Doc View Source BorderThickness Dieses Property weicht zu den allgemeinen Properties ab. Die Border wird, wie beim TabbedWindow, um die Tab-Pages des Dash-Boards gezeichnet. (Siehe BorderThickness ) Declaration public override Bounds BorderThickness { get; set; } Property Value Bounds Overrides ControlDesignViewModel.BorderThickness"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.Columns.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.Columns.html",
    "title": "Property Columns",
    "keywords": "Property Columns | Improve this Doc View Source Columns !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? Columns { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderColor.html",
    "title": "Property ItemBorderColor",
    "keywords": "Property ItemBorderColor | Improve this Doc View Source ItemBorderColor Gibt die Farbe des Rahmens um die Dash-Items an. Diese Eigenschaft kann im Default-Control-Style theme-spezifisch angegeben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Color ItemBorderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderMargin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderMargin.html",
    "title": "Property ItemBorderMargin",
    "keywords": "Property ItemBorderMargin | Improve this Doc View Source ItemBorderMargin Gibt die Dicke des (transparenten) Randes für jedes Dash-Item an. Dieser wird außerhalb des colorierten Rahmen angezeigt. Der Standard-Wert ist 2 . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemBorderMargin { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemBorderThickness.html",
    "title": "Property ItemBorderThickness",
    "keywords": "Property ItemBorderThickness | Improve this Doc View Source ItemBorderThickness Gibt die Dicke des farbigen Rahmens um jedes Dash-Item an. Zum Ausblenden des Rahmens kann der Wert 0 angegeben werden. Der Standard-Wert ist 3 . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemBorderThickness { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemGap.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ItemGap.html",
    "title": "Property ItemGap",
    "keywords": "Property ItemGap | Improve this Doc View Source ItemGap Gibt den horizontalen und vertikalen Abstand zwischen den Dash-Items an. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . Standard-Wert und bisheriges Verhalten ist 0 Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? ItemGap { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentBackColor.html",
    "title": "Property ContentBackColor",
    "keywords": "Property ContentBackColor | Improve this Doc View Source ContentBackColor Die Hintergrund-Farbe in den Tab-Pages des Dash-Boards. Das Property BackColor hingegen zieht außerhalb der Tab-Pages - u.a. in dem Bereich um die Registerkarte-Karten. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Color ContentBackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentPadding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.ContentPadding.html",
    "title": "Property ContentPadding",
    "keywords": "Property ContentPadding | Improve this Doc View Source ContentPadding Der Abstand der Dash-Items zum Rand der Tab-Page. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds ContentPadding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateActive.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateActive.html",
    "title": "Property TabTemplateActive",
    "keywords": "Property TabTemplateActive | Improve this Doc View Source TabTemplateActive Hier werden die Layout-Einstellungen der aktiven Registerkarte vorgenommen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TabTemplate TabTemplateActive { get; } Property Value TabTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateInactive.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TabTemplateInactive.html",
    "title": "Property TabTemplateInactive",
    "keywords": "Property TabTemplateInactive | Improve this Doc View Source TabTemplateInactive Hier werden die Layout-Einstellungen der inaktiven Registerkarte vorgenommen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TabTemplate TabTemplateInactive { get; } Property Value TabTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddPage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddPage.html",
    "title": "Property TooltipAddPage",
    "keywords": "Property TooltipAddPage | Improve this Doc View Source TooltipAddPage !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipAddPage { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipClosePage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipClosePage.html",
    "title": "Property TooltipClosePage",
    "keywords": "Property TooltipClosePage | Improve this Doc View Source TooltipClosePage !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipClosePage { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddColumn.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipAddColumn.html",
    "title": "Property TooltipAddColumn",
    "keywords": "Property TooltipAddColumn | Improve this Doc View Source TooltipAddColumn !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipAddColumn { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRemoveColumn.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRemoveColumn.html",
    "title": "Property TooltipRemoveColumn",
    "keywords": "Property TooltipRemoveColumn | Improve this Doc View Source TooltipRemoveColumn !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipRemoveColumn { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCollapseDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCollapseDashItem.html",
    "title": "Property TooltipCollapseDashItem",
    "keywords": "Property TooltipCollapseDashItem | Improve this Doc View Source TooltipCollapseDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipCollapseDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipExpandDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipExpandDashItem.html",
    "title": "Property TooltipExpandDashItem",
    "keywords": "Property TooltipExpandDashItem | Improve this Doc View Source TooltipExpandDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipExpandDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCloseDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipCloseDashItem.html",
    "title": "Property TooltipCloseDashItem",
    "keywords": "Property TooltipCloseDashItem | Improve this Doc View Source TooltipCloseDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipCloseDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMoveDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMoveDashItem.html",
    "title": "Property TooltipMoveDashItem",
    "keywords": "Property TooltipMoveDashItem | Improve this Doc View Source TooltipMoveDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipMoveDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMaximzeDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipMaximzeDashItem.html",
    "title": "Property TooltipMaximzeDashItem",
    "keywords": "Property TooltipMaximzeDashItem | Improve this Doc View Source TooltipMaximzeDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipMaximzeDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRestoreDashItem.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.TooltipRestoreDashItem.html",
    "title": "Property TooltipRestoreDashItem",
    "keywords": "Property TooltipRestoreDashItem | Improve this Doc View Source TooltipRestoreDashItem !TODO Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString TooltipRestoreDashItem { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.OnLayoutChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.OnLayoutChanged.html",
    "title": "Event OnLayoutChanged",
    "keywords": "Event OnLayoutChanged !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnLayoutChanged Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DashBoardContainerViewModel.html",
    "title": "Class DashBoardContainerViewModel",
    "keywords": "Class DashBoardContainerViewModel Diese Klasse repräsentiert das Control DashboardContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel DashBoardContainerViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class DashBoardContainerViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BorderThickness Dieses Property weicht zu den allgemeinen Properties ab. Die Border wird, wie beim TabbedWindow, um die Tab-Pages des Dash-Boards gezeichnet. (Siehe BorderThickness ) Columns !TODO ContentBackColor Die Hintergrund-Farbe in den Tab-Pages des Dash-Boards. Das Property BackColor hingegen zieht außerhalb der Tab-Pages - u.a. in dem Bereich um die Registerkarte-Karten. ContentPadding Der Abstand der Dash-Items zum Rand der Tab-Page. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . ItemBorderColor Gibt die Farbe des Rahmens um die Dash-Items an. Diese Eigenschaft kann im Default-Control-Style theme-spezifisch angegeben werden. ItemBorderMargin Gibt die Dicke des (transparenten) Randes für jedes Dash-Item an. Dieser wird außerhalb des colorierten Rahmen angezeigt. Der Standard-Wert ist 2 . ItemBorderThickness Gibt die Dicke des farbigen Rahmens um jedes Dash-Item an. Zum Ausblenden des Rahmens kann der Wert 0 angegeben werden. Der Standard-Wert ist 3 . ItemGap Gibt den horizontalen und vertikalen Abstand zwischen den Dash-Items an. Dieser Abstand versteht sich zuzüglich zum ItemBorderMargin . Standard-Wert und bisheriges Verhalten ist 0 TabTemplateActive Hier werden die Layout-Einstellungen der aktiven Registerkarte vorgenommen. TabTemplateInactive Hier werden die Layout-Einstellungen der inaktiven Registerkarte vorgenommen. TooltipAddColumn !TODO TooltipAddPage !TODO TooltipCloseDashItem !TODO TooltipClosePage !TODO TooltipCollapseDashItem !TODO TooltipExpandDashItem !TODO TooltipMaximzeDashItem !TODO TooltipMoveDashItem !TODO TooltipRemoveColumn !TODO TooltipRestoreDashItem !TODO Events OnLayoutChanged !TODO See Also DashboardContainerControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.IsVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible | Improve this Doc View Source IsVisible Declaration [Browsable(true)] [ControlStylesBrowsable(false)] public bool? IsVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplate.html",
    "title": "Class ControlLabelTemplate",
    "keywords": "Class ControlLabelTemplate TODO ControlLabelTemplate Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase ControlLabelTemplateBase ControlLabelTemplate Inherited Members ControlLabelTemplateBase.BackColor ControlLabelTemplateBase.ForeColor ControlLabelTemplateBase.Font ControlLabelTemplateBase.TextAlign ControlLabelTemplateBase.Padding ControlLabelTemplateBase.Margin ControlLabelTemplateBase.MinSize ControlLabelTemplateBase.MaxSize Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ControlLabelTemplate : ControlLabelTemplateBase, INotifyPropertyChanged, IFsXmlSerializable Properties IsVisible"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Family.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Family.html",
    "title": "Property Family",
    "keywords": "Property Family | Improve this Doc View Source Family Declaration [TypeConverter(typeof(FontFamilyConverter))] public string Family { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Size.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Size.html",
    "title": "Property Size",
    "keywords": "Property Size | Improve this Doc View Source Size Declaration public int? Size { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Bold.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Bold.html",
    "title": "Property Bold",
    "keywords": "Property Bold | Improve this Doc View Source Bold Declaration public bool? Bold { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Italic.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Italic.html",
    "title": "Property Italic",
    "keywords": "Property Italic | Improve this Doc View Source Italic Declaration public bool? Italic { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Underline.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.Underline.html",
    "title": "Property Underline",
    "keywords": "Property Underline | Improve this Doc View Source Underline Declaration public bool? Underline { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlFont.html",
    "title": "Class ControlFont",
    "keywords": "Class ControlFont Inheritance Object ControlFont Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(ControlFontTypeConverter))] public class ControlFont Properties Bold Family Italic Size Underline"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColNum.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColNum.html",
    "title": "Property ColNum",
    "keywords": "Property ColNum | Improve this Doc View Source ColNum !TODO Declaration public int ColNum { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColumnName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.ColumnName.html",
    "title": "Property ColumnName",
    "keywords": "Property ColumnName | Improve this Doc View Source ColumnName !TODO Declaration public string ColumnName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCellDoubleClickEventArgs.html",
    "title": "Class FrameworkCellDoubleClickEventArgs",
    "keywords": "Class FrameworkCellDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnCellDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID zugreifen des Parameters der Methode zugreifen. Inheritance Object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs FrameworkColumnChangedEventArgs Inherited Members FrameworkDoubleClickEventArgs.RowID FrameworkDoubleClickEventArgs.RowIndex Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkCellDoubleClickEventArgs : FrameworkDoubleClickEventArgs Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties ColNum !TODO ColumnName !TODO"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkButtonClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkButtonClickEventArgs.html",
    "title": "Class FrameworkButtonClickEventArgs",
    "keywords": "Class FrameworkButtonClickEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkButtonClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkButtonClickEventArgs : FrameworkEventArgs"
  },
  "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.html": {
    "href": "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.html",
    "title": "Namespace FrameworkSystems.FrameworkDataProvider.BaseObjects",
    "keywords": "Namespace FrameworkSystems.FrameworkDataProvider.BaseObjects Classes guid GUID als ID für ein BaseObject. Entspricht der .NET-Guid-Klasse, mit dem Unterschied, daß die GUID nicht auf 16 Byte beschränkt ist."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage Classes DevMLString Diese Klasse beschreibt einen mehrsprachigen String. Darüber können die in den Designern und im Wörterbuch gesetzten Texte zur Laufzeit ermittelt werden. DevMLStringWithGlobal Eine Spezialisierung von DevMLString , die in in den TextCollection-Einträgen ( IDevFrameworkObjectMLString ) verwendet wird. Über den Eintrag besitzt diese Instanz das GlobalObject ( this.Global )."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.FieldRowSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.FieldRowSize.html",
    "title": "Property FieldRowSize",
    "keywords": "Property FieldRowSize | Improve this Doc View Source FieldRowSize Wird das FieldPanel vertikal gestretched, dann kann über die FieldRowSize das Verhältnis angegeben warden, mit dem sich die einzelnen FieldRows vergrößern sollen. Bei der Angabe von None wird die FieldRow mit ihrer minimalen Höhe dargestellt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] public Nonable<int>? FieldRowSize { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.html",
    "title": "Class FieldRowDesignViewModel",
    "keywords": "Class FieldRowDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FieldRowDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class FieldRowDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties FieldRowSize Wird das FieldPanel vertikal gestretched, dann kann über die FieldRowSize das Verhältnis angegeben warden, mit dem sich die einzelnen FieldRows vergrößern sollen. Bei der Angabe von None wird die FieldRow mit ihrer minimalen Höhe dargestellt. LabelMode Über die Eigenschaft LabelMode können Sie einstellen, wie für die Controls die Labels generiert werden sollen. OptimizeGeneratedLabels Über diese Eigenschaft können von mehreren Labels redundante Worte zusammengefasst werden. Diese Einstelllung funktioniert sowohl im LabelMode Generated als auch GeneratedMerged ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.Name.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.Name.html",
    "title": "Property Name",
    "keywords": "Property Name | Improve this Doc View Source Name Gibt den Namen des Controls an. Über diesen Namen kann in den Form-Methoden auf das Control zugegriffen werden.Einige Controls bieten die Möglichkeit, dynamisch Properties zu verändern.In einer Form-Methode kann so z.B. this.btnCalculate.SetVisible(false); aufgerufen werden, um ein Control auszublenden. Wird für ein Control ein Name vergeben, sollte dieser gut überlegt sein, damit er nicht mehr nachträglich geändert werden muss.Denn werden dem Control Events zugeordnet, orientiert sich deren Name am Namen des Controls. Beispiel: wird für einen Button btnStart eine Form- Methode hinterlegt, bekommt Sie den Namen FE_btnStart_OnClick( ) . Declaration [Browsable(true)] public virtual string Name { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.html",
    "title": "Class ControlTreeNode",
    "keywords": "Class ControlTreeNode Inheritance Object ControlTreeNode ControlDesignViewModel Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ControlTreeNode : INotifyPropertyChanged, IDisposable, INamedRecord Properties Name Gibt den Namen des Controls an. Über diesen Namen kann in den Form-Methoden auf das Control zugegriffen werden.Einige Controls bieten die Möglichkeit, dynamisch Properties zu verändern.In einer Form-Methode kann so z.B. this.btnCalculate.SetVisible(false); aufgerufen werden, um ein Control auszublenden. Wird für ein Control ein Name vergeben, sollte dieser gut überlegt sein, damit er nicht mehr nachträglich geändert werden muss.Denn werden dem Control Events zugeordnet, orientiert sich deren Name am Namen des Controls. Beispiel: wird für einen Button btnStart eine Form- Methode hinterlegt, bekommt Sie den Namen FE_btnStart_OnClick( ) ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Classes Alignment<H, V> BorderRadius Bounds TODO ControlFont ControlLabelTemplate TODO ControlLabelTemplate ControlLabelTemplateBase NonableSize RowLabelTemplate TabTemplate TODO"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.OnLeaveActivator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.OnLeaveActivator.html",
    "title": "Enum OnLeaveActivator",
    "keywords": "Enum OnLeaveActivator Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum OnLeaveActivator Fields Name Description Action OnLeaveActivator.Action Durch eine Action wie z.B. setFocus() KeyboardDown KeyboardEnter Drücken der Enter-Taste KeyboardF2 Drücken von F2 KeyboardTabBackward Drücken von Shift+Tab KeyboardTabForward Drücken der Tab-Taste KeyboardUp Mouse Mit der Maus wurde in ein anderes Control geklickt. Undefined"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkSelectionChangedEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkSelectionChangedEventArgs.html",
    "title": "Class FrameworkSelectionChangedEventArgs",
    "keywords": "Class FrameworkSelectionChangedEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkSelectionChangedEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkSelectionChangedEventArgs : FrameworkEventArgs"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Checked.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Checked.html",
    "title": "Property Checked",
    "keywords": "Property Checked | Improve this Doc View Source Checked Ist ein Property hinterlegt, welches als boolescher Wert ausgewertet werden kann (bool, FSbool , FSshort ,…), so wird vor der Bezeichnung des Menüeintrags ein Haken dargestellt, wenn das hinterlegte Property den Wert true repräsentiert. Declaration [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Checked { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Remarks Warning Wenn die Eigenschaft Image gesetzt ist, übersteuert diese die Checked Darstellung."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut | Improve this Doc View Source Shortcut Zur Anwahl des Menüeintrags über einen ShortCut, wird einfach die entsprechende Tastenkombination aus der Combobox ausgewählt. Declaration [Browsable(true)] [DevBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image | Improve this Doc View Source Image Gibt das Bild an, das vor der Bezeichnung des Menüeintrags angezeigt werden soll. Die URL kann einen zum Applikations-Verzeichnis relativen Pfad oder einen absoluten Pfad darstellen. Über die Drop-Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Ist die Eigenschaft Checked ebenfalls zugewiesen, so wird die Darstellung des Checked-Status durch das Image übersteuert. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Ist ein Datasource hinterlegt, wird die Caption wie bei einem Label durch den Inhalt überschrieben. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Hinterlegen Sie hier mehrsprachig die Bezeichnung, die für den Menüeintrag angezeigt werden soll. Soll ein Und-Zeichen(&) dargestellt werden, müssen zwei Und-Zeichen(&&) angegeben werden. Ist auf dem Label ein Datasource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der DataSource hat dann höhere Priorität. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Klick auf das Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnEnter.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnEnter.html",
    "title": "Event OnEnter",
    "keywords": "Event OnEnter Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnEnter Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnLeave.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnLeave.html",
    "title": "Event OnLeave",
    "keywords": "Event OnLeave Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnLeave Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnCanDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.MainMenuDesignViewModel.OnCanDrop.html",
    "title": "Event OnCanDrop",
    "keywords": "Event OnCanDrop Dieses Event wird nicht unterstützt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnCanDrop Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowChangedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowChangedIcon.html",
    "title": "Property RowChangedIcon",
    "keywords": "Property RowChangedIcon | Improve this Doc View Source RowChangedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile geändert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property State den Wert Changed hat. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string RowChangedIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowDeletedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowDeletedIcon.html",
    "title": "Property RowDeletedIcon",
    "keywords": "Property RowDeletedIcon | Improve this Doc View Source RowDeletedIcon Pfad für ein Icon, das im Row-Header angezeigt wird, wenn die Zeile zum Löschen markiert wurde. Das Icon wird angezeigt, wenn an dem Objekt der Zeile (Component) das Property StateBeforeUpdate den Wert true hat. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string RowDeletedIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeader.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeader.html",
    "title": "Property RowHeader",
    "keywords": "Property RowHeader | Improve this Doc View Source RowHeader Bestimmt, ob im Row-Header die Zeilennummer oder der Status des Rows angezeigt wird. Declaration [DevBrowsable(true)] [Browsable(true)] [ControlStylesBrowsable(true)] public GridRowHeader? RowHeader { get; set; } Property Value Nullable < GridRowHeader >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeaderWidth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.RowHeaderWidth.html",
    "title": "Property RowHeaderWidth",
    "keywords": "Property RowHeaderWidth | Improve this Doc View Source RowHeaderWidth Höhe der Spalten. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? RowHeaderWidth { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.SelectedRows.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.SelectedRows.html",
    "title": "Property SelectedRows",
    "keywords": "Property SelectedRows | Improve this Doc View Source SelectedRows Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Zeilen im Grid markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedRows { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Remarks Eine Collection ist eine Sammlung von mehreren Objekten. Um Objekte in dieser Collection anzusprechen, gibt es verschiedene Möglichkeiten. Sie können einerseits über die ID an ein Objekt herankommen ( Collection[ID] ), andererseits können Sie auch über die guid Objekte ansprechen ( Collection[ guid ] ). So können Sie direkt mit den guids aus der SelectedRowsCollection die entsprechenden Objekte aus dem Datasource ansprechen: // SelectedRowsCollection im Form-Event auswerten (oMyColl ist Datasource des Grids) foreach ( guid guidrow in oSelectedRowsColl ) { oMyColl[guidrow].MyFunction( ); } Es ist auch ganz einfach selbst dafür zu sorgen, welche Zeilen ausgewählt werden: // Manuell Zeilen in einem Grid markieren (oMyColl ist Datasource des Grids) // SelectedRowsCollection leeren (keine Zeile ausgewählt) oSelectedRowsColl.Clear( ); // Wenn eine bestimmte Bedingung erfüllt ist, entsprechende Zeilen selektieren foreach (cMyComponent oMyObjectTemp in oMyColl) { if MyObjectTemp.MyProperty > 10 oSelectedRowsColl.Add( MyObjectTemp ); }"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.Multiselect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.Multiselect.html",
    "title": "Property Multiselect",
    "keywords": "Property Multiselect | Improve this Doc View Source Multiselect Gibt an, ob mehrere Zeilen ausgewählt werden können. Bei False kann nur maximal eine Zeile ausgewählt werden. Bei True ist die Auswahl mehrerer Zeilen möglich. Welche Zeilen ausgewählt sind, lässt sich in der SelectRowsCollection auswerten und setzen (siehe Property SelectedRows ). Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiselect { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.MainMemorySortingThreshold.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.MainMemorySortingThreshold.html",
    "title": "Property MainMemorySortingThreshold",
    "keywords": "Property MainMemorySortingThreshold | Improve this Doc View Source MainMemorySortingThreshold Grids bieten grundsätzlich die Möglichkeit, die dargestellten Daten nach einer Spalte zu sortieren oder zu filtern. Dazu stehen zwei Mechanismen ( Datenbanksortierung und Hauptspeichersortierung ) zur Verfügung. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? MainMemorySortingThreshold { get; set; } Property Value Nullable < Int32 > Remarks Hauptspeichersortierung: Vorteil: Schnell Es kann nach allen Eigenschaften sortiert werden Jederzeit möglich. Nachteil: Hoher Arbeitsspeicherverbrauch. Sortierung auf der Datenbank (Datenbanksortierung): Vorteil: Geringer Arbeitsspeicherverbrauch auch bei großen Datenmengen. Nachteil: Es kann nur nach Datenbankeigenschaften sortiert werden Etwas Langsamer Daten müssen in die Datenbank gespeichert worden sein Um die Vorteile beider Mechanismen nutzen zu können, verwendet Framework Studio beide Mechanismen, abhängig von der Menge der dargestellten Daten. Die Eigenschaft MainMemorySortingThreshold gibt den Grenzwert an, wieviele Datensätze die an das Grid gebundene Collection maximal enthalten darf, damit Hauptspeichersortierung verwendet wird. Werden Datensätze mit der Methode Add der Collection hinzugefügt, so wird der Grenzwert automatisch um die Anzahl hinzugefügter Datensätze erhöht. Wird die Eigenschaft nicht an einem Form Control geändert sondern direkt an einem Control Style, so müssen anschließend die Global Objects kompiliert werden, damit die Änderung wirksam wird."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferReloadRowCount.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferReloadRowCount.html",
    "title": "Property TransferReloadRowCount",
    "keywords": "Property TransferReloadRowCount | Improve this Doc View Source TransferReloadRowCount Definiert, wie viele Zeilen nachgelesen werden, wenn in der Tabelle in den entsprechenden Bereich gescrollt wurde. Bei 0 werden alle Zeilen zurückgegeben. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? TransferReloadRowCount { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferStartupRowCount.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.TransferStartupRowCount.html",
    "title": "Property TransferStartupRowCount",
    "keywords": "Property TransferStartupRowCount | Improve this Doc View Source TransferStartupRowCount Definiert, wie viele Zeilen bei einem Load zunächst an den Client zurückgegeben werden. Bei 0 werden alle Zeilen zurückgegeben. Es wird nicht empfohlen, sich standardmäßig alle Zeilen zurückgeben zu lassen, da dies bei großen Datenmengen zu starker Belastung des Clients und des Webservers kommt. Es ist deshalb besser, sich zunächst einen Block zurückgeben zu lassen und bei Bedarf die Daten dynamisch nachlesen zu lassen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public int? TransferStartupRowCount { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable | Improve this Doc View Source IsEditable Gibt an, ob am Grid Daten geändert werden dürfen. Ist IsEditable auf False gesetzt, wirkt sichdas auf alle Columns aus – egal, was dort angegeben ist. Declaration public override bool? IsEditable { get; set; } Property Value Nullable < Boolean > Overrides ControlDesignViewModel.IsEditable"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Gibt den Datasource an, dessen Daten im Grid angezeigt werden sollen. Es ist wichtig, dass Sie hier eine Collection angeben. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnAppendNewRow.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnAppendNewRow.html",
    "title": "Event OnAppendNewRow",
    "keywords": "Event OnAppendNewRow Dieser Vorgang wird ausgelöst, wenn in der letzten Zeile im letzten editierbaren Feld die Tab-Taste gedrückt wird. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnAppendNewRow Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnColumnChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnColumnChanged.html",
    "title": "Event OnColumnChanged",
    "keywords": "Event OnColumnChanged Wird ausgelöst, wenn sich der Inhalt einer Spalte geändert hat. Sie können über das EventArg e.RowID das Objekt ermitteln, bei dem das Event aufgetreten ist. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkColumnChangedEventArgs> OnColumnChanged Returns Type Description EventHandler < FrameworkColumnChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowClick.html",
    "title": "Event OnRowClick",
    "keywords": "Event OnRowClick Tritt auf, wenn auf die Zeile geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkDoubleClickEventArgs> OnRowClick Returns Type Description EventHandler < FrameworkDoubleClickEventArgs > Remarks Wenn eine Zeile einmal geklickt und dadurch selektiert wurde, wird bei einem erneuten Klick auf dieselbe Zeile kein weiteres OnRowClick-Event ausgelöst. So wird verhindert, dass das OnRowClick-Event für ein und dieselbe Zeile mehrfach hintereinander ausgelöst wird. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist und auf Server-Seite die Selektion auf die zuletzt geklickte Zeile entfernt wird, dann wird bei einem erneuten Klick das Event wieder ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowSelectionChanged.html",
    "title": "Event OnRowSelectionChanged",
    "keywords": "Event OnRowSelectionChanged Tritt auf, wenn sich die Selektion im Grid ändert - auch bei Deselektion von Datensätzen. Wenn dem Grid eine SelectedRowsCollection zugeordnet ist, wird diese durch das Event aktualisiert. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkSelectionChangedEventArgs> OnRowSelectionChanged Returns Type Description EventHandler < FrameworkSelectionChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.GridDesignViewModel.OnRowDoubleClick.html",
    "title": "Event OnRowDoubleClick",
    "keywords": "Event OnRowDoubleClick Tritt auf, wenn auf die Zeile doppelt geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkDoubleClickEventArgs> OnRowDoubleClick Returns Type Description EventHandler < FrameworkDoubleClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonIcon.html",
    "title": "Property LoadPageButtonIcon",
    "keywords": "Property LoadPageButtonIcon | Improve this Doc View Source LoadPageButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string LoadPageButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonIcon.html",
    "title": "Property ReloadButtonIcon",
    "keywords": "Property ReloadButtonIcon | Improve this Doc View Source ReloadButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ReloadButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonIcon.html",
    "title": "Property ZoomInButtonIcon",
    "keywords": "Property ZoomInButtonIcon | Improve this Doc View Source ZoomInButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ZoomInButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonIcon.html",
    "title": "Property ZoomResetButtonIcon",
    "keywords": "Property ZoomResetButtonIcon | Improve this Doc View Source ZoomResetButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ZoomResetButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonShortcut.html",
    "title": "Property BackwardButtonShortcut",
    "keywords": "Property BackwardButtonShortcut | Improve this Doc View Source BackwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? BackwardButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonShortcut.html",
    "title": "Property ForwardButtonShortcut",
    "keywords": "Property ForwardButtonShortcut | Improve this Doc View Source ForwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ForwardButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadButtonShortcut.html",
    "title": "Property ReloadButtonShortcut",
    "keywords": "Property ReloadButtonShortcut | Improve this Doc View Source ReloadButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ReloadButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonShortcut.html",
    "title": "Property ZoomInButtonShortcut",
    "keywords": "Property ZoomInButtonShortcut | Improve this Doc View Source ZoomInButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomInButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonShortcut.html",
    "title": "Property ZoomOutButtonShortcut",
    "keywords": "Property ZoomOutButtonShortcut | Improve this Doc View Source ZoomOutButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomOutButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonShortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonShortcut.html",
    "title": "Property ZoomResetButtonShortcut",
    "keywords": "Property ZoomResetButtonShortcut | Improve this Doc View Source ZoomResetButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public ExtendedShortcut? ZoomResetButtonShortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonTooltip.html",
    "title": "Property BackwardButtonTooltip",
    "keywords": "Property BackwardButtonTooltip | Improve this Doc View Source BackwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString BackwardButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonTooltip.html",
    "title": "Property CancelButtonTooltip",
    "keywords": "Property CancelButtonTooltip | Improve this Doc View Source CancelButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString CancelButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonTooltip.html",
    "title": "Property ForwardButtonTooltip",
    "keywords": "Property ForwardButtonTooltip | Improve this Doc View Source ForwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ForwardButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.LoadPageButtonTooltip.html",
    "title": "Property LoadPageButtonTooltip",
    "keywords": "Property LoadPageButtonTooltip | Improve this Doc View Source LoadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString LoadPageButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadPageButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ReloadPageButtonTooltip.html",
    "title": "Property ReloadPageButtonTooltip",
    "keywords": "Property ReloadPageButtonTooltip | Improve this Doc View Source ReloadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ReloadPageButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomInButtonTooltip.html",
    "title": "Property ZoomInButtonTooltip",
    "keywords": "Property ZoomInButtonTooltip | Improve this Doc View Source ZoomInButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ZoomInButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomOutButtonTooltip.html",
    "title": "Property ZoomOutButtonTooltip",
    "keywords": "Property ZoomOutButtonTooltip | Improve this Doc View Source ZoomOutButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ZoomOutButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonTooltip.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ZoomResetButtonTooltip.html",
    "title": "Property ZoomResetButtonTooltip",
    "keywords": "Property ZoomResetButtonTooltip | Improve this Doc View Source ZoomResetButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [Browsable(true)] [ControlStylesBrowsable] public IMLString ZoomResetButtonTooltip { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.EnableJavaScript.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.EnableJavaScript.html",
    "title": "Property EnableJavaScript",
    "keywords": "Property EnableJavaScript | Improve this Doc View Source EnableJavaScript Gibt an, ob JavaScript im Browser aktiviert ist. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? EnableJavaScript { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnLinkClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnLinkClick.html",
    "title": "Event OnLinkClick",
    "keywords": "Event OnLinkClick Tritt ein, wenn ein Html-Link mit der Maus angeklickt wurde. Um eine Client-seitige Navigation zu unterbinden, werden alle Links an den Event-Args konsumiert und müssen, falls gewünscht, wieder manuell über einen der Datasources zum Client geschickt werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnLinkClick Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageLoaded.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageLoaded.html",
    "title": "Event OnPageLoaded",
    "keywords": "Event OnPageLoaded Tritt ein, wenn die aktuelle Seite vom Browser fertig geladen ist. Das Event-Argument stellt die Adresse (url) und den Titel (title) der geladenen Seite zur Verfügung. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnPageLoaded Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageError.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnPageError.html",
    "title": "Event OnPageError",
    "keywords": "Event OnPageError Tritt ein falls beim Laden der Seite ein Fehler aufgetreten ist Über das Event Argument können folgende Informationen über die Fehlermeldung ausgelesen werden: • Url: Gibt die Url zurück zu der navigiert werden sollte • Message: Gibt den Fehlergrund zurück Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnPageError Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnSnapshotGenerated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.OnSnapshotGenerated.html",
    "title": "Event OnSnapshotGenerated",
    "keywords": "Event OnSnapshotGenerated Tritt ein, wenn der Snapshot von der Action GenerateSnapshot erstellt wurde. • Snapshot: Gibt den Snapshot als Byte-Array im PNG Format zurück Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLinkClickEventArgs> OnSnapshotGenerated Returns Type Description EventHandler < FrameworkOnLinkClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.html",
    "title": "Class BrowserDesignViewModel",
    "keywords": "Class BrowserDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel BrowserDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class BrowserDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BackwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button BackwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. BackwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. BrowserMode Gibt an, ob der Browser-Mode ausgewählt wurde. Der Browser-Mode ist zur Anzeige von Webseiten geeignet und verfügt über eine Adresszeile. Die in die Adresszeile eingegebene URL wird durch den LoadPageButton geladen.Das Laden der Seite kann durch den CancelButton abgebrochen und über den ReloadPageButton neu gestartet werden. Außerdem verfügt der Browser-Mode über Buttons, mit denen eine Vorwärts- und Rückwärtsnavigation möglich ist. CancelButtonIcon Pfad zu einem Icon, das für den jeweiligen Button CancelButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Content Über den Datasource Content können Inhalte wie z.B. HTML-Content oder der Pfad zu einer Datei, die im Browser angezeigt werden soll, an den Client übertragen werden. Der Datasource ist unidirektional(nur von Broker zu Client) und hat höhere Priorität als Url. Ressourcen können mit fsbroker://RelativerPfad angezeigt oder verwendet werden. Mit der Funktion CreateRessourcesUrl( ) der Klasse BrowserCommand kann eine Broker-Url erstellt werden. Diese Url kann dann, wie in dem nachfolgenden Beispiel, in Verbindung mit HTML als Link zu einer Datei verwendet warden: EnableJavaScript Gibt an, ob JavaScript im Browser aktiviert ist. ForwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ForwardButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ForwardButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. LoadPageButtonIcon Pfad zu einem Icon, das für den jeweiligen Button LoadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ReloadButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ReloadButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ReloadPageButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ShowStatusBar Gibt an, ob die Statusleiste (Ladestatus der aktuellen Seite + MouseOver Link) angezeigt wird. Die Statusleiste wird nur in Verbindung mit dem BrowserMode angezeigt. ShowZoomBar Gibt an, ob die Leiste zur Änderung der Größe des Inhalts im Browser angezeigt wird. Url Mit dem Datasource Url können Webseiten, die im Browser angezeigt werden sollen, an den Client übertragen werden. Der Datasource ist unidirektional (nur von Broker zu Client). ZoomInButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ZoomInButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomInButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ZoomOutButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomOutButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. ZoomResetButtonIcon Pfad zu einem Icon, das für den jeweiligen Button ZoomResetButtonShortcut ein Tastenkürzel (Tastenkombination) für den schnellen Zugriff auf den Button festlegt. Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, wird die Aktion für den jeweiligen Button ausgeführt. ZoomResetButtonTooltip Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Button, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Events OnLinkClick Tritt ein, wenn ein Html-Link mit der Maus angeklickt wurde. Um eine Client-seitige Navigation zu unterbinden, werden alle Links an den Event-Args konsumiert und müssen, falls gewünscht, wieder manuell über einen der Datasources zum Client geschickt werden. OnPageError Tritt ein falls beim Laden der Seite ein Fehler aufgetreten ist Über das Event Argument können folgende Informationen über die Fehlermeldung ausgelesen werden: • Url: Gibt die Url zurück zu der navigiert werden sollte • Message: Gibt den Fehlergrund zurück OnPageLoaded Tritt ein, wenn die aktuelle Seite vom Browser fertig geladen ist. Das Event-Argument stellt die Adresse (url) und den Titel (title) der geladenen Seite zur Verfügung. OnSnapshotGenerated Tritt ein, wenn der Snapshot von der Action GenerateSnapshot erstellt wurde. • Snapshot: Gibt den Snapshot als Byte-Array im PNG Format zurück"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html",
    "title": "Property ValueAsObject",
    "keywords": "Property ValueAsObject | Improve this Doc View Source ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Declaration object ValueAsObject { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html",
    "title": "Property IsNull",
    "keywords": "Property IsNull | Improve this Doc View Source IsNull Gibt an, ob der Wert der Variable Null ist. Declaration bool IsNull { get; set; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue | Improve this Doc View Source HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. Declaration bool HasValue { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html",
    "title": "Method GetFromObject",
    "keywords": "Method GetFromObject | Improve this Doc View Source GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter. Declaration IFSType GetFromObject(object val) Parameters val Object Returns IFSType"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html",
    "title": "Property DBValue",
    "keywords": "Property DBValue | Improve this Doc View Source DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. Declaration object DBValue { get; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html",
    "title": "Method EqualsValue",
    "keywords": "Method EqualsValue | Improve this Doc View Source EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. Declaration bool EqualsValue(string value2) Parameters value2 String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html",
    "title": "Interface IFSType",
    "keywords": "Interface IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung. Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax public interface IFSType : IComparable Remarks Siehe auch: FS-Datentypen Properties DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. IsNull Gibt an, ob der Wert der Variable Null ist. ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Methods EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html",
    "title": "Struct FSSystemGuid",
    "keywords": "Struct FSSystemGuid TODO! Summary description for FSSystemGuid. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSSystemGuid : IFSSystemGuid, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html",
    "title": "Struct FSbyteArray",
    "keywords": "Struct FSbyteArray TODO! Summary description for FSbyteArray. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyteArray : IFSbyteArray, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewItemArrangement.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewItemArrangement.html",
    "title": "Enum ListViewItemArrangement",
    "keywords": "Enum ListViewItemArrangement Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewItemArrangement Fields Name Description List Wrap"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Width.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Width.html",
    "title": "Property Width",
    "keywords": "Property Width | Improve this Doc View Source Width Declaration [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] [ControlStylesBrowsable(true)] public Nonable<int>? Width { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Height.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.Height.html",
    "title": "Property Height",
    "keywords": "Property Height | Improve this Doc View Source Height Declaration [Browsable(true)] [TypeConverter(typeof(Nonable.NonableTypeConverter<int>))] [ControlStylesBrowsable(true)] public Nonable<int>? Height { get; set; } Property Value Nullable < Nonable < Int32 >>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.NonableSize.html",
    "title": "Class NonableSize",
    "keywords": "Class NonableSize Inheritance Object NonableSize Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(NonableSizeObjectConverter))] public class NonableSize Properties Height Width"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor | Improve this Doc View Source BackColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor | Improve this Doc View Source ForeColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Font.html",
    "title": "Property Font",
    "keywords": "Property Font | Improve this Doc View Source Font Declaration public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign | Improve this Doc View Source TextAlign Declaration public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding | Improve this Doc View Source Padding Declaration public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin | Improve this Doc View Source Margin Declaration public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MinSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MinSize.html",
    "title": "Property MinSize",
    "keywords": "Property MinSize | Improve this Doc View Source MinSize Declaration public NonableSize MinSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize | Improve this Doc View Source MaxSize Declaration public NonableSize MaxSize { get; set; } Property Value NonableSize"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.ControlLabelTemplateBase.html",
    "title": "Class ControlLabelTemplateBase",
    "keywords": "Class ControlLabelTemplateBase Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase ControlLabelTemplateBase ControlLabelTemplate RowLabelTemplate Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(ControlLabelTemplateConverter))] public abstract class ControlLabelTemplateBase : DevDataStyleBase, INotifyPropertyChanged, IFsXmlSerializable Properties BackColor Font ForeColor Margin MaxSize MinSize Padding TextAlign"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkEventArgs.html",
    "title": "Class FrameworkEventArgs",
    "keywords": "Class FrameworkEventArgs Alle FormMethod-EventHandler haben als (einziger) Parameter ein Objekt vom Typ FrameworkEventArgs (oder einer Ableitung). FrameworkEventArgs stellt selbst noch keine besondere Funktionalität bereit, dies kann aber von Ableitungen gemacht werden. So ist es möglich, dem EventHandler weitere Informationen zu übergeben. Siehe hierzu FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition . Inheritance Object EventArgs FrameworkEventArgs FrameworkButtonClickEventArgs FrameworkCheckBoxClickEventArgs FrameworkDoubleClickEventArgs FrameworkOnItemActivatedEventArgs FrameworkOnLeaveEventArgs FrameworkOnLinkClickEventArgs FrameworkOnReloadEventArgs FrameworkSelectionChangedEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkEventArgs : EventArgs"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowID.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowID.html",
    "title": "Property RowID",
    "keywords": "Property RowID | Improve this Doc View Source RowID GUID der Zeile, auf der ein Doppelklick erfolgt ist. Declaration public guid RowID { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowIndex.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.RowIndex.html",
    "title": "Property RowIndex",
    "keywords": "Property RowIndex | Improve this Doc View Source RowIndex Zero-Based index of the row -1 if not valid. Declaration public int RowIndex { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkDoubleClickEventArgs.html",
    "title": "Class FrameworkDoubleClickEventArgs",
    "keywords": "Class FrameworkDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID des Parameters der Methode zugreifen. Inheritance Object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkDoubleClickEventArgs : FrameworkEventArgs Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties RowID GUID der Zeile, auf der ein Doppelklick erfolgt ist. RowIndex Zero-Based index of the row -1 if not valid."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html",
    "title": "Struct FSstring",
    "keywords": "Struct FSstring TODO! Summary description for FSstring. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSstring : IFSstring, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html",
    "title": "Struct FSbool",
    "keywords": "Struct FSbool Summary description for FSbool. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbool : IFSbool, IFSType, IComparable, IConvertible Remarks TODO! Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.ControlName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.ControlName.html",
    "title": "Property ControlName",
    "keywords": "Property ControlName | Improve this Doc View Source ControlName Declaration string ControlName { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.Form.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.Form.html",
    "title": "Property Form",
    "keywords": "Property Form | Improve this Doc View Source Form Declaration IGeneratedForm Form { get; } Property Value FrameworkSystems.FrameworkBase.IGeneratedForm"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkControlActionBase.html",
    "title": "Interface IFrameworkControlActionBase",
    "keywords": "Interface IFrameworkControlActionBase Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkControlActionBase Properties ControlName Form"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.GlobalObj",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.GlobalObj Interfaces IcGlobalBase Bereits im SystemPackage existiert im Namespace FSGeneral eine Component mit dem Namen cGlobal. Diese Component kann customized werden. Aus Forms oder Components heraus kann eine Instanz dieser Component mit this.Global. ocGlobal angesprochen werden. IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten."
  },
  "api/FrameworkSystems.FrameworkBase.Converter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Converter",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Converter Classes XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Interfaces IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T ."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html",
    "title": "Property UserTokenAsString",
    "keywords": "Property UserTokenAsString | Improve this Doc View Source UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string UserTokenAsString { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html",
    "title": "Property Username",
    "keywords": "Property Username | Improve this Doc View Source Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string Username { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html",
    "title": "Property IsDefaultUser",
    "keywords": "Property IsDefaultUser | Improve this Doc View Source IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. Declaration public bool IsDefaultUser { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html",
    "title": "Property AuthenticationEnabled",
    "keywords": "Property AuthenticationEnabled | Improve this Doc View Source AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. Declaration public bool AuthenticationEnabled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html",
    "title": "Method IdentifyDefaultUser",
    "keywords": "Method IdentifyDefaultUser | Improve this Doc View Source IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser() Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück. | Improve this Doc View Source IdentifyDefaultUser(out AUHelper.Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser(out AUHelper.Message msg) Parameters msg FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html",
    "title": "Method IdentifyUser",
    "keywords": "Method IdentifyUser | Improve this Doc View Source IdentifyUser(out AUHelper.Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyUser(out AUHelper.Message msg, string username, string password, ref string loginInfo, bool includeRolesInToken) Parameters msg FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. username String password String loginInfo String Der Parameter LoginIngo wird ausgelesen und vom Authentication Service geloggt. Zurückgegeben wird die zuletzt geloggte Information. includeRolesInToken Boolean Der letzte Parameter gibt an, ob die Rollen im Token kommuniziert werden sollen - Standardwert true Returns Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html",
    "title": "Method IdentifyUnit",
    "keywords": "Method IdentifyUnit | Improve this Doc View Source IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. Declaration public void IdentifyUnit(string unitKey) Parameters unitKey String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html",
    "title": "Field XML_NULL",
    "keywords": "Field XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string XML_NULL = \"\" Returns Type Description String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html",
    "title": "Field XMLNumberFormat",
    "keywords": "Field XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo XMLNumberFormat Returns Type Description CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html",
    "title": "Field DateTimeNumberFormat",
    "keywords": "Field DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo DateTimeNumberFormat Returns Type Description CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html",
    "title": "Property Get",
    "keywords": "Property Get | Improve this Doc View Source Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Declaration public static XmlConverter Get { get; } Property Value XmlConverter"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html",
    "title": "Method IsConvertible",
    "keywords": "Method IsConvertible | Improve this Doc View Source IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). Declaration public bool IsConvertible(Type type) Parameters type Type Returns Boolean | Improve this Doc View Source IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. Declaration public bool IsConvertible(string typeName) Parameters typeName String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml | Improve this Doc View Source FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public T FromXml<T>(string xml) Parameters xml String Returns T Type Parameters Name Description T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml | Improve this Doc View Source ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml<T>(T value) Parameters value T Returns String Type Parameters Name Description T | Improve this Doc View Source ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml(object value) Parameters value Object Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html",
    "title": "Class XmlConverter",
    "keywords": "Class XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Inheritance Object XmlConverter Implements IXmlConverter < FSbool > IXmlConverter < FSbyte > IXmlConverter < FSbyteArray > IXmlConverter < FSDateTime > IXmlConverter < FSdecimal > IXmlConverter < FSdouble > IXmlConverter < FSfloat > IXmlConverter < FSint > IXmlConverter < FSlong > IXmlConverter < FSshort > IXmlConverter < FSstring > IXmlConverter < FSSystemGuid > IXmlConverter < Boolean > IXmlConverter < Byte > IXmlConverter < Byte []> IXmlConverter < DateTime > IXmlConverter < Decimal > IXmlConverter < Double > IXmlConverter < Single > IXmlConverter < Int32 > IXmlConverter < Int64 > IXmlConverter < Int16 > IXmlConverter < String > IXmlConverter < Guid > Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class XmlConverter : IXmlConverter<FSbool>, IXmlConverter<FSbyte>, IXmlConverter<FSbyteArray>, IXmlConverter<FSDateTime>, IXmlConverter<FSdecimal>, IXmlConverter<FSdouble>, IXmlConverter<FSfloat>, IXmlConverter<FSint>, IXmlConverter<FSlong>, IXmlConverter<FSshort>, IXmlConverter<FSstring>, IXmlConverter<FSSystemGuid>, IXmlConverter<bool>, IXmlConverter<byte>, IXmlConverter<byte[]>, IXmlConverter<DateTime>, IXmlConverter<decimal>, IXmlConverter<double>, IXmlConverter<float>, IXmlConverter<int>, IXmlConverter<long>, IXmlConverter<short>, IXmlConverter<string>, IXmlConverter<Guid> Remarks Ein Objekt dieser Klasse wird als Singleton-Instanz angeboten. Note Im Java-Client gibt es ein entsprechendes Gegenstück, die Klasse FrameworkSystems.FSJavaClient.UIWrapper.DotNetTypes , welche statische Methoden zum Umwandeln von Objekten in einen String und umgekehrt anbietet. Unterstützte Typen Die Klasse unterstützt die Konvertierung ausschließlich für die im Folgenden aufgeführten Typen und implementiert für jeden der Typen T das entsprechende Interface IXmlConverter<T> : FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring FSSystemGuid bool byte byte[] DateTime decimal double float int long short string Guid Fields DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Properties Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Methods FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException ."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.AccessControl",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.AccessControl Classes AccessUnit TODO! AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowList.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowList.html",
    "title": "Property RowList",
    "keywords": "Property RowList | Improve this Doc View Source RowList Diese Liste enthält die Zeilennummern der betroffenen Datensätze. Declaration public List<int> RowList { get; } Property Value List < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowIDList.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.RowIDList.html",
    "title": "Property RowIDList",
    "keywords": "Property RowIDList | Improve this Doc View Source RowIDList Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). Declaration public List<guid> RowIDList { get; } Property Value List < guid >"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnReloadEventArgs.html",
    "title": "Class FrameworkOnReloadEventArgs",
    "keywords": "Class FrameworkOnReloadEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnReloadDefinition verknüpfte FormMethod kann somit auf die RowList zugreifen Inheritance Object EventArgs FrameworkEventArgs FrameworkOnReloadEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnReloadEventArgs : FrameworkEventArgs Properties RowIDList Diese Liste enthält die ObjectRowIDs der betroffenen Datensätze. Mit diesen kann der Datensatz direkt aus der Collection ermittelt werden (oMyColl[rowID]). RowList Diese Liste enthält die Zeilennummern der betroffenen Datensätze."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html",
    "title": "Method GetArgumentFSlong",
    "keywords": "Method GetArgumentFSlong | Improve this Doc View Source GetArgumentFSlong(String) Declaration public FSlong GetArgumentFSlong(string key) Parameters key String Returns FSlong"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html",
    "title": "Class FrameworkOnLinkClickEventArgs",
    "keywords": "Class FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden Inheritance Object EventArgs FrameworkEventArgs FrameworkOnLinkClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnLinkClickEventArgs : FrameworkEventArgs Methods GetArgumentFSlong(String)"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html",
    "title": "Enum GridColumnDefinition.ColumnTextAlign",
    "keywords": "Enum GridColumnDefinition.ColumnTextAlign Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnTextAlign Fields Name Description Center Left Right"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html",
    "title": "Enum GridColumnDefinition.ColumnSortOrder",
    "keywords": "Enum GridColumnDefinition.ColumnSortOrder Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnSortOrder Fields Name Description Ascending Descending Unsorted"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetEditable.html",
    "title": "Method SetEditable",
    "keywords": "Method SetEditable | Improve this Doc View Source SetEditable(Boolean) !TODO Declaration public void SetEditable(bool isEditable) Parameters isEditable Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetMultiselect.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetMultiselect.html",
    "title": "Method SetMultiselect",
    "keywords": "Method SetMultiselect | Improve this Doc View Source SetMultiselect(Boolean) Diese Methode ermöglicht es während der Laufzeit Mehrfachselektionen am GridControl zuzulassen oder zu verweigern. Declaration public void SetMultiselect(bool isMultiselectAllowed) Parameters isMultiselectAllowed Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ResetSortAndFilter.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ResetSortAndFilter.html",
    "title": "Method ResetSortAndFilter",
    "keywords": "Method ResetSortAndFilter | Improve this Doc View Source ResetSortAndFilter() !TODO Declaration public void ResetSortAndFilter()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RedoSortAndFilter.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RedoSortAndFilter.html",
    "title": "Method RedoSortAndFilter",
    "keywords": "Method RedoSortAndFilter | Improve this Doc View Source RedoSortAndFilter() !TODO Declaration public void RedoSortAndFilter()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetView.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetView.html",
    "title": "Method GetView",
    "keywords": "Method GetView | Improve this Doc View Source GetView() !TODO Declaration public IGridView GetView() Returns IGridView"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.AddColumn.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.AddColumn.html",
    "title": "Method AddColumn",
    "keywords": "Method AddColumn | Improve this Doc View Source AddColumn(GridColumnDefinition) Fügt dem Grid eine neue Spalte hinzu. Sollte zu dem in der GridColumnDefinition angegebenen Property bereits eine Spalte existieren, so wird eine Exception ausgelöst. Declaration public GridColumnControlAction AddColumn(GridColumnDefinition columnDefinition) Parameters columnDefinition GridColumnDefinition Returns GridColumnControlAction"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetDynamicColumnAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.GetDynamicColumnAction.html",
    "title": "Method GetDynamicColumnAction",
    "keywords": "Method GetDynamicColumnAction | Improve this Doc View Source GetDynamicColumnAction(String) Gibt die GridColumnControlAction der zur Laufzeit hinzugefügten Spalte (=dynamische Spalte) für das angegebene Property zurück. Wenn für das Property keine dynamische Spalte existiert, wird null zurück gegeben. Declaration public GridColumnControlAction GetDynamicColumnAction(string property) Parameters property String Returns GridColumnControlAction"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveColumn.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveColumn.html",
    "title": "Method RemoveColumn",
    "keywords": "Method RemoveColumn | Improve this Doc View Source RemoveColumn(GridColumnDefinition) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. Declaration public void RemoveColumn(GridColumnDefinition columnDefinition) Parameters columnDefinition GridColumnDefinition | Improve this Doc View Source RemoveColumn(GridColumnControlAction) Entfernt die dynamische Spalte, falls sie existiert. Declaration public void RemoveColumn(GridColumnControlAction gridColumnControlAction) Parameters gridColumnControlAction GridColumnControlAction | Improve this Doc View Source RemoveColumn(String) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. Declaration public void RemoveColumn(string property) Parameters property String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveAllDynamicColumns.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.RemoveAllDynamicColumns.html",
    "title": "Method RemoveAllDynamicColumns",
    "keywords": "Method RemoveAllDynamicColumns | Improve this Doc View Source RemoveAllDynamicColumns() Entfernt alle dynamischen Spalten. Declaration public void RemoveAllDynamicColumns()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.html",
    "title": "Class GridControlAction",
    "keywords": "Class GridControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction GridControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class GridControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Methods AddColumn(GridColumnDefinition) Fügt dem Grid eine neue Spalte hinzu. Sollte zu dem in der GridColumnDefinition angegebenen Property bereits eine Spalte existieren, so wird eine Exception ausgelöst. GetDynamicColumnAction(String) Gibt die GridColumnControlAction der zur Laufzeit hinzugefügten Spalte (=dynamische Spalte) für das angegebene Property zurück. Wenn für das Property keine dynamische Spalte existiert, wird null zurück gegeben. GetView() !TODO LoadGridLayout(String, Boolean) !TODO RedoSortAndFilter() !TODO RemoveAllDynamicColumns() Entfernt alle dynamischen Spalten. RemoveColumn(GridColumnControlAction) Entfernt die dynamische Spalte, falls sie existiert. RemoveColumn(GridColumnDefinition) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. RemoveColumn(String) Entfernt die dynamische Spalte zu dem in der GridColumnDefinition angegebenen Property, falls sie existiert. ResetSortAndFilter() !TODO SaveGridLayout(String, Boolean) !TODO ScrollTo(guid) !TODO ScrollTo(Int32) !TODO SetCell(guid, Int32) Diese Aktion setzt den Fokus in eine Zelle des Grids. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. SetCell(guid, String) Wie SetCell(guid, Int32) . Zusätzlich gibt es hier den Parameter SelectAll , mit dem angegeben werden kann, ob der gesamte Inhalt der Zelle markiert werden soll. Mit true wird der Inhalt markiert und kann direkt überschrieben werden. SetCellBackColor(guid, Int32, Color) !TODO SetCellBackColor(guid, String, Color) !TODO SetCellEditable(guid, Int32, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. SetCellEditable(guid, String, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. columnName ist der Name der Spalte. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. SetCellForeColor(guid, Int32, Color) !TODO SetCellForeColor(guid, String, Color) !TODO SetColumnCaption(Int32, String) Setzt die Spaltenüberschrift der Spalte Nummer ColumnPos auf den Wert value . SetColumnCaption(String, String) Setzt die Spaltenüberschrift der Spalte ColumnName auf den neuen Wert value . SetColumnToolTip(Int32, String) !TODO SetColumnToolTip(String, String) !TODO SetColumnVisible(Int32, Boolean) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. SetColumnVisible(Int32, Nullable<Boolean>) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. SetColumnVisible(String, Boolean) Legt fest, ob die Spalte ColumnName dargestellt werden soll. SetColumnVisible(String, Nullable<Boolean>) Legt fest, ob die Spalte ColumnName dargestellt werden soll. SetEditable(Boolean) !TODO SetGridColor(Color) !TODO SetGridRowHeight(Int32) Legt die Zeilenhöhe der einzelnen Zeilen im Grid fest. SetMultiselect(Boolean) Diese Methode ermöglicht es während der Laufzeit Mehrfachselektionen am GridControl zuzulassen oder zu verweigern. See Also GridDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.html",
    "title": "Namespace FrameworkSystems.FrameworkBase",
    "keywords": "Namespace FrameworkSystems.FrameworkBase Classes BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. SelectedRowsCollection !TODO Interfaces IDevFrameworkObject IDevFrameworkObjectMLString Repräsentiert den Eintrag einer TextCollection. IFrameworkBarcodeScanInfo Eine Instanz dieses Typs wird nach einem mit der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) ausgelösten Scan-Vorgang der Callback-Methode übergeben. Sie beinhaltet die Ergebisse des Scan-Vorgangs. IFrameworkControlActionBase IFrameworkGeoLocationInfo Eine Instanz dieses Typs wird nach einem mit der Action GetGeoLocation(Action<IFrameworkGeoLocationInfo>) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet alle Informationen zum derzeitigen Standort des Endgeräts. IFrameworkPhotoInfo Eine Instanz dieses Typs wird nach einem mit der Action TakePhoto(Action<IFrameworkPhotoInfo>, CameraSource) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet die Bilddaten des neuen oder ausgewählten Bildes und Zusatzinformationen. IGridView Ein Grid zeigt immer Daten einer Collection an. Um mit den Daten zu arbeiten, muss auf die Collection zugegriffen werden, die an das entsprechende Grid gebunden ist. Enums AUPermissionType Kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. BarcodeFormat CameraSource DevTextAlign Gibt die Ausrichtung des Textes an. DockPanelOrientation DockPanelScrolling EditorStyle ExtendedShortcut ExtendedShortcut contains the same properties as the System.Windows.Forms.Shortcut enumeration. Furthermore it is extended by: Esc = 27 FieldRowLabelMode FrameworkComponentState Status des Objektes. FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben) FromControlWrapperProcessedState Verarbeitungsstatus der in einem Grid verwendeten Objekte FSVisibility GridRowHeader HorizontalAlignment ListSortOrder Sortierar ListViewHorizontalContentAlignment ListViewItemArrangement ListViewSelectionMode ListViewSelectorPosition ListViewTemplateVariableDataSourceOrigin ListViewVerticalContentAlignment PictureScaleMode used for Picture.ScaleMode SaveEntryPoints StackPanelHAlignment StackPanelOrientation StackPanelVAlignment TextEditorType Used for example by the Editbox control to specify the kind of text to be handled by the control. TreeViewDragDropMode VerticalAlignment WrapPanelHorizontalContentAlignment WrapPanelVerticalContentAlignment WrapPanelWrapArrangement"
  },
  "api/FrameworkSystems.FrameworkBase.WrapPanelWrapArrangement.html": {
    "href": "api/FrameworkSystems.FrameworkBase.WrapPanelWrapArrangement.html",
    "title": "Enum WrapPanelWrapArrangement",
    "keywords": "Enum WrapPanelWrapArrangement Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum WrapPanelWrapArrangement Fields Name Description Horizontal Vertical"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml | Improve this Doc View Source FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T Declaration T FromXml(string xml) Parameters xml String Returns T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml | Improve this Doc View Source ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. Declaration string ToXml(T value) Parameters value T Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html",
    "title": "Interface IXmlConverter<T>",
    "keywords": "Interface IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T . Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IXmlConverter<T> Type Parameters Name Description T Methods FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. See Also XmlConverter"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html",
    "title": "Field ID",
    "keywords": "Field ID Die eindeutige ID des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly guid ID Returns Type Description guid"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html",
    "title": "Enum ComboEditStyle",
    "keywords": "Enum ComboEditStyle TODO! Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.Data Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum ComboEditStyle Fields Name Description FreeTextInput ListValuesInput"
  },
  "api/FrameworkSystems.FrameworkExceptions.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.html",
    "title": "Namespace FrameworkSystems.FrameworkExceptions",
    "keywords": "Namespace FrameworkSystems.FrameworkExceptions Classes FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Enums FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.html",
    "title": "Namespace FrameworkSystems.FrameworkControls.Actions",
    "keywords": "Namespace FrameworkSystems.FrameworkControls.Actions Classes BrowserControlAction ButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Button angeboten. CheckboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Checkbox angeboten. ComboBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Combobox angeboten. DashboardContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control DashboardContainer angeboten. DockPanelControlAction EditableControlAction Summary description for EditableControlAction. EditboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control EditField angeboten. FieldPanelControlAction FieldRowControlAction FormContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control FormCointainer angeboten. FrameworkControlAction Summary description for FrameworkControlAction. FrameworkControlActionBase Actions, die so ziemlich jedes Control besitzt. GridColumnControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid-Column angeboten. GridControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Grid angeboten. ImageButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ImageButton angeboten. LabelControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Label angeboten. ListBoxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Listbox angeboten. ListViewControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ListView angeboten. MainMenuControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Menu-Item angeboten. PictureControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Picture angeboten. RadioButtonControlAction TabbedWindowControlAction TabPageControlAction TemplateControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Template Control angeboten. TreeViewControlAction WrapPanelControlAction"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.WrapPanelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.WrapPanelControlAction.html",
    "title": "Class WrapPanelControlAction",
    "keywords": "Class WrapPanelControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction WrapPanelControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class WrapPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetForeColor.html",
    "title": "Method SetForeColor",
    "keywords": "Method SetForeColor | Improve this Doc View Source SetForeColor(Nullable<Color>) Ermöglicht das Setzen der Control-Farbe zur Laufzeit. Declaration public virtual void SetForeColor(Color? color) Parameters color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBackColor.html",
    "title": "Method SetBackColor",
    "keywords": "Method SetBackColor | Improve this Doc View Source SetBackColor(Nullable<Color>) !TODO Declaration public virtual void SetBackColor(Color? color) Parameters color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetBorderColor.html",
    "title": "Method SetBorderColor",
    "keywords": "Method SetBorderColor | Improve this Doc View Source SetBorderColor(Nullable<Color>) !TODO Declaration public virtual void SetBorderColor(Color? color) Parameters color Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinWidth.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinWidth.html",
    "title": "Method SetMinWidth",
    "keywords": "Method SetMinWidth | Improve this Doc View Source SetMinWidth(FSint) !TODO Declaration public virtual void SetMinWidth(FSint value) Parameters value FSint | Improve this Doc View Source SetMinWidth(Nullable<Int32>) !TODO Declaration public virtual void SetMinWidth(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinHeight.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMinHeight.html",
    "title": "Method SetMinHeight",
    "keywords": "Method SetMinHeight | Improve this Doc View Source SetMinHeight(FSint) !TODO Declaration public virtual void SetMinHeight(FSint value) Parameters value FSint | Improve this Doc View Source SetMinHeight(Nullable<Int32>) !TODO Declaration public virtual void SetMinHeight(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxWidth.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxWidth.html",
    "title": "Method SetMaxWidth",
    "keywords": "Method SetMaxWidth | Improve this Doc View Source SetMaxWidth(FSint) !TODO Declaration public virtual void SetMaxWidth(FSint value) Parameters value FSint | Improve this Doc View Source SetMaxWidth(Nullable<Int32>) !TODO Declaration public virtual void SetMaxWidth(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxHeight.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetMaxHeight.html",
    "title": "Method SetMaxHeight",
    "keywords": "Method SetMaxHeight | Improve this Doc View Source SetMaxHeight(FSint) !TODO Declaration public virtual void SetMaxHeight(FSint value) Parameters value FSint | Improve this Doc View Source SetMaxHeight(Nullable<Int32>) !TODO Declaration public virtual void SetMaxHeight(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetToolTip.html",
    "title": "Method SetToolTip",
    "keywords": "Method SetToolTip | Improve this Doc View Source SetToolTip(String) !TODO Declaration public virtual void SetToolTip(string toolTipExtension) Parameters toolTipExtension String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontFamily.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontFamily.html",
    "title": "Method SetFontFamily",
    "keywords": "Method SetFontFamily | Improve this Doc View Source SetFontFamily(String) !TODO Declaration public virtual void SetFontFamily(string family) Parameters family String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontSize.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontSize.html",
    "title": "Method SetFontSize",
    "keywords": "Method SetFontSize | Improve this Doc View Source SetFontSize(FSint) !TODO Declaration public virtual void SetFontSize(FSint size) Parameters size FSint | Improve this Doc View Source SetFontSize(Nullable<Int32>) !TODO Declaration public virtual void SetFontSize(int? size) Parameters size Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontBold.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontBold.html",
    "title": "Method SetFontBold",
    "keywords": "Method SetFontBold | Improve this Doc View Source SetFontBold(FSbool) !TODO Declaration public virtual void SetFontBold(FSbool bold) Parameters bold FSbool | Improve this Doc View Source SetFontBold(Nullable<Boolean>) !TODO Declaration public virtual void SetFontBold(bool? bold) Parameters bold Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontItalic.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontItalic.html",
    "title": "Method SetFontItalic",
    "keywords": "Method SetFontItalic | Improve this Doc View Source SetFontItalic(FSbool) !TODO Declaration public virtual void SetFontItalic(FSbool italic) Parameters italic FSbool | Improve this Doc View Source SetFontItalic(Nullable<Boolean>) !TODO Declaration public virtual void SetFontItalic(bool? italic) Parameters italic Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html",
    "title": "Class FlavorType",
    "keywords": "Class FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. Inheritance Object FlavorType Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static class FlavorType Remarks Diese Klasse stellt primär Konstanten für alle von Framework Studio bekannten Datenformate zur Verfügung. Die Konstanten sind vom Typ String. So kann das externe Transferobjekt grundsätzlich auch unbekannte Datenformate unterstützen. Fields FileList Stellt Dateien dar. Image Stellt ein Bild dar. TextHtml Stellt Text im HTML-Format dar. TextPlain Stellt unformatierten Text dar. TextRtf Stellt Text im RTF-Format dar. TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. TextXml Stellt Text im XML-Format dar. Methods IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist."
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.MLKey.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.MLKey.html",
    "title": "Property MLKey",
    "keywords": "Property MLKey | Improve this Doc View Source MLKey Der mit dem MLKeyText übergebene MLKey. Declaration public MLKey MLKey { get; } Property Value MLKey"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html",
    "title": "Class FrameworkApplicationException",
    "keywords": "Class FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. Inheritance Object Exception ApplicationException FrameworkApplicationException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class FrameworkApplicationException : ApplicationException, ISerializable, _Exception Constructors FrameworkApplicationException(MLKeyText) FrameworkApplicationException(MLKeyText, Exception) FrameworkApplicationException(MLKeyText, Int32) FrameworkApplicationException(MLKeyText, Int32, Exception) FrameworkApplicationException(String) FrameworkApplicationException(String, Exception) FrameworkApplicationException(String, Int32) FrameworkApplicationException(String, Int32, Exception) Properties MLKey Der mit dem MLKeyText übergebene MLKey. Severity Definiert den Schweregrad der Exception."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text | Improve this Doc View Source Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde. Declaration public virtual string Text { get; protected set; } Property Value String Remarks Lediglich die Texte in den Formaten TextPlain und TextUriList werden schon im OnCanDrop gefüllt."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html",
    "title": "Class TextFlavorData",
    "keywords": "Class TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. Inheritance Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class TextFlavorData : FlavorData Remarks In einem Drag&Drop-Vorgang können mehrere TextFlavorData Objekte (zu unterschiedlichen Textformaten) enthalten sein. Properties Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html",
    "title": "Method GetSupportedFlavorTypes",
    "keywords": "Method GetSupportedFlavorTypes | Improve this Doc View Source GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedFlavorTypes() Returns IEnumerable < String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html",
    "title": "Method GetSupportedTextFlavorTypes",
    "keywords": "Method GetSupportedTextFlavorTypes | Improve this Doc View Source GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedTextFlavorTypes() Returns IEnumerable < String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html",
    "title": "Method IsFlavorTypeSupported",
    "keywords": "Method IsFlavorTypeSupported | Improve this Doc View Source IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können. Declaration public bool IsFlavorTypeSupported(string flavorType) Parameters flavorType String Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html",
    "title": "Method GetFlavorData",
    "keywords": "Method GetFlavorData | Improve this Doc View Source GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . Declaration public FlavorData GetFlavorData(string flavorType) Parameters flavorType String Returns FlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html",
    "title": "Method GetTextFlavorData",
    "keywords": "Method GetTextFlavorData | Improve this Doc View Source GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . Declaration public TextFlavorData GetTextFlavorData(string textFlavorType) Parameters textFlavorType String Returns TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html",
    "title": "Method GetBestTextFlavorType",
    "keywords": "Method GetBestTextFlavorType | Improve this Doc View Source GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. Declaration public string GetBestTextFlavorType() Returns String Remarks Zu dem Daten zur Verfügung gestellt werden: TextXml TextHtml TextUriList TextPlain Ein unbekanntes Textformat, soweit eines unterstützt wird null , falls gar kein Textformat unterstützt wird"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html",
    "title": "Method GetBestTextFlavorData",
    "keywords": "Method GetBestTextFlavorData | Improve this Doc View Source GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. Declaration public TextFlavorData GetBestTextFlavorData() Returns TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html",
    "title": "Method GetImageFlavorData",
    "keywords": "Method GetImageFlavorData | Improve this Doc View Source GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . Declaration public ImageFlavorData GetImageFlavorData() Returns ImageFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html",
    "title": "Method GetFileListFlavorData",
    "keywords": "Method GetFileListFlavorData | Improve this Doc View Source GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . Declaration public FileListFlavorData GetFileListFlavorData() Returns FileListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html",
    "title": "Method GetUriListFlavorData",
    "keywords": "Method GetUriListFlavorData | Improve this Doc View Source GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . Declaration public UriListFlavorData GetUriListFlavorData() Returns UriListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html",
    "title": "Class ExternalTransferObject",
    "keywords": "Class ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. Inheritance Object ExternalTransferObject Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ExternalTransferObject Remarks Die Klasse bietet Methoden, mit denen ermittelt werden kann, welche FlavorTypes ( FlavorType ) unterstützt werden, also in welchen Formaten Daten zur Verfügung stehen. Außerdem können zu jedem FlavorType die entsprechenden Daten ( FlavorData ) abgefragt werden. In den Events OnCanDrop und OnDrop kann eindeutig erkannt werden, ob es sich um einen internen oder einen externen Drag&Drop-Vorgang handelt, indem überprüft wird, ob das TransferObject vom Typ ExternalTransferObject ist. Examples ExternalTransferObject oExternalTransferObject = e.TransferObject as ExternalTransferObject; if (oExternalTransferObject != null) { // Drag&Drop-Vorgang von außerhalb der Applikation } else { // Drag&Drop-Vorgang innerhalb der Applikation } Methods GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Die Caption wird auf das Bild geblendet, und zwar an der Position, die Sie unter CaptionAlign angegeben haben. Ist ihre Grafik selbsterklärend, können Sie die Caption frei lassen. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ButtonBaseDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.html",
    "title": "Class ImageButtonDesignViewModel",
    "keywords": "Class ImageButtonDesignViewModel Diese Klasse repräsentiert das Control ImageButton . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ImageButtonDesignViewModel Inherited Members ButtonBaseDesignViewModel.MapEnterToTabAction ButtonBaseDesignViewModel.Shortcut ButtonBaseDesignViewModel.ShowCaption ButtonBaseDesignViewModel.IsSearchButton ButtonBaseDesignViewModel.LoadAtComponent ButtonBaseDesignViewModel.SearchValuesComponent ButtonBaseDesignViewModel.ContextMenu ButtonBaseDesignViewModel.OnClick ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ImageButtonDesignViewModel : ButtonBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Die Caption wird auf das Bild geblendet, und zwar an der Position, die Sie unter CaptionAlign angegeben haben. Ist ihre Grafik selbsterklärend, können Sie die Caption frei lassen. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. CaptionAlign Ausrichtung des Textes auf dem Image-Button. DisabledImage Gibt das Bild an, das angezeigt werden soll, wenn der Button disabled ist. Die URL kann einen relativen (zum Applikations-Verzeichnis) oder einen absoluten Pfad darstellen. Über die Drop- Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Image Gibt das Bild an, das im Normalzustand angezeigt werden soll. MouseOverImage Gibt das Bild an, das angezeigt werden soll, wenn der Mauszeiger sich über dem Image-Button befindet. PressedImage Gibt das Bild an, das angezeigt werden soll, wenn der Image-Button gedrückt wird. See Also ImageButtonControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption | Improve this Doc View Source ShowCaption Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Klick auf das Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkCheckBoxClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkCheckBoxClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.CheckBoxDesignViewModel.html",
    "title": "Class CheckBoxDesignViewModel",
    "keywords": "Class CheckBoxDesignViewModel Diese Klasse repräsentiert das Control CheckBox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel CheckBoxDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class CheckBoxDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ShowCaption Events OnClick Wird bei einem Klick auf das Control ausgelöst. See Also CheckboxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.TypeName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.TypeName.html",
    "title": "Property TypeName",
    "keywords": "Property TypeName | Improve this Doc View Source TypeName !TODO Declaration public override string TypeName { get; } Property Value String Overrides FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ControlTreeNode.TypeName"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonDesignViewModel.html",
    "title": "Class ButtonDesignViewModel",
    "keywords": "Class ButtonDesignViewModel Diese Klasse repräsentiert das Control Button . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel Inherited Members ButtonBaseDesignViewModel.Caption ButtonBaseDesignViewModel.MapEnterToTabAction ButtonBaseDesignViewModel.Shortcut ButtonBaseDesignViewModel.ShowCaption ButtonBaseDesignViewModel.IsSearchButton ButtonBaseDesignViewModel.LoadAtComponent ButtonBaseDesignViewModel.SearchValuesComponent ButtonBaseDesignViewModel.ContextMenu ButtonBaseDesignViewModel.OnClick ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ButtonDesignViewModel : ButtonBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties TypeName !TODO See Also ButtonControlAction"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewSelectionMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewSelectionMode.html",
    "title": "Enum ListViewSelectionMode",
    "keywords": "Enum ListViewSelectionMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewSelectionMode Fields Name Description Multiple Es können mehrere ListItems gleichzeitig selektiert werden None ListItems können nicht selektiert werden. Single Es kann immer nur ein einziges ListItem gleichzeitig selektiert werden."
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Cancelled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Cancelled.html",
    "title": "Property Cancelled",
    "keywords": "Property Cancelled | Improve this Doc View Source Cancelled true wenn der Scanvorgang am Client abgebrochen wurde Declaration bool Cancelled { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.HasError.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError | Improve this Doc View Source HasError true wenn beim Scanvorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Declaration bool HasError { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.ErrorMessage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage | Improve this Doc View Source ErrorMessage Fehlermeldung bei einem gescheiterten Scanvorgang Declaration string ErrorMessage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Value.html",
    "title": "Property Value",
    "keywords": "Property Value | Improve this Doc View Source Value Der Wert des gescannten Barcodes Declaration string Value { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Format.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Format.html",
    "title": "Property Format",
    "keywords": "Property Format | Improve this Doc View Source Format Das Format des gescannten Barcodes. NONE , wenn kein Barcode gescannt wurde. Declaration BarcodeFormat Format { get; } Property Value BarcodeFormat"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Identifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier | Improve this Doc View Source Identifier Der in der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) übergebene Wert, sonst null . Declaration string Identifier { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkBarcodeScanInfo.html",
    "title": "Interface IFrameworkBarcodeScanInfo",
    "keywords": "Interface IFrameworkBarcodeScanInfo Eine Instanz dieses Typs wird nach einem mit der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat) ausgelösten Scan-Vorgang der Callback-Methode übergeben. Sie beinhaltet die Ergebisse des Scan-Vorgangs. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkBarcodeScanInfo Properties Cancelled true wenn der Scanvorgang am Client abgebrochen wurde ErrorMessage Fehlermeldung bei einem gescheiterten Scanvorgang Format Das Format des gescannten Barcodes. NONE , wenn kein Barcode gescannt wurde. HasError true wenn beim Scanvorgang ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Identifier Der in der Action ScanBarcode(Action<IFrameworkBarcodeScanInfo>, BarcodeFormat, String) übergebene Wert, sonst null . Value Der Wert des gescannten Barcodes"
  },
  "api/FrameworkSystems.FrameworkBase.FromControlWrapperProcessedState.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FromControlWrapperProcessedState.html",
    "title": "Enum FromControlWrapperProcessedState",
    "keywords": "Enum FromControlWrapperProcessedState Verarbeitungsstatus der in einem Grid verwendeten Objekte Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FromControlWrapperProcessedState Fields Name Description ProcessedChanged ProcessedDeleted ProcessedNew ProcessedUnchanged Unprocessed"
  },
  "api/FrameworkSystems.FrameworkBase.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkBase.EditorStyle.html",
    "title": "Enum EditorStyle",
    "keywords": "Enum EditorStyle Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum EditorStyle Fields Name Description CheckBox ComboBox Editfield MultilineEditfield"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Horizontal.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Horizontal.html",
    "title": "Property Horizontal",
    "keywords": "Property Horizontal | Improve this Doc View Source Horizontal Declaration public H? Horizontal { get; set; } Property Value Nullable <H>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeHorizontal.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeHorizontal.html",
    "title": "Method ShouldSerializeHorizontal",
    "keywords": "Method ShouldSerializeHorizontal | Improve this Doc View Source ShouldSerializeHorizontal() Declaration public bool ShouldSerializeHorizontal() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Vertical.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Vertical.html",
    "title": "Property Vertical",
    "keywords": "Property Vertical | Improve this Doc View Source Vertical Declaration public V? Vertical { get; set; } Property Value Nullable <V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeVertical.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShouldSerializeVertical.html",
    "title": "Method ShouldSerializeVertical",
    "keywords": "Method ShouldSerializeVertical | Improve this Doc View Source ShouldSerializeVertical() Declaration public bool ShouldSerializeVertical() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShoudldSerialize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ShoudldSerialize.html",
    "title": "Method ShoudldSerialize",
    "keywords": "Method ShoudldSerialize | Improve this Doc View Source ShoudldSerialize() Declaration public bool ShoudldSerialize() Returns Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ToString.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.ToString.html",
    "title": "Method ToString",
    "keywords": "Method ToString | Improve this Doc View Source ToString() Declaration public override string ToString() Returns String Overrides Object.ToString()"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.SetFrom.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.SetFrom.html",
    "title": "Method SetFrom",
    "keywords": "Method SetFrom | Improve this Doc View Source SetFrom(Alignment<H, V>) Declaration public void SetFrom(Alignment<H, V> value) Parameters value Alignment <H, V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.FromString.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.FromString.html",
    "title": "Method FromString",
    "keywords": "Method FromString | Improve this Doc View Source FromString(String) Declaration public static Alignment<H, V> FromString(string value) Parameters value String Returns Alignment <H, V>"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.GetHashCode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.GetHashCode.html",
    "title": "Method GetHashCode",
    "keywords": "Method GetHashCode | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Int32 Overrides Object.GetHashCode()"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Equals.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.Equals.html",
    "title": "Method Equals",
    "keywords": "Method Equals | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object obj) Parameters obj Object Returns Boolean Overrides Object.Equals(Object)"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Alignment-2.html",
    "title": "Class Alignment<H, V>",
    "keywords": "Class Alignment<H, V> Inheritance Object Alignment<H, V> Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class Alignment<H, V> where H : struct where V : struct Type Parameters Name Description H V Properties Horizontal Vertical Methods Equals(Object) FromString(String) GetHashCode() SetFrom(Alignment<H, V>) ShoudldSerialize() ShouldSerializeHorizontal() ShouldSerializeVertical() ToString()"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Classes FrameworkButtonClickEventArgs FrameworkCellDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnCellDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID zugreifen des Parameters der Methode zugreifen. FrameworkCheckBoxClickEventArgs FrameworkColumnChangedEventArgs !TODO FrameworkDoubleClickEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition verknüpfte FormMethod kann somit auf das Property RowID des Parameters der Methode zugreifen. FrameworkEventArgs Alle FormMethod-EventHandler haben als (einziger) Parameter ein Objekt vom Typ FrameworkEventArgs (oder einer Ableitung). FrameworkEventArgs stellt selbst noch keine besondere Funktionalität bereit, dies kann aber von Ableitungen gemacht werden. So ist es möglich, dem EventHandler weitere Informationen zu übergeben. Siehe hierzu FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnRowDoubleClickDefinition . FrameworkOnItemActivatedEventArgs FrameworkOnLeaveEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnLeaveDefinition des Parameters der Methode zugreifen. FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden FrameworkOnReloadEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnReloadDefinition verknüpfte FormMethod kann somit auf die RowList zugreifen FrameworkSelectionChangedEventArgs Enums OnLeaveActivator"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data Enums ComboEditStyle TODO! SearchCompareOperator"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.SearchCompareOperator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.SearchCompareOperator.html",
    "title": "Enum SearchCompareOperator",
    "keywords": "Enum SearchCompareOperator Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.Data Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum SearchCompareOperator Fields Name Description Equal A comparison for equality GreaterThan A comparison for greater than. GreaterThanEqual A comparison for greater than or equal to. LessThan A comparison for less than. LessThanEqual A comparison for less than or equal to. Like NotEqual"
  },
  "api/FrameworkSystems.FrameworkBase.WrapPanelVerticalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.WrapPanelVerticalContentAlignment.html",
    "title": "Enum WrapPanelVerticalContentAlignment",
    "keywords": "Enum WrapPanelVerticalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum WrapPanelVerticalContentAlignment Fields Name Description Bottom Fill Middle Top"
  },
  "api/FrameworkSystems.FrameworkBase.WrapPanelHorizontalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.WrapPanelHorizontalContentAlignment.html",
    "title": "Enum WrapPanelHorizontalContentAlignment",
    "keywords": "Enum WrapPanelHorizontalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum WrapPanelHorizontalContentAlignment Fields Name Description Center Fill Left Right"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.DockPanelControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.DockPanelControlAction.html",
    "title": "Class DockPanelControlAction",
    "keywords": "Class DockPanelControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction DockPanelControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class DockPanelControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.SetEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.SetEditable.html",
    "title": "Method SetEditable",
    "keywords": "Method SetEditable | Improve this Doc View Source SetEditable(Boolean) Schaltet den Bearbeitungsmodus des Steuerelements an( true ) oder aus( false ). Genau dann,wenn der Bearbeitungsmodus angeschalten ist, kann der Benutzer Layout Änderungen vornehmen.Die Features Maximieren/Wiederherstellen sowie Zu-/Aufklappen bleiben davon jedoch unberührt. Declaration public void SetEditable(bool isEditable) Parameters isEditable Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.DashboardContainerControlAction.html",
    "title": "Class DashboardContainerControlAction",
    "keywords": "Class DashboardContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control DashboardContainer angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction DashboardContainerControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class DashboardContainerControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Methods SetEditable(Boolean) Schaltet den Bearbeitungsmodus des Steuerelements an( true ) oder aus( false ). Genau dann,wenn der Bearbeitungsmodus angeschalten ist, kann der Benutzer Layout Änderungen vornehmen.Die Features Maximieren/Wiederherstellen sowie Zu-/Aufklappen bleiben davon jedoch unberührt. See Also DashBoardContainerViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.CheckboxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.CheckboxControlAction.html",
    "title": "Class CheckboxControlAction",
    "keywords": "Class CheckboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Checkbox angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction CheckboxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class CheckboxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also CheckBoxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkBase.PictureScaleMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.PictureScaleMode.html",
    "title": "Enum PictureScaleMode",
    "keywords": "Enum PictureScaleMode used for Picture.ScaleMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum PictureScaleMode Fields Name Description Center In der originalen Größe zentrieren. Inherit Use editor type from base, if base != null, otherwise default editor type Normal Bild oben links zeichnen (ohne Anpassung). ScaleDown ScaleDown Bild, wenn es zu groß ist, proportional herunter skalieren. Kleinere Bilder behalten ihre Größe. ScaleDownCenter Bild, wenn es zu groß ist, proportional herunter skalieren. Kleinere Bilder behalten ihre Größe. Bild in Control zentrieren. Stretch Bild mit beiden Achsen auf die Größe des Controls skalieren. Das ist das Standardverhalten. Zoom Bild proportional vergrößern oder verkleinern, so dass es gerade so in das Control passt. ZoomCenter ZoomCenter Bild proportional vergrößern oder verkleinern, so dass es gerade so in das Control passt und im Control zentrieren."
  },
  "api/FrameworkSystems.FrameworkBase.IGridView.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IGridView.html",
    "title": "Interface IGridView",
    "keywords": "Interface IGridView Ein Grid zeigt immer Daten einer Collection an. Um mit den Daten zu arbeiten, muss auf die Collection zugegriffen werden, die an das entsprechende Grid gebunden ist. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IGridView : IEnumerable<DevFrameworkObject>, IEnumerable Remarks Wenn über den Client die Daten im Grid sortiert oder gefiltert werden, dann stimmt die Reihenfolge der Elemente in der Collection nicht mehr mit der Anzeige überein. Um auf die den Filterkriterien entsprechenden Elemente in der angezeigten Reihenfolge zugreifen zu können, stellt FrameworkStudio einen View zur Verfügung. Dieser kann am Grid mit der Funktion GetView() abgerufen werden: IGridView gridView = this.grdTableXyz.GetView(); IGridView kann zum einen enumeriert werden, also zum Beispiel mit foreach durchlaufen werden. Zum anderen kann über den Index gezielt auf das x-te Element der Collection zugegriffen werden. IGridView arbeitet mit der Basis-Klasse DevFrameworkObject. Ggf. müssen die ermittelten Elemente mit dem entsprechenden Cast in das gewünschte Format konvertiert werden. // Liste durchlaufen foreach(IcdCustomer oCustomer in gridView) { // Satz verarbeiten [...] } // gezielt einen Satz holen, Cast in entsprchenden Typ IcdCustomer oCustomer = (IcdCustomer) gridView[intIndex];"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetEnabled.html",
    "title": "Method SetEnabled",
    "keywords": "Method SetEnabled | Improve this Doc View Source SetEnabled(Nullable<Boolean>) Bestimmt, ob der Button reagiert, also gedrückt werden kann, oder nicht. Declaration public virtual void SetEnabled(bool? value) Parameters value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetFocus.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.SetFocus.html",
    "title": "Method SetFocus",
    "keywords": "Method SetFocus | Improve this Doc View Source SetFocus() Setzt den Fokus auf das entsprechende Control, an dem diese Action ausgeführt wird. Werden in einem Request an den Broker mehrere SetFocus-Actions ausgeführt, gewinnt die letzte. Declaration public virtual void SetFocus()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditableControlAction.html",
    "title": "Class EditableControlAction",
    "keywords": "Class EditableControlAction Summary description for EditableControlAction. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction CheckboxControlAction ComboBoxControlAction DockPanelControlAction EditboxControlAction FieldPanelControlAction GridColumnControlAction GridControlAction ListBoxControlAction ListViewControlAction MainMenuControlAction PictureControlAction RadioButtonControlAction TabbedWindowControlAction TabPageControlAction TemplateControlAction TreeViewControlAction WrapPanelControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class EditableControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable Methods SetEnabled(Nullable<Boolean>) Bestimmt, ob der Button reagiert, also gedrückt werden kann, oder nicht. SetFocus() Setzt den Fokus auf das entsprechende Control, an dem diese Action ausgeführt wird. Werden in einem Request an den Broker mehrere SetFocus-Actions ausgeführt, gewinnt die letzte."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html",
    "title": "Class AccessUnit",
    "keywords": "Class AccessUnit TODO! Inheritance Object AccessUnit Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AccessUnit"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html",
    "title": "Struct FSint",
    "keywords": "Struct FSint TODO! Summary description for FSint. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSint : IFSint, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkComponentState.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkComponentState.html",
    "title": "Enum FrameworkComponentState",
    "keywords": "Enum FrameworkComponentState Status des Objektes. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FrameworkComponentState Fields Name Description Changed Das Objekt wurde verändert und die Änderungen wurden noch nicht gespeichert Deleted Das Objekt wurde gelöscht (und aus der Collection entfernt!) New Das Objekt wurde neu erzeugt, aber noch nicht gespeichert NewButDeleted Das Objekt wurde zwar neu erzeugt aber inzwischen schon wieder gelöscht (und aus der Collection entfernt!) Unchanged Das Objekt wurde seit dem Laden bzw. dem letzten Speichern nicht mehr verändert. UnchangedButDeleted Das Objekt wurde gelöscht und in der Datenbank gespeichert. So gilt er als Unchanged und Deleted"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count | Improve this Doc View Source Count Gibt die Anzahl der enthaltenen Dateien zurück. Declaration public int Count { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator | Improve this Doc View Source GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück. Declaration public IEnumerator<FileFlavorData> GetEnumerator() Returns IEnumerator < FileFlavorData > Examples FileListFlavorData oFileListFlavorData = oExternalTransferObject.GetFileListFlavorData(); foreach (FileFlavorData oFileFlavorData in oFileListFlavorData) { String sFileName = oFileFlavorData.Name; // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html",
    "title": "Class FileListFlavorData",
    "keywords": "Class FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . Inheritance Object FlavorData FileListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileListFlavorData : FlavorData, IEnumerable<FileFlavorData>, IEnumerable Remarks Die Enumeration enthält (auch im Event OnCanDrop ) immer mindestens ein Objekt vom Typ FileFlavorData . Properties Count Gibt die Anzahl der enthaltenen Dateien zurück. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor | Improve this Doc View Source BackColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor | Improve this Doc View Source ForeColor Declaration [TypeConverter(typeof(ColorTypeConverter))] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Font.html",
    "title": "Property Font",
    "keywords": "Property Font | Improve this Doc View Source Font Declaration public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding | Improve this Doc View Source Padding Declaration public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.IconPadding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.IconPadding.html",
    "title": "Property IconPadding",
    "keywords": "Property IconPadding | Improve this Doc View Source IconPadding Declaration public Bounds IconPadding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderColor.html",
    "title": "Property BorderColor",
    "keywords": "Property BorderColor | Improve this Doc View Source BorderColor Declaration [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BorderColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness | Improve this Doc View Source BorderThickness Declaration public Bounds BorderThickness { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.BorderRadius.html",
    "title": "Property BorderRadius",
    "keywords": "Property BorderRadius | Improve this Doc View Source BorderRadius Declaration public BorderRadius BorderRadius { get; set; } Property Value BorderRadius"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.TabTemplate.html",
    "title": "Class TabTemplate",
    "keywords": "Class TabTemplate TODO Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase TabTemplate Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(TabTemplateConverter))] public class TabTemplate : DevDataStyleBase, INotifyPropertyChanged, IFsXmlSerializable Properties BackColor BorderColor BorderRadius BorderThickness Font ForeColor IconPadding Padding"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.-ctor.html",
    "title": "Constructor MLKeyText",
    "keywords": "Constructor MLKeyText | Improve this Doc View Source MLKeyText(MLKey, String) Declaration public MLKeyText(MLKey mLKey, string text) Parameters mLKey MLKey text String"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Key.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Key.html",
    "title": "Property Key",
    "keywords": "Property Key | Improve this Doc View Source Key Declaration public MLKey Key { get; } Property Value MLKey"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Text.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.Text.html",
    "title": "Property Text",
    "keywords": "Property Text | Improve this Doc View Source Text Declaration public string Text { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKeyText.html",
    "title": "Class MLKeyText",
    "keywords": "Class MLKeyText Diese Klasse verpackt einen MLKey und den lokalisierten Text. So ist es möglich mit dem Text auch den MLKey zu transportieren. In der FrameworkApplicationException kann so der MLKey als \"Fehlercode\" verwendet werden. Inheritance Object MLKeyText Namespace : FrameworkSystems.FrameworkExceptions.MultiLanguage Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax public class MLKeyText Remarks Das GlobalObject bietet Methoden, um Texte in Form dieser Klasse zu erhalten: GetMLKeyText(MLKey) FormatMLKeyText(MLKey, Object[]) Constructors MLKeyText(MLKey, String) Properties Key Text"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html",
    "title": "Property ImageByteArray",
    "keywords": "Property ImageByteArray | Improve this Doc View Source ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde. Declaration public byte[] ImageByteArray { get; } Property Value Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html",
    "title": "Class ImageFlavorData",
    "keywords": "Class ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. Inheritance Object FlavorData ImageFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ImageFlavorData : FlavorData Properties ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html",
    "title": "Property UnitKey",
    "keywords": "Property UnitKey | Improve this Doc View Source UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Declaration public string UnitKey { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html",
    "title": "Property Units",
    "keywords": "Property Units | Improve this Doc View Source Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Declaration public IEnumerable<KeyValuePair<string, string>> Units { get; } Property Value IEnumerable < KeyValuePair < String , String >> Remarks KeyValuePair.Key = Schlüsselwert der Unit (Geschäftseinheit) KeyValuePair.Value = Name der Unit"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html",
    "title": "Method Granted",
    "keywords": "Method Granted | Improve this Doc View Source Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. Declaration public bool Granted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit type AUPermissionType Returns Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1, AUPermissionType.Delete ) ) { //Delete granted } if ( this.Global.Granted(AUList.aufrmForm1, AUPermissionType.Insert) ) { //Insert granted } | Improve this Doc View Source Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Declaration public bool Granted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . Returns Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1 ) ) { //Access granted }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html",
    "title": "Method LicenseGranted",
    "keywords": "Method LicenseGranted | Improve this Doc View Source LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. Declaration public bool LicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . type AUPermissionType Eine AUPermissionType Returns Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access } | Improve this Doc View Source LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt Declaration public bool LicenseGranted(AccessUnit accessUnit) Parameters accessUnit AccessUnit Eine AccessUnit aus der AUList . Returns Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html",
    "title": "Method GetPackages",
    "keywords": "Method GetPackages | Improve this Doc View Source GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. Declaration public List<AUHelper.PackageInfo> GetPackages() Returns List < AUHelper.PackageInfo > Remarks Das SystemPackage ist in der Liste nicht enthalten. Die Liste beginnt mit dem DefaultPackage und endet mit dem obersten CustomizingPackage. Die Klasse AUHelper.PackageInfo enthält über ein Package die Informationen ID, Name, Version und Hersteller (Manufacturer)."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html",
    "title": "Method ChangePasswordChecked",
    "keywords": "Method ChangePasswordChecked | Improve this Doc View Source ChangePasswordChecked(String, String, String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, string oldPassword, string newPassword, out AUHelper.Message message, string loginInfo) Parameters username String oldPassword String newPassword String message FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message loginInfo String beliebiger Text, der vom Authentication Service geloggt wird, darf null sein | Improve this Doc View Source ChangePasswordChecked(String, Byte[], String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, byte[] oldHashSign, string newPassword, out AUHelper.Message message, string loginInfo) Parameters username String oldHashSign Byte [] Der Hashwert des alten Passwortes. newPassword String message FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message loginInfo String beliebiger Text, der vom Authentication Service geloggt wird, darf null sein"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html",
    "title": "Method ChangePassword",
    "keywords": "Method ChangePassword | Improve this Doc View Source ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. Declaration public void ChangePassword(string oldPassword, string newPassword) Parameters oldPassword String newPassword String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetAllLanguages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetAllLanguages.html",
    "title": "Method GetAllLanguages",
    "keywords": "Method GetAllLanguages | Improve this Doc View Source GetAllLanguages() Gibt eine Liste mit ISO Kürzeln aller an dieser Applikation bekannten Sprachen zurück. Declaration public List<string> GetAllLanguages() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetGrantedLanguages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetGrantedLanguages.html",
    "title": "Method GetGrantedLanguages",
    "keywords": "Method GetGrantedLanguages | Improve this Doc View Source GetGrantedLanguages() Gibt eine Liste mit ISO Kürzeln der Sprachen zurück, die zur Verfügung stehen und durch die verwendeten Lizenzen freigegeben sind. Declaration public List<string> GetGrantedLanguages() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html",
    "title": "Method GetApplicationRoles",
    "keywords": "Method GetApplicationRoles | Improve this Doc View Source GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles(bool reload) Parameters reload Boolean Mit true wird ein neues Laden der Rollen vom Authentication Service erzwungen. Returns List < String > | Improve this Doc View Source GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html",
    "title": "Method GetUserRoles",
    "keywords": "Method GetUserRoles | Improve this Doc View Source GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. Declaration public List<string> GetUserRoles() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html",
    "title": "Method GetRoleDescription",
    "keywords": "Method GetRoleDescription | Improve this Doc View Source GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleDescription(string roleName) Parameters roleName String Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html",
    "title": "Method GetRoleCaption",
    "keywords": "Method GetRoleCaption | Improve this Doc View Source GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleCaption(string roleName) Parameters roleName String Returns String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html",
    "title": "Method GetUserUnits",
    "keywords": "Method GetUserUnits | Improve this Doc View Source GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Declaration public List<string> GetUserUnits() Returns List < String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html",
    "title": "Method RegisterUnits",
    "keywords": "Method RegisterUnits | Improve this Doc View Source RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service. Declaration public void RegisterUnits(IEnumerable<KeyValuePair<string, string>> units) Parameters units IEnumerable < KeyValuePair < String , String >> Key = unit id / Value = unit name"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html",
    "title": "Class AUHelper",
    "keywords": "Class AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. Inheritance Object AUHelper Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AUHelper Examples this.Global.AUHelper.ChangePassword( sOld, sNew ); Properties AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Methods ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. ChangePasswordChecked(String, Byte[], String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. ChangePasswordChecked(String, String, String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. GetAllLanguages() Gibt eine Liste mit ISO Kürzeln aller an dieser Applikation bekannten Sprachen zurück. GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetGrantedLanguages() Gibt eine Liste mit ISO Kürzeln der Sprachen zurück, die zur Verfügung stehen und durch die verwendeten Lizenzen freigegeben sind. GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyDefaultUser(out AUHelper.Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. IdentifyUser(out AUHelper.Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor | Improve this Doc View Source ForeColor Declaration [Browsable(true)] public Color ForeColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor | Improve this Doc View Source BackColor Declaration [Browsable(true)] public Color BackColor { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Font.html",
    "title": "Property Font",
    "keywords": "Property Font | Improve this Doc View Source Font Declaration [Browsable(true)] public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding | Improve this Doc View Source Padding Declaration [Browsable(true)] public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin | Improve this Doc View Source Margin Declaration [Browsable(true)] public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.RowLabelTemplate.html",
    "title": "Class RowLabelTemplate",
    "keywords": "Class RowLabelTemplate Inheritance Object FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataBase FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Data.DevDataStyleBase ControlLabelTemplateBase RowLabelTemplate Inherited Members ControlLabelTemplateBase.TextAlign ControlLabelTemplateBase.MinSize ControlLabelTemplateBase.MaxSize Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class RowLabelTemplate : ControlLabelTemplateBase, INotifyPropertyChanged, IFsXmlSerializable Properties BackColor Font ForeColor Margin Padding"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.-ctor.html",
    "title": "Constructor MLKey",
    "keywords": "Constructor MLKey | Improve this Doc View Source MLKey(String) Declaration public MLKey(string value) Parameters value String"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.ToString.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.ToString.html",
    "title": "Method ToString",
    "keywords": "Method ToString | Improve this Doc View Source ToString() Liefert den String-Wert des MLKeys. Declaration public override string ToString() Returns String Overrides Object.ToString()"
  },
  "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.MultiLanguage.MLKey.html",
    "title": "Class MLKey",
    "keywords": "Class MLKey Diese Klasse verpackt einen MLKey. Der MLKey besteht aus einem String-Wert. Inheritance Object MLKey Namespace : FrameworkSystems.FrameworkExceptions.MultiLanguage Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax public class MLKey Remarks Warning Bitte einen existierenden MLKey immer über MLKeys... verwenden. Diese Klasse sollte im eigenen Code nicht instanziiert werden. Alle im Wörterbuch enthaltenen MLKeys werden mit den Ressources in eine Klasse MLKeys genriert. über diese kann man im eigenen Code unterstützt durch Intellisense auf jedem MLKey zugreifen. FSstring sArticle = this.Global.GetMLText(MLKeys.LBL_Article); Constructors MLKey(String) Methods ToString() Liefert den String-Wert des MLKeys."
  },
  "api/FrameworkSystems.FrameworkBase.ListViewHorizontalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewHorizontalContentAlignment.html",
    "title": "Enum ListViewHorizontalContentAlignment",
    "keywords": "Enum ListViewHorizontalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewHorizontalContentAlignment Fields Name Description Center Fill Left Right"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.SynchronizeColumns.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.SynchronizeColumns.html",
    "title": "Property SynchronizeColumns",
    "keywords": "Property SynchronizeColumns | Improve this Doc View Source SynchronizeColumns Ist dieser Schalter gesetzt, dann werden die Controls in den FieldRows in Form einer Tabelle angeordnet. Dabei belegen jedes Control und jedes Control-Label genau eine Zelle dieser Tabelle. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? SynchronizeColumns { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.RowLabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.RowLabelTemplate.html",
    "title": "Property RowLabelTemplate",
    "keywords": "Property RowLabelTemplate | Improve this Doc View Source RowLabelTemplate Jede FieldRow besitzt als erstes Control einen “RowLabel-Container”. In ihm wird das erste Control-Label(bzw.beim LabelMode NoneAligned das erste Control der FieldRow) platziert. Hier werden die Einstellungen für diesen RowLabel-Container vorgenommen.Die Einstellungen für die Control-Labels werden an den LabelTemplates der jeweiligen Controls vorgenommen. Mit MinSize und MaxSize kann die Größe des RowLabel-Containers definiert werden.So können die Labels ausgerichtet werden. Beim LabelMode GeneratedMerged werden alle Control-Labels nebeneinander in dem Container platziert.Zwischen den Labels wird ein Separator in Form eines Slash “/” angezeigt.Dessen Layout kann über die Separator-Eigenschaften des RowLabelTemplates gesteuert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public RowLabelTemplate RowLabelTemplate { get; set; } Property Value RowLabelTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldPanelDesignViewModel.html",
    "title": "Class FieldPanelDesignViewModel",
    "keywords": "Class FieldPanelDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LayoutContainerDesignViewModel FieldPanelDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class FieldPanelDesignViewModel : LayoutContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties RowLabelTemplate Jede FieldRow besitzt als erstes Control einen “RowLabel-Container”. In ihm wird das erste Control-Label(bzw.beim LabelMode NoneAligned das erste Control der FieldRow) platziert. Hier werden die Einstellungen für diesen RowLabel-Container vorgenommen.Die Einstellungen für die Control-Labels werden an den LabelTemplates der jeweiligen Controls vorgenommen. Mit MinSize und MaxSize kann die Größe des RowLabel-Containers definiert werden.So können die Labels ausgerichtet werden. Beim LabelMode GeneratedMerged werden alle Control-Labels nebeneinander in dem Container platziert.Zwischen den Labels wird ein Separator in Form eines Slash “/” angezeigt.Dessen Layout kann über die Separator-Eigenschaften des RowLabelTemplates gesteuert werden. SynchronizeColumns Ist dieser Schalter gesetzt, dann werden die Controls in den FieldRows in Form einer Tabelle angeordnet. Dabei belegen jedes Control und jedes Control-Label genau eine Zelle dieser Tabelle."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DisabledBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DisabledBackColor.html",
    "title": "Property DisabledBackColor",
    "keywords": "Property DisabledBackColor | Improve this Doc View Source DisabledBackColor !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? DisabledBackColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Editor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Editor.html",
    "title": "Property Editor",
    "keywords": "Property Editor | Improve this Doc View Source Editor !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TextEditorType? Editor { get; set; } Property Value Nullable < TextEditorType >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Format.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Format.html",
    "title": "Property Format",
    "keywords": "Property Format | Improve this Doc View Source Format !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public FrameworkFormatMask? Format { get; set; } Property Value Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern | Improve this Doc View Source FormatPattern !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string FormatPattern { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Multiline.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.Multiline.html",
    "title": "Property Multiline",
    "keywords": "Property Multiline | Improve this Doc View Source Multiline Gibt an, ob es sich bei dem Editfield um ein Multiline-Field handelt. Wenn ja, sind mehrzeilige Texteingaben und -anzeigen möglich. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiline { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.WordWrap.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.WordWrap.html",
    "title": "Property WordWrap",
    "keywords": "Property WordWrap | Improve this Doc View Source WordWrap Gibt an, ob der automatische Zeilenumbruch aktiviert werden soll. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? WordWrap { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.PasswordChar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.PasswordChar.html",
    "title": "Property PasswordChar",
    "keywords": "Property PasswordChar | Improve this Doc View Source PasswordChar Hier kann ein Zeichen angegeben werden, das bei einer Passworteingabe als Platzhalter angezeigt werden soll, z.B. *. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public char PasswordChar { get; set; } Property Value Char"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign | Improve this Doc View Source TextAlign Gibt an, wie der Text im Editfield ausgerichtet sein soll. Bei Inherit wird die Angabe aus dem Default-Style gezogen. Bei DatatypeDefault werden Strings links und Datum und Nummern rechts ausgerichtet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.ScrollBars.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.ScrollBars.html",
    "title": "Property ScrollBars",
    "keywords": "Property ScrollBars | Improve this Doc View Source ScrollBars Gibt an, ob in dem Editfield Scrollbars angezeigt werden sollen. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [DevBrowsable(true)] public ScrollBars? ScrollBars { get; set; } Property Value Nullable < ScrollBars >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionStart.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionStart.html",
    "title": "Property SelectionStart",
    "keywords": "Property SelectionStart | Improve this Doc View Source SelectionStart Die Startposition der Textauswahl Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectionStart { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionEnd.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.SelectionEnd.html",
    "title": "Property SelectionEnd",
    "keywords": "Property SelectionEnd | Improve this Doc View Source SelectionEnd Die Endposition der Textauswahl Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectionEnd { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Gibt an, mit welcher Membervariable oder welchem Property das Editfield verbunden werden soll. Handelt es sich beim Datasource um ein schreibgeschütztes Property, wird das Property IsEditable auf False gesetzt und lässt sich nicht mehr ändern. Es sind Membervariablen oder Properties vom Typ String, Number (int, short, long...), Date, Boolean möglich. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.OnValidated.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.OnValidated.html",
    "title": "Event OnValidated",
    "keywords": "Event OnValidated Tritt ein, wenn der Fokus von dem Editfeld genommen wird und der Wert geändert wurde. Nach diesem Event wird das OnLeave Event mit Parameter HasValueChanged = true ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnValidated Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.EditboxDesignViewModel.html",
    "title": "Class EditboxDesignViewModel",
    "keywords": "Class EditboxDesignViewModel Diese Klasse repräsentiert das Control EditField . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel EditboxDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class EditboxDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties DataSource Gibt an, mit welcher Membervariable oder welchem Property das Editfield verbunden werden soll. Handelt es sich beim Datasource um ein schreibgeschütztes Property, wird das Property IsEditable auf False gesetzt und lässt sich nicht mehr ändern. Es sind Membervariablen oder Properties vom Typ String, Number (int, short, long...), Date, Boolean möglich. DisabledBackColor !TODO Editor !TODO Format !TODO FormatPattern !TODO Multiline Gibt an, ob es sich bei dem Editfield um ein Multiline-Field handelt. Wenn ja, sind mehrzeilige Texteingaben und -anzeigen möglich. PasswordChar Hier kann ein Zeichen angegeben werden, das bei einer Passworteingabe als Platzhalter angezeigt werden soll, z.B. *. ScrollBars Gibt an, ob in dem Editfield Scrollbars angezeigt werden sollen. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. SelectionEnd Die Endposition der Textauswahl SelectionStart Die Startposition der Textauswahl TextAlign Gibt an, wie der Text im Editfield ausgerichtet sein soll. Bei Inherit wird die Angabe aus dem Default-Style gezogen. Bei DatatypeDefault werden Strings links und Datum und Nummern rechts ausgerichtet. WordWrap Gibt an, ob der automatische Zeilenumbruch aktiviert werden soll. Diese Angabe macht nur Sinn, wenn es sich um ein Multiline-Field handelt. Events OnValidated Tritt ein, wenn der Fokus von dem Editfeld genommen wird und der Wert geändert wurde. Nach diesem Event wird das OnLeave Event mit Parameter HasValueChanged = true ausgelöst. See Also EditboxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemId.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemId.html",
    "title": "Property ItemId",
    "keywords": "Property ItemId | Improve this Doc View Source ItemId Die ID des aktivierten Objekts in der zu Grunde liegenden Collection. Declaration public guid ItemId { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemIndex.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.ItemIndex.html",
    "title": "Property ItemIndex",
    "keywords": "Property ItemIndex | Improve this Doc View Source ItemIndex Der 0-basierte Index des aktivierten Objekts in der Collection. Declaration public int ItemIndex { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnItemActivatedEventArgs.html",
    "title": "Class FrameworkOnItemActivatedEventArgs",
    "keywords": "Class FrameworkOnItemActivatedEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkOnItemActivatedEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnItemActivatedEventArgs : FrameworkEventArgs Properties ItemId Die ID des aktivierten Objekts in der zu Grunde liegenden Collection. ItemIndex Der 0-basierte Index des aktivierten Objekts in der Collection."
  },
  "api/FrameworkSystems.FrameworkBase.StackPanelOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StackPanelOrientation.html",
    "title": "Enum StackPanelOrientation",
    "keywords": "Enum StackPanelOrientation Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum StackPanelOrientation Fields Name Description Horizontal Vertical"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html",
    "title": "Enum FrameworkFormatMask",
    "keywords": "Enum FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben) Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FrameworkFormatMask Fields Name Description DateOnlyLong DateOnlyMedium DateOnlyShort DateTimeLong DateTimeMedium DateTimeShort Decimal Integer LowerCase NegativeInteger None PositiveInteger TimeOnlyLong TimeOnlyMedium TimeOnlyShort UpperCase UserDefined"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption | Improve this Doc View Source ShowCaption !TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.IsSearchButton.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.IsSearchButton.html",
    "title": "Property IsSearchButton",
    "keywords": "Property IsSearchButton | Improve this Doc View Source IsSearchButton Gibt an, ob es sich bei dem Button um einen Such-Button handelt. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [Browsable(true)] public bool? IsSearchButton { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.LoadAtComponent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.LoadAtComponent.html",
    "title": "Property LoadAtComponent",
    "keywords": "Property LoadAtComponent | Improve this Doc View Source LoadAtComponent Gibt die Component an, an welcher der Load ausgeführt werden soll (dies kann auch eine Collection sein). (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [DevBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource LoadAtComponent { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.SearchValuesComponent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.SearchValuesComponent.html",
    "title": "Property SearchValuesComponent",
    "keywords": "Property SearchValuesComponent | Improve this Doc View Source SearchValuesComponent Gibt die Component an, aus der die Load-Condition erzeugt werden soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [DevBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SearchValuesComponent { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ContextMenu.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.ContextMenu.html",
    "title": "Property ContextMenu",
    "keywords": "Property ContextMenu | Improve this Doc View Source ContextMenu Gibt an, welches Kontextmenü geöffnet werden soll, wenn der Button betätigt wird. Ist ein Kontextmenü zugeordnet, so wird das Event OnClick nicht ausgelöst Declaration [Browsable(true)] [TypeConverter(typeof(RecordsConverter))] public DevControlMainMenuRecord ContextMenu { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.DevControlMainMenuRecord See Also ContextMenuDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Klick auf das Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ButtonBaseDesignViewModel.html",
    "title": "Class ButtonBaseDesignViewModel",
    "keywords": "Class ButtonBaseDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ButtonBaseDesignViewModel ButtonDesignViewModel ImageButtonDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ButtonBaseDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Gibt die Beschriftung des Buttons in den definierten Sprachen an. Siehe auch Caption in ControlDesignViewModel ContextMenu Gibt an, welches Kontextmenü geöffnet werden soll, wenn der Button betätigt wird. Ist ein Kontextmenü zugeordnet, so wird das Event OnClick nicht ausgelöst IsSearchButton Gibt an, ob es sich bei dem Button um einen Such-Button handelt. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) LoadAtComponent Gibt die Component an, an welcher der Load ausgeführt werden soll (dies kann auch eine Collection sein). (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) MapEnterToTabAction !TODO SearchValuesComponent Gibt die Component an, aus der die Load-Condition erzeugt werden soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Shortcut Legt ein Tastenkürzel(Tastenkombination) für den schnellen Zugriff auf den Button fest.Wird die hinterlegte Tastenkombination in der erstellten Anwendung gedrückt, so wird das OnClick-Event des Buttons ausgelöst. Inherited(Bei der Auswahl dieses Wertes wird die Einstellung gelöscht und der Wert aus der Basis-Klasse oder den Default Control Styles gezogen) None(keine zugeordnet) ShowCaption !TODO Events OnClick Wird bei einem Klick auf das Control ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BrowserMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BrowserMode.html",
    "title": "Property BrowserMode",
    "keywords": "Property BrowserMode | Improve this Doc View Source BrowserMode Gibt an, ob der Browser-Mode ausgewählt wurde. Der Browser-Mode ist zur Anzeige von Webseiten geeignet und verfügt über eine Adresszeile. Die in die Adresszeile eingegebene URL wird durch den LoadPageButton geladen.Das Laden der Seite kann durch den CancelButton abgebrochen und über den ReloadPageButton neu gestartet werden. Außerdem verfügt der Browser-Mode über Buttons, mit denen eine Vorwärts- und Rückwärtsnavigation möglich ist. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? BrowserMode { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowStatusBar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowStatusBar.html",
    "title": "Property ShowStatusBar",
    "keywords": "Property ShowStatusBar | Improve this Doc View Source ShowStatusBar Gibt an, ob die Statusleiste (Ladestatus der aktuellen Seite + MouseOver Link) angezeigt wird. Die Statusleiste wird nur in Verbindung mit dem BrowserMode angezeigt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowStatusBar { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowZoomBar.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ShowZoomBar.html",
    "title": "Property ShowZoomBar",
    "keywords": "Property ShowZoomBar | Improve this Doc View Source ShowZoomBar Gibt an, ob die Leiste zur Änderung der Größe des Inhalts im Browser angezeigt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowZoomBar { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Content.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Content.html",
    "title": "Property Content",
    "keywords": "Property Content | Improve this Doc View Source Content Über den Datasource Content können Inhalte wie z.B. HTML-Content oder der Pfad zu einer Datei, die im Browser angezeigt werden soll, an den Client übertragen werden. Der Datasource ist unidirektional(nur von Broker zu Client) und hat höhere Priorität als Url. Ressourcen können mit fsbroker://RelativerPfad angezeigt oder verwendet werden. Mit der Funktion CreateRessourcesUrl( ) der Klasse BrowserCommand kann eine Broker-Url erstellt werden. Diese Url kann dann, wie in dem nachfolgenden Beispiel, in Verbindung mit HTML als Link zu einer Datei verwendet warden: Declaration [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Content { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Url.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.Url.html",
    "title": "Property Url",
    "keywords": "Property Url | Improve this Doc View Source Url Mit dem Datasource Url können Webseiten, die im Browser angezeigt werden sollen, an den Client übertragen werden. Der Datasource ist unidirektional (nur von Broker zu Client). Declaration [Browsable(true)] [ControlStylesBrowsable(false)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource Url { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.BackwardButtonIcon.html",
    "title": "Property BackwardButtonIcon",
    "keywords": "Property BackwardButtonIcon | Improve this Doc View Source BackwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string BackwardButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.CancelButtonIcon.html",
    "title": "Property CancelButtonIcon",
    "keywords": "Property CancelButtonIcon | Improve this Doc View Source CancelButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string CancelButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.BrowserDesignViewModel.ForwardButtonIcon.html",
    "title": "Property ForwardButtonIcon",
    "keywords": "Property ForwardButtonIcon | Improve this Doc View Source ForwardButtonIcon Pfad zu einem Icon, das für den jeweiligen Button Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ForwardButtonIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.DevTextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevTextAlign.html",
    "title": "Enum DevTextAlign",
    "keywords": "Enum DevTextAlign Gibt die Ausrichtung des Textes an. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum DevTextAlign Fields Name Description Center Zentriert DatatypeDefault Inherit Erbt von Vater-Control Left Linksbündig Right Rechtsbündig"
  },
  "api/FrameworkSystems.FrameworkBase.BarcodeFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BarcodeFormat.html",
    "title": "Enum BarcodeFormat",
    "keywords": "Enum BarcodeFormat Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Flags] public enum BarcodeFormat Fields Name Description ALL Es werden alle Barcode-Formate unterstützt. AZTEC CODABAR CODE_128 CODE_39 CODE_93 DATA_MATRIX EAN_13 EAN_8 ITF NONE Der Scan-Vorgang hat keinen Barcode ermittelt. PDF_417 QR_CODE UPC_A UPC_E"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.DockPanelOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.DockPanelOrientation.html",
    "title": "Property DockPanelOrientation",
    "keywords": "Property DockPanelOrientation | Improve this Doc View Source DockPanelOrientation Horizontal: Die Controls werden nebeneinander platziert. Vertical: Die Controls werden übereinander platziert. HorizontalOrVertical: Die Controls werden nebeneinander platziert. Reicht der Platz nicht aus, „klappt“ das DockPanel auf die Seite und die Controls werden übereinander platziert. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DockPanelOrientation? DockPanelOrientation { get; set; } Property Value Nullable < DockPanelOrientation >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.DockPanelDesignViewModel.html",
    "title": "Class DockPanelDesignViewModel",
    "keywords": "Class DockPanelDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LayoutContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.SpaceableContainerDesignViewModel DockPanelDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class DockPanelDesignViewModel : SpaceableContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties DockPanelOrientation Horizontal: Die Controls werden nebeneinander platziert. Vertical: Die Controls werden übereinander platziert. HorizontalOrVertical: Die Controls werden nebeneinander platziert. Reicht der Platz nicht aus, „klappt“ das DockPanel auf die Seite und die Controls werden übereinander platziert."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.PastePlainText.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.PastePlainText.html",
    "title": "Method PastePlainText",
    "keywords": "Method PastePlainText | Improve this Doc View Source PastePlainText(String) Diese Action fügt den angegebenen (unformatierten) Text in einem Editfield an die aktuelle Cursorposition ein. Wenn im Control Text markiert ist, wird dieser durch den angegebenen Text ersetzt. Dadurch kann insbesondere in mehrzeiligen Textfeldern Text durch die Businesslogik an der aktuellen Position eingefügt werden, ohne dass der neue Text unter Verwendung der Datasources SelectionStart und SelectionEnd manuell zusammengesetzt werden muss. Declaration public virtual void PastePlainText(string plainText) Parameters plainText String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLength.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLength.html",
    "title": "Method SetDisplayMinLength",
    "keywords": "Method SetDisplayMinLength | Improve this Doc View Source SetDisplayMinLength(FSint) !TODO Declaration public void SetDisplayMinLength(FSint value) Parameters value FSint | Improve this Doc View Source SetDisplayMinLength(Nullable<Int32>) !TODO Declaration public void SetDisplayMinLength(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLength.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLength.html",
    "title": "Method SetDisplayMaxLength",
    "keywords": "Method SetDisplayMaxLength | Improve this Doc View Source SetDisplayMaxLength(FSint) !TODO Declaration public void SetDisplayMaxLength(FSint value) Parameters value FSint | Improve this Doc View Source SetDisplayMaxLength(Nullable<Int32>) !TODO Declaration public void SetDisplayMaxLength(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLines.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMinLines.html",
    "title": "Method SetDisplayMinLines",
    "keywords": "Method SetDisplayMinLines | Improve this Doc View Source SetDisplayMinLines(FSint) !TODO Declaration public void SetDisplayMinLines(FSint value) Parameters value FSint | Improve this Doc View Source SetDisplayMinLines(Nullable<Int32>) !TODO Declaration public void SetDisplayMinLines(int? value) Parameters value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLines.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SetDisplayMaxLines.html",
    "title": "Method SetDisplayMaxLines",
    "keywords": "Method SetDisplayMaxLines | Improve this Doc View Source SetDisplayMaxLines(FSint) !TODO Declaration public void SetDisplayMaxLines(FSint value) Parameters value FSint"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SelectAllText.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.SelectAllText.html",
    "title": "Method SelectAllText",
    "keywords": "Method SelectAllText | Improve this Doc View Source SelectAllText() Diese Action selektiert den kompletten Text des Editfields. Sie ist gedacht für Multiline Editfields, weil diese im Gegensatz zu normalen Editfields nicht den Text selektieren, wenn im Java-Client der Fokus in das Feld gesetzt wird. Idealerweise erfolgt der Aufruf dieser Action im OnEnter- Event des Editfields. Declaration public virtual void SelectAllText()"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.EditboxControlAction.html",
    "title": "Class EditboxControlAction",
    "keywords": "Class EditboxControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control EditField angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction EditboxControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class EditboxControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable Methods PastePlainText(String) Diese Action fügt den angegebenen (unformatierten) Text in einem Editfield an die aktuelle Cursorposition ein. Wenn im Control Text markiert ist, wird dieser durch den angegebenen Text ersetzt. Dadurch kann insbesondere in mehrzeiligen Textfeldern Text durch die Businesslogik an der aktuellen Position eingefügt werden, ohne dass der neue Text unter Verwendung der Datasources SelectionStart und SelectionEnd manuell zusammengesetzt werden muss. SelectAllText() Diese Action selektiert den kompletten Text des Editfields. Sie ist gedacht für Multiline Editfields, weil diese im Gegensatz zu normalen Editfields nicht den Text selektieren, wenn im Java-Client der Fokus in das Feld gesetzt wird. Idealerweise erfolgt der Aufruf dieser Action im OnEnter- Event des Editfields. SetDisplayMaxLength(FSint) !TODO SetDisplayMaxLength(Nullable<Int32>) !TODO SetDisplayMaxLines(FSint) !TODO SetDisplayMinLength(FSint) !TODO SetDisplayMinLength(Nullable<Int32>) !TODO SetDisplayMinLines(FSint) !TODO SetDisplayMinLines(Nullable<Int32>) !TODO See Also EditboxDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.ObjectRowID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.ObjectRowID.html",
    "title": "Property ObjectRowID",
    "keywords": "Property ObjectRowID | Improve this Doc View Source ObjectRowID Eindeutige ID vom Typ guid des Objektes. Declaration guid ObjectRowID { get; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.State.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.State.html",
    "title": "Property State",
    "keywords": "Property State | Improve this Doc View Source State Status des IDevFrameworkObjects vom Typ FrameworkComponentState Declaration FrameworkComponentState State { get; set; } Property Value FrameworkComponentState"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.StateBeforeUpdate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.StateBeforeUpdate.html",
    "title": "Property StateBeforeUpdate",
    "keywords": "Property StateBeforeUpdate | Improve this Doc View Source StateBeforeUpdate !TODO Declaration FrameworkComponentState StateBeforeUpdate { get; set; } Property Value FrameworkComponentState"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObject.html",
    "title": "Interface IDevFrameworkObject",
    "keywords": "Interface IDevFrameworkObject Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IDevFrameworkObject : IDevFrameworkBaseObject, FrameworkDataTransaction.ISource Remarks Alle Business-Objekte, die im Developement Framework verwendet werden sollen, müssen dieses Interface einbinden. Properties ObjectRowID Eindeutige ID vom Typ guid des Objektes. State Status des IDevFrameworkObjects vom Typ FrameworkComponentState StateBeforeUpdate !TODO"
  },
  "doc/themes/zwischen-themes-wechseln.html": {
    "href": "doc/themes/zwischen-themes-wechseln.html",
    "title": "Zwischen Themes wechseln",
    "keywords": "Zwischen Themes wechseln Sind im aktuellen Package oder in dessen Basis-Packages Themes definiert (und nicht auf Deprecated gesetzt) kann das aktive Theme über das Menü Tools > Choose Theme ausgewählt werden. Note Wird Framework Studio neu gestartet, wird IMMER das Default-Theme geladen. Menü zur Auswahl des aktiven Themes: Wenn das aktive Package über ein oder mehrere Basis-Packages verfügt, in denen auch Themes definiert sind, werden diese mit dem jeweiligen Package Namen angezeigt. Themes aus Basis-Packages: Das aktuell aktive Theme wird auch rechts in der Framework Studio Statusleiste angezeigt. Anzeige des aktiven Themes:"
  },
  "doc/themes/verwalten.html": {
    "href": "doc/themes/verwalten.html",
    "title": "Verwalten",
    "keywords": "Verwalten Die Themes werden über den Theme Manager verwaltet. Dieser kann über das Menü Tools > Manage Themes aufgerufen werden. In der Liste werden alle verfügbaren Themes angezeigt. Sind Themes in einem oder mehreren Basis-Packages des aktuellen Packages definiert, werden diese mit dem jeweiligen Packagenamen in Klammern angezeigt, können aber nicht geändert werden. Menü: Über den Button wird ein neues Theme angelegt werden. Neue Themes erhalten ein (+) -Zeichen. Nur neu angelegte Themes können ohne die Aufräum-Routine gelöscht werden. Mit werden alle Änderungen gespeichert. Neue Themes mit (+) werden dann persistent gespeichert und können dann nur noch über die Aufräum-Routine gelöscht werden. Mit können noch nicht persistent gespeicherte Themes (mit (+) ) wieder gelöscht werden. Mit kann die Aufräum-Routine angestoßen werden. Properties: ID: Die ID wird beim Anlegen eines Themes generiert und ist eindeutig. Name: Name des Themes. Kann auch im Nachhinein noch geändert werden, da die Themes über die ID identifiziert werden. Der Name darf maximal 20 Zeichen lang sein. Deprecated: Wird ein Theme auf „Deprecated“ gesetzt, steht es in der Theme-Auswahl nicht mehr zur Verfügung. Es wird zudem auch bei Publish-Vorgängen nicht mehr beachtet. Deprecated gilt somit als Vorstufe zum Löschen des Themes mittels der Aufräum-Routine (siehe Aufräum-Routine ). Caution Sind in einem Package Themes auf Deprecated gesetzt, werden diese von der Aufräum-Routine endgültig aus dem Package gelöscht. Für Packages, die auf dem Package aufsetzen, in dem das Theme definiert war, ist das Theme dann auch nicht mehr verfügbar."
  },
  "doc/themes/themeable-properties.html": {
    "href": "doc/themes/themeable-properties.html",
    "title": "Themeable Properties",
    "keywords": "Themeable Properties Um der Anwendung ein anderes Aussehen zu geben, können folgende Elemente auf Theme-Ebene angepasst werden: Applications Default Control Styles Resources (nur Bilder) Im Folgenden werden die verschiedenen Properties dieser Elemente aufgelistet, die im Rahmen eines Themes verändert werden können: Themeable Application Properties BackImage FocusHighlightColor Icon IsTransparent MenuBackColor MenuBackColorAlpha MenuItemBackColor MenuItemBackColorAlpha SplitterBackColor SplitterBackColorAlpha StartImage Themeable Default Control Styles Für jeden Default Control Style BackColor ForeColor Font IsEditable IsVisible IsTransparent EditField DisableBackColor TextAlign ImageButton CaptionAlign ScaleMode Picture ContentAlignment PictureScaleMode TabbedWindow TabAlignment TabLayout TreeView IsBorderVisible IsFirstExpandIconVisible IsHeaderVisible Themeable Resource Property Da Bilder die einzigen Ressourcen sind, die durch Themes angepasst werden können, ist auch das einzige Property, welches anpassbar ist, das Bild, welches die Resource definiert."
  },
  "doc/themes/properties-theme-abhaengig-aendern.html": {
    "href": "doc/themes/properties-theme-abhaengig-aendern.html",
    "title": "Properties Theme-abhängig ändern",
    "keywords": "Properties Theme-abhängig ändern Um in Applications oder Default Control Styles Properties Theme-abhängig ändern zu können, muss nur das entsprechende Theme ausgewählt werden. Wird nun ein Property modifiziert, wird die Information automatisch dem aktuell aktiven Theme zugeordnet. Properties ändern bei Applications Beispiel Wurde vom Benutzer kein Theme ausgewählt (d.h. das Default-Theme ist aktiv), sieht die FSDemoApplication im Design-Panel wie folgt aus: Application PropertyGrid im Default-Theme: Ein BackImage wurde definiert, IsTransparent aktiviert, SplitterBackColor und die Farben für Menüs wurden modifiziert. Wird nun ein anderes Theme (über Tools > Choose Theme ) ausgewählt, werden die Properties, bezogen auf das nun ausgewählte Theme, angezeigt und können geändert werden: Application PropertyGrid im angepassten Theme: Im Gegensatz zum Default-Theme wurde hier ein anderes BackImage definiert. Das Property „FocusHighlightColor“ ist auf einen Gelbton abgeändert worden (im Default-Theme war hier nichts definiert). Auch die SplitterBackColor wurde neu zugewiesen. Properties ändern bei Default Control Styles Das Theme-abhängige Modifizieren von Properties eines Default Control Styles gestaltet sich analog zu den Applications: Beispiel Im Folgenden wird der Default Control Style des Button-Controls angezeigt, während der Benutzer das Default-Theme ausgewählt hat: DefaultControlStyle PropertyGrid im Default-Theme: Die BackColor wurde auf ButtonFace , die Font auf Arial; 12pt und die ForeColor auf Red gesetzt. Wird nun wiederrum ein Theme ausgewählt, könnten die Properties z.B. wie folgt umdefiniert werden: DefaultControlStyle PropertyGrid im angepassten Theme: Bild ändern bei Ressourcen Ist das Default-Theme aktiv, kann ein Bild über den Button Import File an die Resource gebunden werden. Der Name der Resource wird dabei standardmäßig auf den Namen der importierten Datei angepasst: Bild-Resource im Default-Theme: Wird nun ein Theme vom Benutzer ausgewählt, hat der Benutzer die Möglichkeit über den Button Import File erneut eine Bilddatei zu importieren. Diese wird dann jedoch dem Theme zugeordnet und das Bild des Default-Themes (der graue Buttonhintergrund) bleibt erhalten. Resource mit angepasstem Bild: In dieser Grafik wurde für die Resource NVButton1.gif ein neues Bild für das ausgewählte Theme importiert. Dass das Bild im aktiven Theme überschrieben ist, zeigt sich an der fetten Schrift des Relative Path und daran, dass der Reset-Button aktiv ist. In der Resource wurde der graue Button-Hintergrund durch einen bläulichen ausgetauscht. Wird wieder zum Default-Theme gewechselt, würde die Resource wieder den grauen Button-Hintergrund anzeigen. Bild zurücksetzen Ist einer Resource für ein Theme ein abweichendes Bild zugeordnet, kann dies durch den Reset-Button wieder auf das Default-Bild zurückgesetzt werden. Beispiel Der Resource ist im Default-Theme, wie in den obigen Grafiken zu sehen, der graue Button-Hintergrund zugewiesen und im Theme der bläuliche. Befindet sich der Benutzer nun im Theme und klickt den Reset-Button, wird der bläuliche Buttonhintergrund aus der Resource für das Theme entfernt und der graue Button-Hintergrund würde auch für das Theme verwendet werden (siehe Hierarchie bei mehreren Packages und Themes ). Important Wird einer Resource bei aktiviertem Theme ein Bild zugewiesen und ist das Bild für das Default-Theme noch nicht gesetzt, wird das im Theme importierte Bild auch als Bild für das Default-Theme hinzugefügt."
  },
  "doc/themes/hierarchie-bei-mehreren-package-und-themes.html": {
    "href": "doc/themes/hierarchie-bei-mehreren-package-und-themes.html",
    "title": "Hierarchie bei mehreren Packages und Themes",
    "keywords": "Hierarchie bei mehreren Packages und Themes Wenn mehrere Packages übereinander liegen und mehrere Themes verfügbar sind, folgt Framework Studio einem gewissen Schema, woher die einzelnen Property-Werte bezogen werden. Dieses Schema ist für Properties der Applications, der Default Control Styles, sowie der Bilder der Ressourcen exakt gleich. Im folgenden Beispiel wird angenommen, dass 3 Packages übereinander liegen und im untersten Package (BasePackage) 2 Themes definiert wurden, die somit auch den anderen Packages zur Verfügung stehen. Das Property, welches hier betrachtet werden soll, ist die FocusHighlightColor (im Folgenden FHC) einer Application. Die FHC soll in der Package-Hierarchie wie folgt definiert sein: Theme-Definition für die FocusHighlightColor: Ist die FHC im aktuellen Package für das gewählte Theme nicht definiert (wie z.B. bei CustomPackage/Theme2), werden erst alle Basis-Packages durchsucht, ob dort das Property für das gewählte Theme gesetzt ist. Ist dies nicht der Fall, wird die gleiche Suche für das Property im Default-Theme angestoßen (siehe Pfeile). Anhand der folgenden Grafik soll nun erläutert werden, welche Werte die FHC je Package und Theme annehmen würde: Lookup-Pfad des Themeable Properties: Beispiel BasePackage/Theme1 Da im BasePackage für das Theme Theme1 die FHC explizit auf Purple gesetzt wurde, wird keine Hierarchiesuche angestoßen und die FHC ist somit Purple . Beispiel BasePackage/Theme2 Im BasePackage ist die FHC für das Theme Theme2 nicht definiert. Da das BasePackage kein weiteres Basis-Package hat, wird der Wert des Default-Theme zurückgegeben. In diesem Fall ist im Default-Theme auch nicht explizit ein Wert gesetzt, also wird die Standardfarbe für die FHC (Black) zurückgegeben. Beispiel CustomPackage/Theme1 Für Theme1 ist im CustomPackage keine FHC definiert, also wird im Basis-Package von CustomPackage (BasePackage) für das Theme1 nach der FHC gesucht. Dort ist Purple definiert und wird somit zurückgegeben. Beispiel CustomPackage /Theme2 Im CustomPackage ist die FHC für Theme2 nicht definiert. Es wird somit in BasePackage für Theme2 nach einem Wert gesucht. Dort ist ebenso kein Wert definiert. Es verbleiben keine weiteren Basis-Packages, also wird wieder vom CustomPackage aus durch die Hierarchie gesucht, diesmal jedoch mit dem Default-Theme (da für Theme1 in keinem Package ein Wert für FHC definiert wurde). Für das Default-Theme ist im CustomPackage der Wert Red für die FHC definiert und wird somit zurückgegeben. Beispiel AdditionalPackage/Theme1 In diesem Beispiel ist im AdditionalPackage für das Theme1 gleich ein Wert für die FHC definiert. Yellow wird sofort zurückgegeben. Beispiel AdditionalPackage /Theme2 Für Theme2 ist in keinem der Packages ein Wert für die FHC definiert. Somit wird die Package-Hierarchie für das Default-Theme nach einem Wert für die FHC durchsucht. Im AdditionalPackage wird für das Default-Theme gleich ein Wert Blue gefunden und zurückgegeben."
  },
  "doc/themes/einfuehrung.html": {
    "href": "doc/themes/einfuehrung.html",
    "title": "Einführung",
    "keywords": "Einführung Durch Themes wird die Möglichkeit gegeben, einer FS-Anwendung ein anderes Aussehen zu geben, ohne dabei auf die Geschäftslogik und damit den Sourcecode Einfluss zu nehmen. Beispiel FS-Demo mit Standard-Theme: Das Bild zeigt die FS-Demo-Anwendung, wie sie standardmäßig von Framework Studio erstellt wird. Im folgenden Bild wurde das Aussehen der Anwendung durch Hinzufügen eines Themes grundlegend verändert: In diesem neuen Theme wurden folgende Änderungen durchgeführt: Hintergrundbild geändert. Transparenz des Grids deaktiviert. Button-Images durch blaue Bilder ersetzt. Schriftfarbe der Labels auf blau gesetzt. FocusHighlightColor auf hellgelb gesetzt."
  },
  "doc/print-server/installation.html": {
    "href": "doc/print-server/installation.html",
    "title": "Installation Print-Server",
    "keywords": "Installation Print-Server Requirements Die Requirements für den Print-Server sind in der Liste der Requirements enthalten. Update Wenn ein bestehender Print-Service mit einer neuen Version aktualisiert werden soll, dann befolgen Sie bitte die folgenden Schritte. Die Installation eines neuen Print-Service ist weiter unten beschrieben. Bitte prüfen Sie vor dem Update, ob alle Requirements in der korrekten Version installiert sind. Sichern Sie das aktuelle Programm-Verzeichnis. Jetzt müssen Sie den Dienst deinstallieren. Note Sehen Sie ggf. nach, mit welchem Benutzer der Dienst im Moment läuft (unter Systemsteuerung, Verwaltung, Dienste). Dieser Benutzer muss später bei der Installation der neuen Version wieder angegeben werden. Starten sie das Programm PrintServiceConfigEditor.exe und drücken sie nacheinander die beiden Links stop und uninstall Service und beenden Sie dann den Config-Editor. Wenn noch eine ältere Version im Einsatz ist, welche keinen PrintServiceConfigEditor besitzt, dann führen Sie die Datei Service_uninstall.bat aus. Kopieren Sie den Inhalt des Ordners bin\\ in den Zielordner. Ersetzen Sie alle vorhandenen Dateien. Note Mit dieser Kopier-Aktion wird eine Datei Template_PrintService.exe.config in den Programm-Ordner kopiert. Unbedingt die Datei PrintService.exe.config aus dem alten (gesicherten) Programmverzeichnis weiterverwenden. Starten Sie das Programm PrintServiceConfigEditor.exe und prüfen Sie, ob alle Einstellungen korrekt sind. Es kann durch den Update Änderungen in der config-Datei geben, die dazu führen, dass Änderungen gespeichert werden müssen. Mit Klick auf den Link install Service wird das Programm wieder als Dienst im Betriebssystem registriert. Die darauffolgenden Schritte sind identisch mit der Installation (siehe unten). Installation Bitte prüfen Sie vor der Installation, ob alle Requirements installiert sind. Erstellen Sie den Zielordner für den Service Empfehlung: C:\\Programme\\Framework Systems\\PrintService\\ Kopieren Sie den Inhalt des Ordners bin\\ in den Zielordner. Jetzt müssen Sie die Konfiguration des Services festlegen. Führen Sie dazu im Zielordner das Programm PrintServiceConfigEditor.exe aus. Dieses Programm bearbeitet den Inhalt der Konfigurations-Datei PrintService.exe.config . Beim ersten Aufruf des Configuration-Editors wird die Datei Template_PrintService.exe.config automatisch in PrintService.exe.config umbenannt. Informationen zur Konfiguration von Datenbankverbindung und Drucker finden Sie auf der separaten Seite Konfiguration . Bitte führen sie diese wie gewünscht durch. Jetzt müssen Sie das Programm als Dienst im Betriebssystem registrieren. Klicken Sie dazu den Link install Service . Es öffnet sich ein Fenster, welches den Fortschritt der Installation anzeigt. Fehler, die bei der Installation auftreten, werden in diesem Fenster ausgegeben. Während der Installation des Services wird folgendes Fenster angezeigt: Geben Sie hier den Benutzer an, mit welchem der Dienst ausgeführt werden soll. Es wird empfohlen nach Möglichkeit einen Domain-User anzugeben, der Zugriff auf die Drucker des Rechners hat. Im Idealfall dürfte dies der angemeldete Benutzer sein. Wählen Sie dazu User aus und geben sie in User credentials die Benutzerdaten an. Der User muss im Format Domain\\User angegeben werden. Je nach Konfiguration des Systems kann ggf. auch eines der Systemkonten verwendet werden. Diese Routine erzeugt einige Protokoll-Dateien über den Installationsverlauf im Zielordner. Diese sind kein Problem. Schließen Sie das Installations-Fenster mit dem Button Close . Wenn die Installation erfolgreich verlaufen ist, dann wird im Anschluss angezeigt, dass der Dienst läuft. Im oberen Teil des Fensters sollten Sie folgendes Bild sehen: Mögliche Gründe für das Fehlschlagen der Installation: Die Konfiguration ist fehlerhaft. Starten Sie ggf. die PrintServiceConfigEditor.exe erneut und prüfen Sie die Angaben. Der angegebene Benutzer hat nicht die notwendigen Rechte. Prüfen Sie ggf. das Ereignisprotokoll. Deinstallation Starten Sie das Programm PrintServiceConfigEditor.exe Stoppen Sie den Dienst mit dem Link stop Mit dem Link uninstall Service wird der Windows Dienst deinstalliert. Nach einer Rückfrage startet die Deinstallation und es wird wie bei der Installation ein Dialog mit dem Fortschritt angezeigt. Auch hier werden bei Problemen Fehlermeldungen ausgegeben. Wenn die Deinstallation abgeschlossen ist, kann dieser Dialog mit dem Button Close beendet werden. Anschließend wird angezeigt, dass der Service nicht installiert ist. Beenden Sie den Configuration-Editor und löschen Sie den Zielordner. Warning Dabei gehen die Einstellungen aus der Konfigurations-Datei PrintService.exe.config verloren. Sichern Sie diese Datei ggf. für eine spätere Verwendung. David Fax für Faxversand Installieren Sie auf dem PrintService-Rechner ein Tobit Infocenter. Setzen Sie den neu angelegten Tobit Faxware Drucker als Standarddrucker ein. Falls noch nicht vorhanden, installieren Sie ein Microsoft Word in der Version 2003, 2007, 2010 oder 2013 auf dem PrintService-Rechner. Legen Sie im Abschnitt Printers den neuen Fax-Drucker an. a. Legen Sie mit Add new Printer einen neuen Fax-Drucker an. b. Es erscheint eine Drucker-Auswahl der auf dem Rechner installierten Drucker. Wählen Sie den Drucker Tobit Faxware aus. c. Für den Faxware Drucker wird eine Registerkarte angelegt. d. Markieren Sie die Checkbox Use Word (for Fax Printers). Bei Name geben Sie den Namen des neuen Fax-Druckers an. Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Dieser Name ist frei wählbar und muss nicht mit dem physikalischen Namen des Druckers in Verbindung stehen. Hier im Beispiel haben wir den Namen Tobit Fax gewählt. Bei Path wird der physikalische Name des Fax-Druckers angegeben, hier Tobit Faxware . Bei Paper Source können Sie den Schacht angeben, der zum Druck verwendet werden soll. Diese Einstellung ist hier erst einmal nicht von Interesse. Der Schacht wird nur beim Ausdruck mit CrystalReports berücksichtigt. Speichern Sie die neuen Einstellungen über Save Changes . Starten Sie anschließend den PrintService-Dienst einmal mit dem Link restart durch. Der Fax-Drucker steht nun in eNVenta ERP zur Verfügung und kann benutzt werden."
  },
  "doc/print-server/features.html": {
    "href": "doc/print-server/features.html",
    "title": "Features im Print-Server",
    "keywords": "Features im Print-Server Konsole Sie können den Print-Service auch als Konsole-Anwendung starten. Dazu kann einfach die Datei PrintService.exe gestartet werden. Ein PrintService darf generell nur einmal gestartet sein. Also entweder als Dienst oder mit der Konsole. Bevor Sie die Konsole-Anwendung starten, stellen Sie sicher, dass der Dienst gestoppt oder deaktiviert ist. Anmerkung: Es ist aber durchaus möglich VERSCHIEDENE PrintServices auf einem Rechner parallel zu betreiben. Jeder dieser Services darf aber nur einmal laufen. Beim Start mit der Konsole werden detaillierte Informationen zum Status und zu den Print-Jobs ausgegeben. Das kann sehr hilfreich sein, um z.B. das Verhalten des PrintServices oder auch Fehler zu analysieren. Die Ausgaben auf der Konsole haben denselben Inhalt wie die Protokoll-Datei. Wenn der Service als Konsole-Anwendung gestartet wird, werden die Informationen sowohl in der Konsole als auch, wenn konfiguriert, in der Protokoll-Datei ausgegeben. Prüfungen beim Start Der PrintService führt beim Start Überprüfungen durch. Sind Drucker verfügbar? Es wird geprüft, ob die angegebenen Drucker auch als Windows-Drucker verfügbar sind. Der Print-Server registriert ja alle Drucker im Repository. Diese werden dann von der Applikation (z.B. eNVenta) verwendet. Wenn ein Drucker nicht verfügbar ist, wird eine Warnung in das Ereignis-Protokoll geschrieben, Es wird eine Information in die Protokoll-Datei geschrieben und der Drucker wird mit dem Präfix ##ERROR## in das Repository geschrieben. So können Sie auch in der Anwendung sehen, wenn der Print-Service einen Drucker nicht ansprechen kann. Wenn der Drucker aufgrund technischer Probleme nicht korrekt arbeitet, kann der PrintService keinen Fehler erzeugen. Das schlägt dann ggf. erst bei der Verarbeitung des Druckjobs auf. Sind die Print-Adapter richtig konfiguriert? Crystal Adapter : Beim Start wird geprüft, ob die Crystal-Komponente angesprochen werden kann. Wenn z.B. nicht die korrekte Runtime installiert ist, dann wird eine Fehlermeldung generiert. Diese landet in der Protokoll-Datei und als Warnung im Ereignis-Protokoll. Word, Excel Adapter : Es wird geprüft, ob Word oder Excel verfügbar ist. Bei der Prüfung wird die Version in die Protokoll-Datei geschrieben. Im Fehlerfall wird in die Protokoll-Datei geschrieben und es wird eine Warnung in das Ereignis-Protokoll geschrieben. Wenn Sie kein Word oder Excel verwenden, dann können die entsprechenden Adapter auch aus der Config-Datei entfernt werden. Entsprechende Print-Jobs werden in diesem Fall ignoriert. PDF-Adapter : Es wird geprüft, ob die in der Config definierte Programm-Datei existiert. Wenn nicht, wird die Protokoll-Datei geschrieben und eine Warnung in das Ereignis-Protokoll. Wenn Sie keine PDF-Dateien verarbeiten, dann können Sie diesen Adapter auch aus der Config-Datei entfernen. Entsprechende Print-Jobs werden in diesem Fall ignoriert. Druck in einen Ordner Wenn man mit dem Link Choose Folder den Drucker in einen [Folder] geändert hat, können Sie im Anschluss den Pfad manuell bearbeiten. Tip Bei der Angabe des Ordners können auch UNC-Pfade (z.B. \\\\Server\\Freigabe\\ ) verwendet werden. Es ist zwingend darauf zu achten, dass der Dienst mit einem Benutzer läuft, der entsprechende Schreib-Rechte für diese Freigabe hat. Note Netzlaufwerke sind hingegen NICHT zu empfehlen, weil diese – wenn der Print-Service als Dienst gestartet wird – evtl. nicht zur Verfügung stehen. Durch die Verwendung von Platzhaltern kann der Pfad dynamisch aufgebaut werden. Folgende Platzhalter können verwendet werden: Platzhalter Beschreibung {date} Datum des Drucks mit dem Format yyyy-MM-dd z.B. 2012-05-30 {time} Zeit des Drucks im Format HHmmss z.B. 121037 (für 12:10:37) {owner} Benutzer, der den Druck durchgeführt hat. Der Dateiname wird folgendermaßen generiert: Crystal Report Adapter Dateiname: <ReportName>_<PrintJob-ID>.PDF Beispiel: Invoice_61b7ad1bb4304b40a7758f02f888e614.PDF Wenn nicht bereits im Ordner verwendet, werden dem Dateinamen noch die Platzhalter in der folgenden Reihenfolge vorangestellt: {date}_{time}_{owner}_<dateiname> Beispiel-Konfiguration Es soll pro Tag ein neuer Ordner angelegt werden und darunter pro Mitarbeiter ein weiterer eigener Ordner. Konfigurierter Ordner (Folder): \\\\Fileserver1\\Ausdrucke\\{date}\\Server1\\{owner}\\ Es werden z.B. folgende Ordner generiert: \\\\Fileserver1\\Ausdrucke\\2012-05-30\\Server1\\User1\\ \\\\Fileserver1\\Ausdrucke\\2012-05-30\\Server1\\User2\\ Es werden die Dateien im folgenden Format angelegt: {time}_<ReportName>_<PrintJob-ID>.PDF ( {date} und {owner} werden schon im Ordner verwendet und deshalb nicht in den Dateinamen gepackt) Beispiele für Dateien 121037_Invoice_61b7ad1bb4304b40a7758f02f888e614.PDF 182026_CallList_2a0af0b92b7f418483b5ab0801727453.PDF"
  },
  "doc/ide/tools-menu.html": {
    "href": "doc/ide/tools-menu.html",
    "title": "Tools Menü",
    "keywords": "Tools Menü In den folgenden Abschnitten werden die Menüpunkte im Menü Tools beschrieben. Registered Databases In diesem Dialog werden die im Repository verwendeten Datenbankverbindungen verwaltet. Die Verbindung mit dem Namen RuntimeConnection stellt die Verbindung zum Repository dar. Die in diesem Dialog angelegten Verbindungen stehen allen Benutzern in allen Packages des Repositories zur Verfügung. Caution Die Angaben stehen nicht unter der Versionskontrolle. Sie können von allen Benutzern zu jeder Zeit verändert werden. Die Änderungen wirken sich auf alle Benutzer gleichermaßen aus. Es sollte daher beachtet werden, dass andere Benutzer dadurch nicht behindert werden. Die Verbindungs-Einstellungen sind im Kapitel Connection Einstellungen (!TODO LINK) beschrieben. Access Unit Treeview Über den Menüpunkt Tools / Access Unit Treeview... kann das Fenster zum Bearbeiten der Access Unit Hierarchie aufgerufen werden. Siehe dazu Access Unit Hierarchie (!TODO LINK). Code Snippets Editor Der Code Snippets Editor ist ein hilfreiches Werkzeug, wenn Sie einen Code haben, der immer wieder auftaucht. Was für einen Code Sie im Endeffekt hinterlegen, bleibt dabei Ihnen überlassen. Es könnten z.B. Templates für die Dokumentation sein, Code-Strukturen oder Schleifenkonstrukte. Auch Methoden, die Sie laufend bei Vererbung benötigen, könnten hilfreich sein. Sie können die hinterlegten Code-Snippets im Code-Editor über die Tastenkombination <Strg+J> aufrufen. Es öffnet sich eine Listbox, über die Sie das gewünschte Snippet auswählen können. Auch über die Toolbox können die Snippets per Drag und Drop in den Code-Editor oder dem Comment-Editor gezogen werden. Die Code-Snippets werden im Repository an der aktuellen Package-Version gespeichert. Sie werden zusammen mit der Package-Version exportiert und so in das Ziel-Repository übertragen. Das ursprüngliche manuelle Exportieren und Importieren der Code-Snippets entfällt. Im Code-Snippet-Editor können die Code-Snippets für die aktuelle Package-Version bearbeitet werden. Zusätzlich werden die Code-Snippets aus den Basis-Packages zusammen mit dem Package-Namen angezeigt – sie sind readonly. Überschreiben können Sie ein Code-Snippet indem Sie im aktuellen Package ein weiteres Code-Snippet mit identischem Namen erstellen. In der Liste sind die Code-Snippets nach der Package-Hierarchie angeordnet, sodass Überschreibungen gut zu erkennen sind. Beispiel: Das aktuelle Package hat FSDemoCustomize und FSDemo als Basis und dementsprechend werden auch die Code-Snippets dieser Packages angezeigt. In dem Code-Snippet Editor werden die Snippets folgendermaßen dargestellt: Snippet1 Snippet1 [FSDemoCustomize] Snippet1 [FSDemo] Snippet2 [FSDemoCustomize] Snippet2 [FSDemo] Snippet3 [FSDemo] Snippet4 Snippet4 [FSDemo] Von den im Code-Snippet-Editor angezeigten Einträgen gewinnt jeweils der erste. Die grauen Einträge werden im Intellisense und der Toolbox nicht angezeigt. Checked Out Report Im Menu Tools / Checked Out Report öffnet sich ein Report-Fenster. Checked Out Records: Dieser Report zeigt die ausgecheckten Elemente aller Benutzer an. Die Anzeige ist nach Benutzern gruppiert. Eine Legende mit den Bedeutungen der Farben befindet sich am Ende dieses Reports. Change Password Im Menu Tools / Change Password öffnet sich ein Dialog zum Ändern des eigenen Passworts. Change Password Dialog: In diesem Dialog müssen Sie im Feld Old Password das zurzeit gültige Passwort eingeben. In New Password können Sie das neue Passwort eingeben, welches in Confirm New Password bestätigt werden muss, um Fehleingaben zu verhindern. Mit dem Button OK wird das neue Passwort gesetzt. Wenn Sie kein neues Passwort eingeben und mit dem Button OK bestätigen, wird das Passwort gelöscht und Sie können sich ab sofort ohne Passwort mit Ihrem Benutzernamen anmelden. Wenn Sie im Team mit mehreren Entwicklern arbeiten, wird aus Sicherheitsgründen empfohlen ein Passwort zu verwenden. Sollten Sie Ihr Passwort einmal vergessen, gibt es die Möglichkeit über die Benutzer-Verwaltung (!TODO LINK) ein neues Passwort zu vergeben. Adjust moved customizations Wird ein Element aus einem Basis-Package gecustomized, dann merkt sich Framework Studio aus Performance-Gründen auch im Customizing-Package den Namespace, in dem sich dieses Element befindet. Nun kann es passieren, dass im Basis-Package ein Element mit der Funktion Change Namespace in einen anderen Namespace verschoben wird. Dies führt zu Compile-Fehlern im Customizing-Package. Mit der Routine Adjust moved customizations wird der Namespace der gecustomizten Elemente korrigiert. Diese werden dazu ausgecheckt und müssen anschließend wieder eingecheckt werden, bevor ein Framework Compiler gestartet wird. FSConsole Command Prompt Startet ein Konsolen-Fenster. Dort ist als aktuelles Verzeichnis das Framework Studio Programm-Verzeichnis gesetzt. Runtime Licenses Über den Menüpunkt Tools / Runtime Licenses kann der Runtime License Manager geöffnet werden. Details zur Verwaltung von Laufzeitlizenzen mit dem Runtime License Manager finden Sie unter Laufzeitlizenzen (!TODO LINK)."
  },
  "doc/ide/registerkarten.html": {
    "href": "doc/ide/registerkarten.html",
    "title": "Registerkarten im Framework Designer",
    "keywords": "Registerkarten im Framework Designer Registerkarte Namespaces Diese Registerkarte ist noch mal in 2 Teile gegliedert. Im oberen Teil ist der Namespace-Baum abgebildet. In Framework Studio werden zu jedem Package ( Packages ) die Klassen wie in .NET üblich in Namespaces strukturiert. Diese Namespaces sind wie ein Baum unter ihrem Package aufgebaut und können beliebig tief verschachtelt sein. Im unteren Teil werden die Elemente des im oberen Baum ausgewählten Namespace im so genannten Objekt-Baum angezeigt. Mit einem Doppelklick können diese geöffnet werden. Es öffnet sich für jedes Element ein Designer-Fenster im Hauptfenster. Die Toolbar im mittleren Teil der Registerkarte bezieht sich auf den darunter dargestellten Objekt-Baum. Die einzelnen Elemente der Toolbar werden im Abschnitt Allgemeine Funktionalitäten erläutert. Außer der Registerkarte Search beziehen sich alle anderen Registerkarten, die im Folgenden beschrieben werden, immer auf das gerade aktive Designer-Fenster bzw. das dort ausgewählte Element. Ein Wechsel auf diese Registerkarten ist nur möglich, wenn bereits ein Designer-Fenster geöffnet wurde. Registerkarte Class Die Registerkarte Class zeigt alle Members des geöffneten Elements an. Über das Kontext-Menü des Elements (oberster Eintrag) können auch neue Member hinzugefügt werden. Mit einem Doppelklick auf einen Eintrag dieses Baums wird das entsprechende Member im Designer-Fenster auf der rechten Seite geöffnet bzw. ausgewählt. Über das Kontext-Menü eines Members lässt sich dieses aus dem Objekt löschen, umbenennen oder ein weiteres Member gleichen Typs erzeugen. Registerkarte Inheritance In dieser Registerkarte wird der Vererbungsbaum für das geöffnete Objekt angezeigt. Warning Nur Metadatentypen, Reports, Forms und Workflows lassen sich vererben. Registerkarte Properties Hier können die Eigenschaften der Elemente eines Objektes geändert werden. Es werden immer die Eigenschaften des im aktiven Designer-Fensters ausgewählten Elements angeboten. Sie können ein Element wählen, indem Sie es im Designer-Fenster anklicken. Diese listet alle Elemente auf, die im Zusammenhang zu der im aktiven Designer-Fenster ausgewählten Registerkarte stehen. Sortierung nach Kategorien: Standardmäßige Sortierreihenfolge der Properties. Sortierung Alphabetisch: Alternativ können Sie sich die Properties alphabetisch sortiert anzeigen lassen. Warning TODO! ++ Vererbte und Fett gedruckte Property-Werte ++ Zurücksetzen auf default-Wert ++ Ggf. Spezielle Editoren Registerkarte Toolbox Handelt es sich bei dem ausgewählten Objekt um ein Form oder einen Workflow, wird diese Registerkarte zugänglich. Bei Forms werden dort alle verfügbaren Controls angeboten. Ein Control kann per Drag & Drop auf dem Form positioniert werden. Bei Workflows werden über diese Registerkarte Links, Branches und Switches angeboten, welche per Drag & Drop in den Workflow gezogen und dort positioniert werden können. Ergänzende Informationen zu den Tools finden Sie in den Abschnitten zu Form (!TODO LINK) und Workflows Designer (!TODO LINK). Registerkarte Search Auf dieser Registerkarte werden verschiedene Suchfunktionen zur Verfügung gestellt. Für die Suche gelten folgende allgemeine Funktionen: Suchbegriffeingabe Die Combobox unter der Suchdomänenauswahl ist zur Eingabe des Suchbegriffs vorgesehen. Sie speichert die 15 zuletzt verwendeten Suchbegriffe. Kommt ein sechzehnter Suchbegriff hinzu, so wird der älteste Eintrag verdrängt. Wird ein Suchbegriff verwendet, der schon in der Liste enthalten ist, so wird der Eintrag an den Anfang der Liste verschoben. Button Search Mit dem Button Search wird die Suche gestartet und die Ergebnisse werden in der Liste im unteren Bereich angezeigt. Suchergebnis-Historie Die Links/Rechts Pfeil-Buttons ermöglichen das chronologische Wechseln (links = zurück, rechts = vor) zwischen Suchergebnissen, die in der Suchergebnis-Historie abgelegt wurden. Sobald eine neue Suche ausgeführt wird, wird das Ergebnis dieser Suche ans Ende der Historie angehängt und angezeigt. Die Historie speichert maximal 15 Einträge. Außerdem erscheinen beim Blättern zusätzliche Informationen zum jeweiligen Eintrag unterhalb der Suchergebnisse. Suchergebnis-Historie mit zusätzlichen Informationen Result view style Hier kann ausgewählt werden, ob die Ergebnisse in einer Liste oder in einem Namespace-Baum angezeigt werden sollen. Zusätzlich besteht die Möglichkeit nur Methoden anzuzeigen. Diese Einstellung kann auch nach der Suche verändert werden. Ergebnis-Liste Die Ergebnisse werden wie gewünscht als Liste oder in einem Namespace-Baum angezeigt. Beim Namespace-Baum sind die Einträge mit grauem Text nicht Bestandteil der Ergebnis-Menge sondern dienen dazu, die Ergebnisse in einem Baum anzuordnen. In dieser Ansicht ist das Einchecken von Elementen inklusive aller Unterelemente über das Kontextmenü möglich. So können beispielsweise, nach der Suche nach ausgecheckten Elementen, alle ausgecheckten Elemente des Benutzers in einem Vorgang eingecheckt werden. Durch Doppelklick auf ein Suchergebnis wird das Ergebnis geöffnet. Nun folgt die Beschreibung der verschiedenen Such-Mechanismen. Volltext-Suche in generierten Code Die Suche auf den generierten Code ist ein guter Mechanismus, um z.B. nach bestimmten Verwendungen zu suchen. Der generierte Code beinhaltet sowohl alle im Designer angegebenen Informationen als auch den selbst geschriebenen Code. Der generierte Code wird mit entsprechenden Marken versehen, sodass die Suche bei einem Treffer die gefundene Code-Zeile einem Element (z.B. Component, Form) oder einem Teil (z.B. Property, Methode) zuordnen kann. Wird z.B. eine Zeile in einer selbst geschrieben Methode gefunden, kann diese Code-Zeile aus der Treffer-Liste heraus direkt angesprungen werden. Sie können in dem Textfeld einen zu suchenden Text angeben. Es wird dabei nach dem kompletten Text gesucht. Search Domain Hier wird angegeben, in welchem Bereich die Suche erfolgen soll. Sie können ein gesamtes Package durchsuchen oder den Suchbereich auf einen Namespace mit allen darunter liegenden Namespaces einschränken. Der Suchbereich kann auch über den Menüeintrag Search... im Objektbaum auf der Registerkarte Namespaces oder über den Menüeintrag Edit/Search... im Designerfenster eines LabeledRecords auf einen einzelnen LabeledRecord, also z.B. auf ein Form oder eine Textcollection eingeschränkt werden. Search in Component: In diesem Fall wird der Button Select Namespace angezeigt, mit dem der Suchbereich wieder auf einen beliebigen Namespace festgelegt werden kann. Grundsätzlich gilt: Je kleiner der Suchbereich, desto schneller die Suche. Bei einer großen Anwendung kann die Suche über alle Namespaces sehr lange dauern. Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Checkbox Use Saved Code Für die Suche soll der gespeicherte generierte Code verwendet werden. Es wird empfohlen, diese Option zu verwenden, da ansonsten der Code für die Suche komplett neu erzeugt werden muss. Das kann bei einer großen Anwendung sehr lange dauern. Combobox Element type Hier können Sie angeben, in welcher Art von Elementen die Suche durchgeführt werden soll. (z.B. Components, Forms, …) Suche in Textcollections Mit der Suche in Textcollections ist es möglich, gezielt die in den Textcollections angegebenen Texte zu durchsuchen. Suche in Textcollections: Search Domain Hier wird angegeben, in welchem Bereich die Suche erfolgen soll. Sie können in allen Textcollections eines Packages oder in allen Textcollections, die unterhalb eines bestimmten Namespaces liegen, suchen. Der Suchbereich kann außerdem über den Menüeintrag Search... im Objektbaum auf der Registerkarte Namespaces oder über den Menüeintrag Edit/Search... im Designerfenster einer Textcollection auf eine spezielle Textcollection eingeschränkt werden. Checkbox Textcollection Mit dieser Checkbox wird dieser Suchmodus aktiviert. Combobox Language Hier kann angegeben werden, in welcher Sprache gesucht werden soll. Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Wird z.B. als Suchtext ein regulärer Ausdruck ^$ angegeben und es wird eine Sprache ausgewählt, lassen sich alle Texte finden, bei denen der Text in dieser Sprache nicht gefüllt ist. ( ^ ist ein Zeilen-Anfang, $ ist ein Zeilenende und dazwischen soll nichts stehen.) Suche nach ausgecheckten Elementen In diesem Suchmodus werden alle ausgecheckten Elemente des Benutzers im aktuellen Package angezeigt. Checkbox Checked out Damit wird der Suchmodus aktiviert. Es werden alle anderen Controls inklusive des Namespace-Baumes deaktiviert. In der Ergebnis-Liste besteht die Möglichkeit, ein Check In oder ein Undo Check Out durchzuführen. Dabei können auch mehrere Elemente gleichzeitig verarbeitet werden. Dazu gibt es für die Ergebnisse ein Kontext-Menu, welches mit der rechten Maustaste aufgerufen werden kann. Nach einem Check In oder ein Undo Check Out wird die Ergebnis-Liste nicht aktualisiert. Es muss anschließend ggf. noch einmal neu gesucht werden, um die Liste zu aktualisieren. Während der Check In in einem Rutsch durchgeführt wird, wird der Undo Check Out für jedes Element einzeln durchgeführt. Dabei erscheint jedes Mal eine Meldung, die bestätigt werden muss. Es kann auch vorkommen, dass ein Undo Check Out mal nicht durchgeführt werden kann, weil dies durch eine bereits existierende Referenz verhindert wird. Der Vorgang muss ggf. wiederholt werden. Es folgt die Beschreibung des Kontext-Menus. Je nach Ergebnis können die Menu-Einträge variieren. Check In Checkt das einzelne Element ein. Check In all sub records Checkt alle, unterhalb eines Namespaces liegenden Elemente ein – auch über mehrere Ebenen hinweg. Check In with all its sub records Checkt den Namespace und alle unterhalb diesem Namespace liegenden Elemente ein – auch über mehrere Ebenen hinweg. Undo Check Out Führt einen Undo Check Out für das einzelne Element durch. Undo Check Out all sub records Führt einen Undo Check Out für alle unterhalb einem Namespace liegenden Elemente durch – auch über mehrere Ebenen hinweg. Undo Check Out with all its sub records Führt einen Undo Check Out für den Namespace und alle unterhalb dieses Namespace liegenden Elemente durch – auch über mehrere Ebenen hinweg. Suche nach Elementnamen Dieser Suchmodus wird mit der Checkbox Element Name aktiviert und dient dem schnellen Auffinden von Elementen über ihren Namen. Suche nach Elementnamen: Checkbox Case sensitive Bei der Suche wird nach Groß- und Klein-Schreibung unterschieden. Checkbox Regular Expressions Bei dem Suchtext handelt es sich um einen regulären Ausdruck. Es muss ein gültiger Ausdruck angegeben werden. Combobox Element type Hier kann die Suche auf einen Elementtyp (z.B. Components, Forms, ...) eingeschränkt werden. Suche nach Abhängigkeiten Sucht alle Elemente, die vom aktuellen Element abhängig sind. Mit dieser Funktion können Sie beispielsweise von einem Form zu Workflows wechseln, in denen das Form verwendet wird: von einer Component zu anderen Components oder zu Forms wechseln, die diese Component verwenden von einem Metadatentypen zu Components oder Forms wechseln, die den Metadatentypen verwenden von Workflows zu anderen Workflows wechseln, die diesen Workflow verwenden Data Source Hierarchiesuche Eine spezielle Form der Abhängigkeitssuche ist die Data Source Hierarchiesuche. Diese wird an einem Control innerhalb eines Forms ausgelöst und listet eine geordnete Kette von Elementen auf, die sich aus der Datenquelle des Controls ergeben: Das Control, für das die Suche ausgeführt wurde. Das Form-Property. Wenn eine Component beteiligt ist, wird das entsprechende Component-Property ebenfalls dargestellt – wie z.B. cdCall.oPCSInfo. Das Component-Property Die Tabellen-Spalte Der Metadatentyp und ggf. Basis-Metadatentypen Checkbox Dependencies Da diese Option eine spezielle Suchdomäne benötigt, kann die Suche nur durch das Menü Edit/Search Dependencies im Designerfenster bzw. über das Kontextmenü an einem Form Control erfolgen und die Checkbox Dependencies wird erst dann aktiv. Erst wenn das Häkchen entfernt wurde, kann wieder eine normale Suche durchgeführt werden. Registerkarte Comment Auf der Registerkarte Comment können Methoden dokumentiert werden. Wird z.B. ein Form geöffnet und auf der Registerkarte Methods eine Methode ausgewählt, wird die Comment-Registerkarte freigeschaltet. Registerkarte Check In Comment Auf der Registerkarte Check In Comment kann für ein Element (z.B. Form, Workflow, Component usw.) ein Kommentar hinterlegt werden, der beim nächsten Check In verwendet werden soll."
  },
  "doc/html-client/mobile/index.html": {
    "href": "doc/html-client/mobile/index.html",
    "title": "Funktionalitäten für mobile Endgeräte",
    "keywords": "Funktionalitäten für mobile Endgeräte Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser."
  },
  "doc/html-client/mobile/barcode.html": {
    "href": "doc/html-client/mobile/barcode.html",
    "title": "Barcode Scanner",
    "keywords": "Barcode Scanner Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser. Über die in einem mobilen Gerät integrierte Kamera können im HTML Client Barcodes unterschiedlicher Formate eingescannt werden. Unterstützte Formate Name Beispiel Name Beispiel AZTEC EAN_13 CODABAR ITF CODE_39 PDF_417 CODE_93 QR_CODE CODE_128 UPC_A DATA_MATRIX UPC_E EAN_8 Action ScanBarcode() Der Scan-Vorgang wird am Form über die Action ScanBarcode() gestartet. Note Es wird dringend empfohlen, nur diejenigen Barcode-Formate zu übergeben, die auch tatsächlich beim Scan-Vorgang unterstützt werden sollen, um Fehler beim Scannen zu vermeiden. Je geringer die Anzahl der unterstützten Formate ist, desto unwahrscheinlicher ist es, dass der Scan fehlschlägt. // Aufruf der Action beim Click des Scan-Buttons protected virtual void FE_btnScanArticle_OnClick(FrameworkButtonClickEventArgs e) { this.ScanBarcode( this.ScanBarcodeCallback, BarcodeFormat.EAN_8 | BarcodeFormat.EAN_13, \"Article\" ); } Wenn der Scan-Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die gescannten Daten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkBarcodeScanInfo übergeben. // Callback-Methode protected virtual void ScanBarcodeCallback(IFrameworkBarcodeScanInfo e) { if (e.HasError) { this.sValue = e.ErrorMessage; } else if (e.Cancelled) { this.sValue = \"Cancelled\"; } else { if (e.Identifier == \"Article\") { this.sArticle = e.Value; } else { this.sAmount = e.Value; } this.sFormat = e.Format.ToString(); } } Berechtigung für Kamera Der Barcode Scanner benötigt auf dem mobilen Gerät Zugriff auf die Kamera. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden:"
  },
  "doc/html-client/only-android.include.html": {
    "href": "doc/html-client/only-android.include.html",
    "title": "",
    "keywords": "Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser."
  },
  "doc/html-client/lizenzen.html": {
    "href": "doc/html-client/lizenzen.html",
    "title": "Hinweis zu Lizenzen",
    "keywords": "Hinweis zu Lizenzen Timeout Aus technischen Gründen kann der HTML-Client weder im Browser, noch in der App auf einem mobilen Gerät dem Broker mitteilen, dass er beendet wurde. Z.B. kann auf einem Android-Gerät nicht unterschieden werden, ob eine App nur in den Ruhezustand gewechselt hat oder komplett geschlossen wurde. Dies hat zur Folge, dass Broker-Sessions, die von einem HTML-Client aus gestartet wurden, offen bleiben, bis der Broker sie von sich aus verwirft. Diese Zeitspanne beträgt 12 Stunden . ClientID Um dem Verbrauch von Lizenzen entgegen zu wirken, wird im HTML-Client eine ClientID generiert, die den Browser bzw. das mobile Gerät identifiziert und mit zum Broker geschickt wird. Im Browser ist die ClientID eine UUIDv4, die im Code generiert wird, auf mobilen Geräten wird die Cordova-Geräte-ID herangezogen. Über die ClientID kann der Broker den Browser bzw. das mobile Gerät identifizieren und bei einem erneuten Start einer Anwendung diesem die bisherige Lizenz zuordnen. Zusatz für mobile Geräte Die ClientID auf mobilen Geräten ist immer gleich. Ein mobiles Gerät verbraucht am Broker eine Lizenz unabhängig vom Benutzer. Zusatz für Browser Ein Browser hat keinen Zugriff auf das Betriebssystem und den Computer. Die generierte ClientID wird deshalb im sogenannten „Local Storage“ des Browsers gespeichert. Dieser Speicher ist je nach Konfiguration benutzerabhängig. Beispiel: Ist auf einem Computer, den drei Benutzer verwenden, Firefox als Browser installiert, so hat jeder Benutzer seinen eigenen Local Storage. Dies bedeutet, dass jeder Benutzer seine eigene ClientID bekommt und somit auch drei Lizenzen am Broker verbraucht werden. Dies gilt auch, wenn ein Benutzer dieselbe Applikation einmal im Firefox und einmal im Chrome öffnet. Die beiden Browser haben separate Local Storages und verbrauchen somit auch wieder zwei Lizenzen am Broker."
  },
  "doc/form/control/listview.html": {
    "href": "doc/form/control/listview.html",
    "title": "ListView",
    "keywords": "ListView Properties/Events Actions Note Dieses Control funktioniert nur im Mobile-Client . Im Java-Client wird das Control nicht angezeigt. ListView Template Editor Der ListView Template Editor bietet die Möglichkeit, das HTML/CSS Template für ListItems sprachabhängig zu definieren. Dabei können Template DataSources definiert werden, auf welche aus dem HTML heraus mittels Template Variablen verwiesen wird. So können sehr einfach Businessdaten ins HTML eingebettet und formatiert werden. Der Editor kann im Property-Grid über das Property Template geöffnet werden. Allgemein Dropdown für Sprachauswahl Das HTML und CSS eines ListItems kann, wenn gewünscht, für jede Sprache einzeln definiert werden. Ist für eine Sprache kein Template definiert, wird auf Deutsch zurückgegriffen. Button Validate Über diesen Button können die im HTML eingebetteten Template Variablen und Template MLKeys überprüft werden. Es werden folgende Fälle geprüft: Ist der Template MLKey parsebar und ist der MLKey-Name gültig? Ist die Template Variable parsebar? Passt das angegebene Format zum Datentyp? Zeigt die Template Variable auf eine existierende Template DataSource? Ist jeder Template DataSource eine valide DataSource zugeordnet Template DataSources Auf der rechten Seite der Registerkarte HTML befindet sich die Liste der definierten Template DataSources. Jede Template DataSource zeigt auf ein Property der der ListView zugeordneten DataSource Collection. Im Beispiel ist der ListView die cdArticleColl aus dem FSDemo als DataSource zugewiesen. Somit stehen einer Template DataSource alle Properties des cdArticle -Objekts zur Verfügung. Wie im Bild zu sehen, verweist die Template DataSource Price auf das Property decPrice von cdArticle . Der Name einer Template DataSource muss eindeutig sein. Aus dem HTML kann nun mittels einer Template Variable auf die Template DataSource zugegriffen und der Wert wie gewünscht im HTML formatiert werden. HTML Auf der linken Seite der Registerkarte HTML befindet sich der HTML-Codeeditor, in dem das HTML für das ListItem definiert werden kann. Note Das benutzerdefinierte HTML wird zur Laufzeit vom HTML Client (Angular) compiliert und optimiert. Grobe Fehler wie z.B. nicht geschlossene Tags oder invalides HTML können zu Anzeigefehlern führen, die unter Umständen auch andere Bereiche des HTML Clients betreffen. ListView Templates sollten vor dem produktiven Einsatz in allen verfügbaren Browsern ausgiebig getestet werden. Button Use Base Mit dem Button Use Base kann das HTML Template z.B. nach einem Customizing wieder auf die Basis zurückgesetzt werden. Button Template Variable Mit dem Button Template Variable kann eine neue Template Variable erstellt, oder eine bestehende geändert werden. Button MLKey Mit dem Button MLKey wird das MLKey-Wörterbuch geöffnet. Dort kann ein neuer Template MLKey erstellt, oder ein bestehender geändert werden. HTML Aufbau Der benutzerdefinierte HTML Code wird im HTML Client in ein <div> -Tag mit der CSS-Klasse lvItem verpackt. Es ist also nicht unbedingt nötig, um den eigenen HTML Code ein <div> -Tag als Container zu implementieren. Der Code aus dem Beispiel sieht im HTML Client z.B. so aus: <hc-listitem-content _nghost-wvt-c19 class=\"ng-star-inserted\"> <div _ngcontent-wvt-c19 class=\"lvItem\"> <img _ngcontent-wvt-c19 src=\"http://localhost:8080/Dev/NV286_1_ListView40_FSDemo_4.0_user1/FSDempApplication//images/NVNew1.png\"> <span _ngcontent-wvt-c19>Laptop SILBER kostet 1,899.00€</span> </div> </hc-listitem-content> Das <div> -Tag mit der CSS-Klasse lvItem kann im CSS wie gewünscht angepasst werden, ohne einen eigenen Container oder eine eigene CSS-Klasse verwenden zu müssen. Placeholder Die Konstante %FILESURL% kann im HTML verwendet werden, um zur Laufzeit die Broker-Url zu erhalten. Dadurch können z.B. in <img> -Tags auf Bilder, welche als Ressourcen im Framework Studio hinterlegt wurden, zugegriffen werden. Dynamische Bilder können über eine binäre Template-Variable realisiert werden. (siehe Abschnitt Images im ListViewItem ) Template Variablen Über den Button Template Variable öffnet sich der Template Variable Editor . Befindet sich der Cursor im Codeeditor auf einer bestehenden Template Variable, wird diese im Editor vorselektiert. Auf der linken Seite werden alle zur Verfügung stehenden Template DataSources aufgelistet. Auf der rechten Seite kann für die Template Variable ein passendes Format und/oder FormatPattern definiert werden. Durch die Aufteilung in Template DataSources und Template Variablen werden die Daten und deren Formatierung im HTML strikt voneinander getrennt. Beispielsweise könnte der Wert einer Template DataSource im englischen HTML anders formatiert werden als im deutschen HTML. Template Variablen werden im HTML-Code wie folgt angezeigt: {{ ds:[Name]|f:[Format]|fp:[FormatPattern] }} Dabei verweist [Name] auf den Namen der zugehörigen Template DataSource, [Format] und [FormatPattern] definieren das im Template Variable Editor ausgewählte Format und FormatPattern. PreviewValue ist derjenige Wert, der für die Template Variable angezeigt wird, wenn das Template auf der Registerkarte Preview zur Vorschau gerendert wird. Der Wert wird zur Laufzeit ignoriert. Note Es wird empfohlen, Template Variablen und Template MLKeys immer über den jeweiligen Editor zu ändern, um Syntaxfehler zu vermeiden. Template MLKey Template MLKeys werden im HTML-Code wie folgt angezeigt: {{ mlkey:[MLKey-Name] }} Dabei verweist [MLKey-Name] auf den Namen des zugehörigen MLKeys. Zum Beispiel \"SYS_OK\". CSS Das benutzerdefinierte HTML kann mittels CSS im CSS-Codeeditor auf der Registerkarte CSS beliebig angepasst werden. Beispiel: .lvltem { display: flex; flex-direction: row; align-items: center; background-color: azure; border-radius: 0.3rem; border: 0.1rem solid gray; padding: 0.3rem; padding-right: 2.8rem; } .lvItem[lvDisabled] { background-color: #cccccc; } img { display: inline; } Wie im Kapitel HTML beschrieben, wird ein ListItem mit einem <div> -Tag der CSS-Klasse lvItem umgeben. Im CSS-Code kann somit über den CSS-Selector .lvItem auf das Element zugegriffen werden. REM anstatt Pixel Im CSS sollten Größenangaben ausschließlich mit rem angegeben werden. Der HTML Client skaliert die gesamte Anzeige anhand der vom Browser vorgegebenen Schriftgröße. Im HTML Client wird global für das HTML- und das BODY-Tag folgendes definiert: html { font-size: 62.5%; } body { font-size: 1.4rem; } In Desktop-Browsern wie z.B. Chrome, Firefox oder Edge ist der Standardwert der Schriftgröße 16px . 1rem ist per Definition genauso groß wie die Schriftgröße des HTML-Tags, also im Standardfall erst einmal 16px . Setzt man nun die font-size des HTML-Tags auf 62.5% , ergibt sich eine Schriftgröße von 10px , womit 1rem nun ebenfalls 10px groß ist. Da meist in Desktop-Browsern entwickelt und getestet wird, ergibt diese Anpassung Sinn, da es viel einfacher zu verstehen ist, mit Faktor 10, als mit Faktor 16 zu arbeiten. 0.5rem sind 5px , 5rem sind 50px usw. Deshalb wird im BODY-Tag auch die Schriftgröße auf 1.4rem gesetzt, was letztenendes 14px sind. Dies spiegelt die Standardschriftgröße des HTML Clients wieder. Probleme können nun enstehen, wenn REM- und Pixelwerte gemischt werden! Ein Beispiel: .tpl .remClass { width: 10rem; } .tpl .pxClass { width: 100px; } Nehmen wir an, es gibt zwei HTML-Elemente im Template mit den Klassen remClass und pxClass . Liefert der Browser eine Standardgröße von 16px , besteht kein Problem, die beiden Elemente sind exakt gleich groß, da 65.5% von 16px = 10px . Damit sind 10rem exakt 100px . Anders sieht es aber aus, wenn z.B. ein mobiler Browser eine Standardschriftgröße von 14px liefert. 62.5% von 14px = 8.75px , damit sind 10rem exakt 87.5px und die beiden HTML-Elemente sind plötzlich unterschiedlich groß. Dies kann je nach Gerät und verwendetem Browser zu unvorhersehbaren Skalierungsfehlern führen. Tip Es wird ausdrücklich empfohlen, im HTML/CSS des ListItems rem als Größeneinheit zu verwenden. IsEditable Im CSS kann auch ein Style für deaktivierte ListItems in einem nicht editierbaren ListView hinterlegt werden. Wird ein ListView im Designer oder per Action auf isEditable = false gesetzt, so wird am <div> -Tag lvItem das HTML-Attribut lvDisabled hinzugefügt: <hc-listitem-content _nghost-wvt-c19 class=\"ng-star-inserted\"> <div _ngcontent-wvt-c19 class=\"lvItem\" lvDisabled=\"true\"> [...] </div> </hc-listitem-content> Im CSS-Code kann über den Attribute-Selector .lvItem[lvDisabled] genau dieser Fall abgefragt werden. Im Beispiel wird der Hintergrund des ListItems auf grau ( #cccccc ) gesetzt. Images im ListViewItem Eine Besonderheit ist das Anzeigen von Bildern in einem ListViewItem mittels <img /> , wenn dieses über ein byte[] aus der Datenbank gebunden werden soll. Ein Anwendungsfall wäre z.B. das Anzeigen von Artikelbildern. Beispiel: <img class=\"img\" src=\"data:{{ ds:MimeType }};base64,{{ ds:Image }}\" /> Um ein Bild an ein HTML img-Tag zu binden sind zwei Template Variablen notwendig. Das byte[] mit den Bildinformationen alleine reicht abhängig vom genutzten Browser nicht immer aus (siehe Hinweis). Es muss zusätzlich der HTML Mime-Type spezifiziert werden, sodass der Browser weiß, um welches Bildformat es sich handelt. {{ ds:MimeType }} ist eine Template Variable vom typ FSstring oder string und gibt z.B. den Mime-Type \"image/png\" oder \"image/jpg\" zurück. {{ ds:Image }} ist eine Template Variable vom Type FSByteArray oder byte[] . Binärdaten werden als Base64-String zum Client übertragen. Da das HTML src -Attribut Base64 versteht, ist keine weitere Formatierung der Daten nötig. Tip Die Angabe des Mime-Types ist in den meisten Browsern wie Chrome, Firefox, Safari oder Edge (auch auf mobilen Geräten) nicht zwingend nötig. Manche proprietären Browser auf mobilen Geräten haben jedoch Schwierigkeiten, ohne die Angabe des Mime-Types, das Bild korrekt darzustellen. Sollten diese Browser keine Rolle für die Anwendung spielen, kann auch folgendes HTML genutzt werden: <img class=\"img\" src=\"data:;base64,{{ ds:Image }}\" /> Das Semicolon vor base64 ist ohne die Angabe des Mime-Types zwingend notwendig. Preview Wenn der HTML-Code gültig ist, wird auf der Registerkarte \"Preview\" eine gerenderte Vorschau des Templates angezeigt. Für die Vorschau werden die PreviewValues für die einzelnen Template Variablen verwendet. Sollte ein PreviewValue nicht gesetzt sein, wird stattdessen der DataSource Name angezeigt. Template MLKeys zeigen den im Wörterbuch hinterlegten Text an. Fallback für die Standartsprache Wenn für eine Sprache eines bestimmten HTML-Codes nicht gibt, wird den HTML-Code des Standartsprache (Deutsch) verwendet. Diese Regel wird auch für den CSS-Code anwenden. Anderseits, wenn kein Code auch für die Standardsprache gibt, wird die Meldung TEMPLATE NULL angezeigt."
  },
  "doc/form/control/listbox.html": {
    "href": "doc/form/control/listbox.html",
    "title": "Listbox",
    "keywords": "Listbox Properties/Events Actions Bei einer Listbox handelt es sich im Grunde um eine Combobox, die immer ausgeklappt ist."
  },
  "doc/form/control/label.html": {
    "href": "doc/form/control/label.html",
    "title": "Label",
    "keywords": "Label Properties/Events Actions Das Label dient dazu, Text in einer Maske anzuzeigen. Sie können einem Label einen festen Text zuweisen und somit z.B. andere Controls mit einer Beschriftung versehen. Dieser Text wird mehrsprachig hinterlegt. Es ist auch möglich einem Label einen Datasource zuzuweisen. So können Sie auch Inhalte von Properties anzeigen."
  },
  "doc/form/control/is-visible-editable-au.html": {
    "href": "doc/form/control/is-visible-editable-au.html",
    "title": "IsVisibleAU / IsEditableAU",
    "keywords": "IsVisibleAU / IsEditableAU Die Control-Eigenschaften IsVisibleAU und IsEditableAU stellen jeweils eine Liste von AccessUnit Objekten verknüpft mit je einem AUPermissionType dar. Für jeden dieser Listeneinträge wird bei der Initialisierung der Form-Controls mit Hilfe der Methode IGlobalObjects.AUHelper.Granted(AccessUnit, AUPermissionType) geprüft, ob der Zugriff gewährt wird. Falls dies bei keinem der Einträge zutrifft und die Liste nicht leer ist, so wird das entsprechende Control unsichtbar (bei IsVisibleAU ) bzw. nicht bearbeitbar (bei IsEditableAU ). Wenn das Property IsVisible bzw. IsEditable bereits auf false gesetzt wurde, haben die Properties keine Auswirkungen. Eine spezielle Access Unit ist die FormAccessUnit. Sie ist, worauf der Name bereits hinweist, dem Form zugeordnet. Im Fall von IsVisibleAU und IsEditableAU ist die äußerste Spezialisierung in der Vererbungskette relevant. Wird eine Eigenschaft in einem vererbten From oder im Customizing überschrieben, so wirken die Listeneinträge als wären sie mit denen aus der Basis vereinigt. Warning Bei kritischen Aktionen sollte weiterhin eine Prüfung der Access Units auf funktionaler Ebene erfolgen. Controls könnten durch Überschreibungen von IsVisibleAU / IsEditableAU oder den Actions SetVisible(bool) / SetEnabled(bool) sichtbar bzw. zugänglich gemacht werden. Der Dialog zum Festlegen der Properties IsVisibleAU und IsEditableAU , der beim Klick auf den Button im Property Grid erscheint, zeigt links den kompletten Access Unit Baum und die FormAccessUnit zur Auswahl an. Rechts sind die in der Liste enthaltenen Access Units. Die in der Mitte befindlichen Buttons fügen entweder eine im linken Bereich ausgewählte AccessUnit in der rechten Liste ein (Alle Buttons mit diesem Pfeil: ) oder entfernen sie aus der rechten Liste ( ). Dialog zur Bearbeitung von IsVisibleAU/IsEditableAU:"
  },
  "doc/form/layout-konzept.html": {
    "href": "doc/form/layout-konzept.html",
    "title": "Layout-Konzept",
    "keywords": "Layout-Konzept Control-Hierarchie Die Controls eines Forms sind in einem Baum organisiert. Dabei spielen die Hierarchie und vor allem die Reihenfolge in diesem Baum eine wichtige Rolle. Das Form wird mithilfe von verschiedenen Containern (DockPanel, WrapPanel, FieldPanel), in denen die Controls platziert werden, strukturiert. Ausschließlich die Hierarchie und Reihenfolge der Controls definieren deren Anordnung im Form. Absolute Positionen können nicht angegeben werden. In Ableitungen bzw. im Customizing können neue Container und Controls in der Hierarchie eingefügt werden. Bestehende Container oder Controls können an eine andere Stelle in der Hierarchie verschoben werden. Die Controls ordnen sich auch dann wieder automatisch an. Besonders vorteilhaft ist dies, wenn Sie mehrere Packages miteinander kombinieren. Überlagerungen von Controls kann es so nicht geben – Überlagerungen sind technisch auch gar nicht möglich. Größe von Controls Die Größe von Text-Feldern und Grid-Columns wird durch den Metadatentyp gesteuert. Dort gibt es die Eigenschaften DisplayMinLength , DisplayMaxLength und für Multiline-Felder DisplayMinLines und DisplayMaxLines. Diese Eigenschaften sind in der kompletten Kette von Metadatentyp über DBColumn und Component-Property bis zum Control verfügbar. Am ControlStyle FSGeneral.Controls.BaseControl wird das Property MeasureText angeboten. Die Display-Length-Eigenschaften werden vom Client mithilfe dieses Textes in die realen Größen umgerechnet. Zuzüglich Padding und Border ergibt sich so die Gesamt-Größe des Controls. Die Display-Length Einstellungen sollten soweit wie möglich am Metadatentyp erfolgen. Eine gute Hilfe dabei ist die DataSource Hierarchy Search im Form-Designer. Die Control-Eigenschaften MinSize , MaxSize bzw. GridColumn. Width sollten nur in Ausnahmefällen gesetzt werden, weil dadurch das Control nicht mehr, z.B. auf Änderungen der Schriftgröße, reagieren kann. Tab-Reihenfolge Die Tab-Reihenfolge der Controls wird durch deren Position im Baum bestimmt. Wenn Sie den kompletten Baum von oben nach unten durchlaufen, ergibt sich so die komplette Tab-Reihenfolge. Eine davon abweichende Tab-Reihenfolge kann nicht definiert werden. Individuelle oder von der Situation abhängige Tab-Reihenfolgen können mit dem OnLeave/OnValidate -Event und der SetFocus -Action realisiert werden. Mit dem Property TabStop kann ein Control in der Tab-Reihenfolge übersprungen werden. Deprecated Layout / Migration Öffnen Sie ein „altes“ Form, dann wird mit der Registerkarte Deprecated Layout der alte Form-Designer angezeigt. Dieser funktioniert ganz normal bis zur Umstellung. Form-Designer mit Deprecated Form: Mit dem Button Convert Deprecated Layout wird die Konvertierung in das neue Layout gestartet. Dies geht aber erst wenn alle Basis-Forms in allen Base-Packages dieses Forms umgestellt sind. Es öffnet sich neben dem neuen Form-Designer ein weiteres Fenster Convert Deprecated Layout . Dieses kann auf dem 2. Monitor platziert werden. Convert Deprecated Layout: Form-Designer mit teilwiese migriertem Form: ALLE Controls müssen in den neuen Baum eingehängt werden. Dazu muss das entsprechende Control aus dem alten Control-Baum per Drag & Drap an die richtige Stelle in den Control-Baum des neuen Form-Designers verschoben werden. Im alten Baum wird das Control dann mit einem grünen Hintergrund als verarbeitet markiert. Controls, die nicht in das neue Layout übernommen werden, werden von der Konvertierung ausgeschlossen und mit einem roten Hintergrund markiert. Das sind Controls, die es im neuen Layout nicht mehr gibt (z.B. Panel, StackPanel, Line) – diese sind automatisch ausgeschlossen. Einige Controls können auch vom Entwickler (rechte Maustaste / Exclude ) oder einem Automatismus ausgeschlossen werden (Picture, Label). Ist ein Control verarbeitet, erhält es einen grünen Haken . Ein Container erhält diesen Haken erst dann, wenn auch alle seine Unter-Controls verarbeitet sind. Ziel ist es, dass der komplette Baum – also der oberste Knoten DefaultVariant – verarbeitet ist und diesen grünen Haken erhält. Dann kann das Form kompiliert, getestet und die Konvertierung mit dem Button Complete abgeschlossen werden."
  },
  "doc/form/designer.html": {
    "href": "doc/form/designer.html",
    "title": "Forms",
    "keywords": "Forms Der Form-Designer ist ein Tool, ähnlich dem Designer in Visual Studio, in dem Sie Controls per Drag & Drop auf einem Form positionieren und mit Funktionalität beleben können. Er wird entweder durch einen Doppelklick auf ein entsprechendes Form-Element auf der Registerkarte Namespaces oder durch das Erstellen eines neuen Form-Elements geöffnet. Allgemeiner Überblick Kontextabhängige Registerkarten Registerkarte Default Variant Registerkarte Property Registerkarte Method Registerkarte Functional Controls Registerkarte Available Reports Registerkarte Access Units"
  },
  "doc/ide/allgemeine-funktionatitaeten.html": {
    "href": "doc/ide/allgemeine-funktionatitaeten.html",
    "title": "Allgemeine Funktionalitäten",
    "keywords": "Allgemeine Funktionalitäten Buttons Einige der nachfolgend beschriebenen Buttons werden in unterschiedlichen Zusammenhängen angeboten. Die angebotene Funktion des Buttons bezieht sich daher immer auf den Kontext, in dem der Button dargestellt wird. New: Dieser Button erzeugt ein neues Element. Beim Klick auf den Button wird ein Kontext-Menü angezeigt, mit dem Sie auswählen, was für ein Element erzeugt werden soll. Im Detailfenster einer Component zum Beispiel, können Sie mit diesem Button der Component ein neues Property oder eine neue Methode hinzufügen. Auf der Registerkarte Namespaces können Sie mit diesem Button dem im Objekt-Baum (unterer Baum) dargestellten Namespace neue Namespace Elemente hinzufügen, wie zum Beispiel Metadatentypen , Components , Forms . Delete: Das Element im aktuellen Kontext wird mit dem Button Delete gelöscht. Der Löschvorgang wird erst mit betätigen des Buttons Save All wirksam. Wird das ausgewählte Element noch von einem anderen Element benutzt, wird eine Fehlermeldung mit dem entsprechenden Hinweis angezeigt: Mit dem Button Details wird eine Liste aller Verwendungen angezeigt. Derive: Wenn Sie diesen Button betätigen, wird das ausgewählte Element vererbt. Dies funktioniert bei Metadatentypen, Reports, Forms und Workflows. Customize: Im aktiven Package, also in dem Package, an dem Sie sich angemeldet haben, wird von dem ausgewählten Element eine Customization angelegt. Das bedeutet, dass ein Element, das in einem Basis-Package definiert bzw. programmiert wurde, im aktiven Package geändert werden kann. Diese Funktion steht nur dann zur Verfügung, wenn die verwendete Package-Lizenz (PKL) des Ursprungs-Packages Customizing für diesen Elementtyp freigeschaltet ist. Save: Speichert die Änderungen des Elements im aktuellen Kontext ab. Alle Änderungen werden erst beim Save in das Repository zurückgeschrieben. Geänderte, aber noch nicht gespeicherte Elemente werden mit einem Stern nach dem Namen gekennzeichnet. Save All: Alle Änderungen im gesamten Projekt werden über diesen Button gespeichert. Undo Until Last Save: Mit diesem Button nehmen Sie alle Änderungen seit der letzten Speicherung zurück. Source-Control In Framework Studio kann immer nur ein Entwickler an einem Element arbeiten. Dazu muss dieser das zu bearbeitende Element auschecken. Die anderen Entwickler können das Element weiterhin in dem Stand öffnen, wie es war, bevor es ausgecheckt wurde. Wenn alle Änderungen an dem Element durchgeführt wurden, kann es wieder eingecheckt werden. Ab diesem Zeitpunkt werden die Änderungen auch für alle anderen Entwickler sichtbar. Warning Ein Element kann immer nur von einem Entwickler ausgecheckt werden. Für die Bedienung der Source-Control-Funktionalität stehen folgende Buttons zur Verfügung: Check Out: Checkt das Element aus, d.h. sperrt es für Änderungen durch andere Entwickler, damit Sie es bearbeiten können. Ist das Element bereits von einem Entwickler ausgecheckt, bekommen Sie eine entsprechende Fehlermeldung. Check In: Der Button Check In checkt das Element ein. Alle Entwickler sehen ab jetzt das von Ihnen aktualisierte Element. Ein anderer Entwickler kann das Element jetzt erneut auschecken. Undo Check Out: Hiermit machen Sie einen Check Out rückgängig. Dabei werden alle Änderungen, die nach dem Check Out gemacht wurden, verworfen. Bevor diese Funktion ausgeführt wird, werden alle Änderungen an ungespeicherten Elementen gespeichert ( Save All ). Sollte aufgrund von Abhängigkeiten beim Undo Check Out ein Problem auftreten, so startet Framework Studio neu, um weiterhin Datenkonsistenz garantieren zu können. Warning Diese vier Befehle können Sie auch über das Kontext-Menü des Elements aufrufen. Source Control im Kontext-Menü: Compile Compile Options: Der Button Compile Options öffnet ein Kontextmenü, in dem Sie alle Optionen für den nächsten Kompiliervorgang festlegen können. Außerdem können Sie über dieses Kontextmenü einen Kompiliervorgang starten. Ergänzende Informationen erhalten Sie im Abschnitt Code Builder . Applications: Öffnet den Applications–Optionen-Dialog, in dem Sie u.a. einstellen können, in welchem Verzeichnis der IL-Code hinterlegt werden soll und wie sich der Session-Storage verhalten soll. Außerdem werden dort einige grundlegende Einstellungen bezüglich Design und Frameset der jeweiligen Anwendung festgelegt. Ergänzende Informationen können Sie dem Abschnitt Applications entnehmen. References: Der References–Dialog dient dem Einbinden von Assemblies. Wenn Sie weitere Informationen dazu benötigen, lesen Sie bitte den Abschnitt References . Icons Is Not Checked Out: Dieses Icon vor einem Element bedeutet, dass dieses Element bei dem angemeldeten Entwickler eingecheckt ist. Wollen Sie ein Element bearbeiten, müssen Sie es zuvor auschecken. Is Checked Out: Steht dieses Icon vor einem Element, ist das Element bereits von Ihnen ausgecheckt und kann bearbeitet werden. Wenn Sie mit der Bearbeitung fertig sind, können Sie das Element wieder über das Source-Control einchecken. Haben Sie ein Element versehentlich ausgecheckt, können Sie den Checkout-Vorgang mit Undo Checkout rückgängig machen. Warning Sie sollten darauf achten, dass Sie einen kompilierbaren Stand haben,bevor Sie ein Element wieder einchecken. Dazu ist es erforderlich auch in Zusammenhang stehende Elemente einzuchecken. Version History Sowohl über das Kontextmenü eines Objekts im Objektbaum auf der Registerkarte Namespaces als auch über das Hauptmenü können Sie sich unter dem Menüpunkt View/Version History einen Überblick über die einzelnen Entwicklungsstufen eines Objektes verschaffen. Dazu werden von allen bisher eingecheckten Versionen Versionsnummer, Benutzer, Datum, Kommentar und die Information, ob die Version bereits inspiziert wurde, angezeigt. Version History Report: Objekttyp und Name sowie der vollständige Name des Objektes (mit Namespaces) werden im Kopf des Reports angezeigt. Wenn zum Zeitpunkt der Reporterstellung ein Benutzer das Objekt ausgecheckt hat, so wird das mit dem blau gefärbten Kommentar „Checked out.“ unter der neuesten Versionsnummer ebenfalls in der Tabelle dargestellt. Über die Symbole am oberen Fensterrand wird Ihnen die Möglichkeit zum Drucken, Vergrößern, Blättern und Speichern des Reports bereitgestellt. Dieser Report steht Ihnen für alle Access Units, Components, Collections, Control Default Styles, Custom Controls, Datasources, DBTables (Tabellen im Database Editor), Forms, Global Events, Global Objects, Metadatatypes, Namespaces, Report Document Types, Resources and Workflows zur Verfügung. Source Control History Über den Menüpunkt Source Control/History im Hauptmenü von Framework Studio wird ein Report geöffnet, der einen Überblick über alle Check-In und Check-Out Vorgänge innerhalb des aktuellen Labels ermöglicht. Mit diesem Report können Sie sich einen guten Überblick darüber verschaffen, was sich seit einem bestimmten Datum geändert hat, welche Elemente im Moment noch ausgecheckt sind und welche Elemente noch nicht vom FrameworkCompiler kompiliert wurden. Ein Vergleich des generierten Codes mit der Vorgängerversion oder der aktuellen Version ist ebenfalls möglich. Source Control History: Es gibt zwei Modi: Checked In: Es werden nur eingecheckte Elemente ab dem angegebenen Datum angezeigt. Checked Out: Es werden alle im Moment ausgecheckten Elemente angezeigt. Mit dem Button Refresh wird die Tabelle aktualisiert. Durch Anklicken der Spaltenüberschrift kann nach allen Spalten sortiert werden. Die Tabelle kann über die Zwischenablage in andere Programme kopiert werden. Die Druckvorschau und der Druckdialog lassen sich über das Kontextmenü der Tabelle und mit den Buttons Print bzw. Preview öffnen. Besondere Spalten: Date: Ist der Text hellrot hinterlegt, wurde dieses Element noch nicht vom FrameworkCompiler kompiliert (Datum größer als das Datum des letzten „Refresh Workspace“ des FrameworkCompilers). Ist der Text gelb hinterlegt, wurde dieses Element zwar noch nicht vom FrameworkCompiler kompiliert, aber vom Benutzer über Get latest Check Ins im Workspace aktualisiert. Name: Durch anklicken eines Elements in dieser Spalte wird das Element im Designer geöffnet. Version: Durch anklicken einer Version kann der generierte Code des Elements mit der aktuellen Version oder der Vorgängerversion verglichen werden. Dazu öffnet sich nach dem Anklicken ein Dialog, in dem Sie die Vergleichsversion auswählen können. Get latest Check Ins Über den Menüpunkt Source Control/Get latest Check Ins kann ein Dialog aufgerufen werden, über welchen der Benutzer-Workspace bis zu einem bestimmten Zeitpunkt aktualisiert werden kann, ohne dass ein FrameworkCompiler angestoßen werden muss. Der Dialog ist ähnlich der Source Control History aufgebaut. Er zeigt allerdings nur Elemente, die die folgenden zwei Kriterien erfüllen: Sie sind NACH dem letzten Refresh Workspace des Users eingecheckt Sie sind von anderen Usern eingecheckt Anders ausgedrückt zeigt die Liste alle von anderen Usern eingecheckten Elemente, die dem Workspace des aktuellen Users noch nicht bekannt sind. Beispiel: Benutzer demo1 und Benutzer demo2 holen sich nach einem nächtlichen Compilerlauf den FrameworkCompiler-Workspace. demo1 checkt Elemente aus, ändert sie und checkt sie wieder ein. Versucht demo2 diese Elemente nun auszuchecken, wird FS feststellen, dass neuere Versionen der Elemente verfügbar sind, die dem aktuellen Workspace noch unbekannt sind. Diese Elemente werden dann in der Liste von „Get latest Check Ins“ angezeigt (siehe Bild). In der Source Control History werden diese Elemente rot markiert dargestellt, da sie nach dem Compilerlauf eingecheckt wurden und dem aktuellen Workspace von demo2 nicht bekannt sind. Im Dialog hat der Benutzer nun die Möglichkeit, über die Checkboxen auszuwählen, bis zu welchem Zeitpunkt/Element er seinen Workspace updaten will. Nach dem Klick auf Refresh Elements startet sich Framework Studio automatisch neu. Dabei wird der Benutzer-Workspace genau bis zum ausgewählten Zeitpunkt/Element (im Beispiel frmCompany, 04.11.2011 14:20:23) aktualisiert. Die Elemente CompanyName , cdCompany und frmCompany können nun vom Benutzer demo2 ausgecheckt und bearbeitet werden, obwohl noch kein FrameworkCompiler gelaufen ist. In Get latest Check Ins verbleibt nur noch das Element OrderText . In der Source Control History erscheinen die aktualisierten Elemente nun gelb . Important Bei der Auswahl des Zeitpunkts/Elements bis zu dem aktualisiert werden soll, muss auf zusammenhängende Check Ins geachtet werden. Wenn z.B. frmCompany den Metadatentyp OrderText benötigt, dieser jedoch nicht mit aktualisiert wird (wie im Beispiel), kann es anschließend zu Compile-Fehlern kommen, da OrderText im Workspace nicht gefunden werden kann. Alle über Get latest Check Ins aktualisierten Elemente werden nach dem Neustart von Framework Studio automatisch zur Compile-Liste hinzugefügt. Copy Fullname. In allen Editoren gibt es im Menü Edit den Menüpunkt Copy Fullname . Dieser legt den Namen des Elementes inkl. Namespace in die Zwischenablage. So kann dieser z.B. in Dokumentationen eingefügt werden. GoTo Customization Top: Wechsel zur obersten Customization. Customization Up: Wechsel zur nächst höheren Customization. Customization Down: Wechsel zur nächst tieferen Customization. Customization Root: Wechsel zur Definition des Elements, also dem Basiselement, auf das die unterste Customization aufsetzt. Vorwärts- und Rückwärtsnavigation Framework Studio merkt sich bei jedem Verlassen eines Code Editors, über den grundsätzlich Methodencode bearbeitet werden kann, die aktuelle Cursorposition zusammen mit der Information, welche Methode gerade verlassen wird. Dies gilt für Methoden an Forms, Components, Proxies, Services, Service Hosts und in den Get- und Set-Methoden von Individual Properties an Components. Neben den Code-Editoren kann zusätzlich zwischen den LabeldRecords und den Controls des Form-Designers hin und her navigiert werden. Es werden maximal 25 Einträge gespeichert. Wenn ein Eintag eingefügt werden soll und alle 25 Speicherplätze bereits belegt sind, wird zuvor der älteste Eintrag verworfen. Mit dem Menüpunkt View/Navigate Backward (Tastenkombination ALT + Pfeil Links ) kann jeweils zum zuvor gespeicherten Eintrag navigiert werden. Mit dem Menüpunkt View/Navigate Forward (Tastenkombination ALT + Pfeil Rechts ) kann zum jeweils nächsten gespeicherten Eintrag navigiert werden, wenn zuvor rückwarts navigiert wurde. Method History Browser Bei allen Elementen, die Methoden enthalten (z.B. Forms, Components, Services, FSTransformations, …) können Sie im Designer-Fenster mit dem Menüpunkt View / Method History Browser oder über das Kontextmenü im Editor, Methoden in verschiedenen Versionen innerhalb des Packages des Elements vergleichen. Dazu wählen Sie zunächst die Package-Version, anschließend die Element-Version und zuletzt die Methode aus, die betrachtet werden soll. Mit dem Button Compare with current kann diese Version der Methode mit der aktuellen Version verglichen werden. Mit dem Button Compare with previous kann die ausgewählte Version mit der ersten Vorgängerversion verglichen werden, die eine Änderung aufweist. Zum Vergleich wird ein externes Programm verwendet, welches mit dem Menüpunkt Tools / Options im Hauptfenster konfiguriert werden muss. Dort muss auf der Registerkarte Utilities der Pfad zum Werkzeug bei Diff Tool eingetragen werden. Bei Diff Tool Data Dir muss ein Verzeichnis ausgewählt werden, in das temporär die zu vergleichenden Dateien geschrieben werden können. Gut geeignet ist beispielsweise das frei verfügbare Vergleichswerkzeug WinMerge . Element History Browser Im Designer Fenster aller Elemente für die Code generiert wird (Components, Forms, Workflows, …), lässt sich über den Menüpunkt View / Element History Browser analog zum Method History Browser ein Dialog öffnen, mit dem die Historie des Elements im Package des Elements betrachtet werden kann. Der Element History Browser zeigt den generierten Code zu der ausgewählten Version an und ermöglicht über den Button Compare with current einen Vergleich mit der aktuellen Version. Mit dem Button Compare with previous kann mit der direkten Vorgängerversion verglichen werden. Methoden-Wächter Für Form-Methoden, Component-Methoden, ServiceProxy-Methoden, FsTransformation-Methoden, ServiceHost-Methoden, sowie get- und set-Methoden von Individual und DataContract Properties steht ein Methoden-Wächter zur Verfügung. Dieser kann bei überschriebenen Methoden alle Basis-Methoden und deren Änderungsstatus überwachen. Wird bei einem Compile festgestellt, dass sich in einer Basis-Methode etwas geändert hat, wird eine Compiler-Warning (FSWarn[2029]( !TODO LINK )) ausgegeben: Methoden-Wächter Warnung: Der Wächter lässt sich über den Button in der Toolbar aktivieren: Aktivierung Methoden-Wächter: Ist der Wächter aktiviert, ändert sich das Symbol des Buttons in ein Refresh-Icon und der Button zum Deaktivieren des Wächters wird aktiv. Refresh- und Disable Buttons: Befinden sich mehrere Packages unter dem aktuellen Package, in dem der Methoden-Wächter aktiviert ist, wird nicht nur die direkte Basis-Methode überwacht, sondern der gesamte Basispfad bis zur virtual -Methode. Werden bei einem Compile Änderungen an einer der Basis-Methoden festgestellt, kann der Methoden-Wächter aktualisiert werden. Damit wird vom Entwickler bestätigt, dass die Änderung in der Basis-Methode keine Auswirkung auf den aktuellen Code hat. Mit dem Aktualisieren des Methoden-Wächters wird auch die Warnung während des Compile-Vorgangs eliminiert. Aktualisierung des Methoden-Wächters: Sollten beim Deaktivieren des Wächters noch nicht bestätigte Änderungen in den Basis-Methoden vorhanden sein, wird zuvor nochmals explizit gewarnt: Warnung beim Deaktivieren:"
  },
  "doc/html-client/mobile/standort.html": {
    "href": "doc/html-client/mobile/standort.html",
    "title": "Standortbestimmung",
    "keywords": "Standortbestimmung Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser. Der Mobile Client unterstützt die Bestimmung des aktuellen Standorts. Abhängig vom Gerät und abhängig davon, ob GPS aktiviert ist, wird entweder der GPS-Sensor angesprochen oder eine Annäherung des Standoprtes über das Mobile Netzwerk angestoßen. Action GetGeoLocation() Der Vorgang wird am Form über die Action GetGeoLocation() gestartet. // Aufruf der Action beim Click eines Buttons protected virtual void FE_btn_OnClick(FrameworkButtonEventArgs e) { this.GetGeoLocation(this.GetGeoLocationCallback, \"Start\"); } Wenn der Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die empfangenen Standortdaten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkGeoLocationInfo übergeben. public virtual void GetGeoLocationCallback(IFrameworkGeoLocationInfo info) { this.Reset(); if (info.HasError) { this.sError = info.ErrorMessage; } else { if (info.Identifier == \"Start\") { this.sInfo = \"Start location of our journey\"; } else { this.sInfo = \"Destination location of our journey\"; } this.sIdentifier = \"Identifier: \" + info.Identifier; this.sLatitude = \"Latitude: \" + (info.Latitude.HasValue ? info.Latitude.ToString() : \"N/A\"); this.sLongitude = \"Longitude: \" + (info.Longitude.HasValue ? info.Longitude.ToString() : \"N/A\"); this.sAltitude = \"Altitude: \" + (info.Altitude.HasValue ? info.Altitude.ToString() : \"N/A\"); this.sAccuracy = \"Accuracy: \" + (info.Accuracy.HasValue ? info.Accuracy.ToString() : \"N/A\"); this.sHeading = \"Heading: \" + (info.Heading.HasValue ? info.Heading.ToString() : \"N/A\"); this.sSpeed = \"Speed: \" + (info.Speed.HasValue ? info.Speed.ToString() : \"N/A\"); this.sTimestamp = \"Timestamp: \" + (info.Timestamp.HasValue ? info.Timestamp.ToString() : \"N/A\"); } } Note Wie an den Nullable-Typen zu sehen ist, können Abhängig vom Gerät und dessen Sensorik ggf. einzelne Werte der oben gegebenen Auflistung nicht verfügbar sein. Es ist zwingend nötig, vor der Verarbeitung immer auf die Verfügbarkeit der Werte zu prüfen. Berechtigung für die Bestimmung des Standortes Die GetGeoLocation-Action benötigt auf dem Endgerät die Berechtigung zur Bestimmung des Gerätestandortes. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden."
  },
  "doc/html-client/mobile/kamera.html": {
    "href": "doc/html-client/mobile/kamera.html",
    "title": "Kamera",
    "keywords": "Kamera Note Dieses Feature steht nur in der Android-App zur Verfügung. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem oder die Kamera zuzugreifen. Dadurch hat der Mobile Client auf mobilen Geräten als App mehr Möglichkeiten als im Browser. Über die in einem mobilen Gerät integrierte Kamera können im Mobile Client Bilder gemacht und zum Broker geschickt werden. Alternativ können schon vorhandene Bilder aus der Bildergallerie ausgewählt werden. Action TakePhoto() Der Vorgang wird am Form über die Action TakePhoto() gestartet. // Aufruf der Action beim Click eines Buttons protected virtual void FE_btn_OnClick(FrameworkButtonEventArgs e) { this.TakePhoto(this.TakePhotoCallback, CameraSource.CAMERA, \"Camera\"); } Wenn der Vorgang am Client abgeschlossen ist, wird die übergebene Callback-Methode aufgerufen. In ihr können die empfangenen Bilddaten weiterverarbeitet werden. Der Callback-Methode wird dafür ein Objekt mit dem Typ IFrameworkPhotoInfo übergeben. public virtual void TakePhotoCallback(IFrameworkPhotoInfo info) { this.Reset(); if (info.HasError) { this.sMessage = info.ErrorMessage; } else if (info.ImageBytes == null) { this.sMessage = \"ImageData is null\"; } else { if (info.Identifier == \"Camera\") { this.sMessage = \"Image from camera\"; } else { this.sMessage = \"Image from gallery\"; } this.binImage = info.ImageBytes; } } Berechtigung für Kamera und SD-Karte Die TakePhoto-Action benötigt auf dem Endgerät Berechtigungen für die Benutzung der Kamera sowie für das Lesen und Schreiben von Daten (Bildern) auf die SD-Karte bzw. den internen Gerätespeicher. Diese Berechtigungen müssen z.B. auf einem Android-Gerät einmalig erteilt werden."
  },
  "doc/form/control/image-button.html": {
    "href": "doc/form/control/image-button.html",
    "title": "Image Button",
    "keywords": "Image Button Properties/Events Actions Ein Image-Button ist ein Bild, das sich wie ein Push-Button verhält. Wenn Sie dem Image-Button als Bild eine GIF-Datei mit transparentem Hintergrund zuweisen, können Sie, wie die Abbildung zeigt, Buttons in beliebigen Formen erstellen. Dem Button können Sie vier verschiedene Bilder zuweisen. Ein Bild für den normalen Zustand, eins das angezeigt wird, wenn der Button disabled ist, eins das angezeigt wird, wenn sich die Maus über dem Button befindet und eines, das dann angezeigt wird, wenn auf den Button geklickt wird."
  },
  "doc/form/control/grid.html": {
    "href": "doc/form/control/grid.html",
    "title": "Grid",
    "keywords": "Grid Properties/Events Actions Das Grid stellt Daten in tabellarischer Form dar. Dem Client bietet das Grid außerdem die Möglichkeit die Daten per Mausklick auf den entsprechenden Spaltenkopf sortiert darzustellen. Gedrückthalten der Umschalttaste ermöglicht es, auch mehrere Spalten eines Grid Controls per Mausklick zu sortieren. Dabei hat die zuerst (ohne Umschalttaste) ausgewählte Spalte die höchste Priorität. Durch weitere Klicks mit Umschalttaste kann das zweite, dritte, … Sortier-Kriterium angegeben werden. Wenn der Kopf einer bereits sortierten Spalte erneut mit gedrückter Umschalttaste angeklickt wird, dann wird für diese Spalte die Sortier-Richtung geändert (aufsteigend, absteigend, unsortiert) und sie wird als Sortier-Kriterium niedrigster Priorität hinten angestellt. Das Kontextmenü eines Spaltenkopfs arbeitet ausschließlich im Mehrfach-Sortierungs -Modus und enthält einen weiteren Eintrag, um sämtliche Sortierungen zurückzusetzen: Außerdem kann auch für jede Spalte ein Filter über das Kontextmenü definiert werden. Hier gilt ebenfalls die Regel, dass das Kontextmenü grundsätzlich Mehrfach-Filterung zulässt und eine Möglichkeit zum Zurücksetzen bietet. Der Filterdialog erscheint durch den Kontextmenüeintrag Filter / Filter anpassen . Bei Spalten mit Datumswerten kann durch Rechtsklick auf das darin enthaltene Eingabefeld ein Kalender aufgerufen werden: Allgemeines zu den Row-Icons Hinter jedem Grid steckt eine Collection und hinter jeder Zeile ein Objekt aus der Collection. Das Row-Icon zeigt den Status dieses Objekts an ( neu , geändert oder gelöscht ). Das Property RowHeader muss auf DisplayRowStatus eingestellt sein, damit die Icons angezeigt werden."
  },
  "doc/form/control/grid-column.html": {
    "href": "doc/form/control/grid-column.html",
    "title": "Grid-Column",
    "keywords": "Grid-Column Properties/Events Actions Ist einem Grid eine Collection als Datasource zugewiesen, können die Properties des Collection-Objekts dem Grid als Columns zugewiesen werden."
  },
  "doc/form/control/form-container.html": {
    "href": "doc/form/control/form-container.html",
    "title": "FormContainer",
    "keywords": "FormContainer Properties/Events Actions Der Form Container ist ein Panel, welches genau eine Instanz eines Formulars enthalten kann. Um hierin ein Formular zu öffnen, muss am Workflow Link der Container -Wert gesetzt werden: Wird ein Formular in einem FormContainer geöffnet, der bereits ein Formular beinhält, so wird das alte zuvor entfernt."
  },
  "doc/form/control/context-menu.html": {
    "href": "doc/form/control/context-menu.html",
    "title": "ContextMenu",
    "keywords": "ContextMenu Properties/Events Actions Buttons und ImageButtons können bei Betätigung ein Kontextmenü öffnen. Dazu muss dem Button über das Property ContextMenu ein ContextMenu zugeordnet werden. Das Control ContextMenu stellt lediglich eine Hülle dar, in der alle Menüeinträge gesammelt werden, die angezeigt werden sollen, wenn das Kontextmenü geöffnet wird. Ein neues ContextMenu lässt sich im Form-Designer ( Allgemeiner Überblick ) auf zwei Arten per Drag&Drop anlegen: Aus der Toolbox ( Registerkarte Toolbox ) heraus auf die DefaultVariant des Forms (also auf den Hintergrund des Forms) im Designer-Fenster: Das Kontextmenü wird angelegt und ist keinem Button zugeordnet. Aus der Toolbox heraus direkt auf einen Button (oder ImageButton ) : Das Kontextmenü wird angelegt und dem Button zugeordnet. Der Name wird dabei mit men, gefolgt von dem Namen des Buttons, vorbelegt. Kontextmenüs werden im ClassView ( Registerkarte Class ) immer im Teilbaum unterhalb der DefaultVariant ggf. parallel zum Hauptmenü ( MainMenu ) angezeigt. Am Kontextmenü können im ClassView (wie bei anderen Menüs) neue Menüeinträge über den Eintrag New MenuItem im Kontextmenü des Treeviews angelegt werden. Warning Beim Löschen eines Kontextmenüs wird nicht überprüft, ob das Kontextmenü bereits einem Button zugeordnet ist."
  },
  "articles/release-4-2.html": {
    "href": "articles/release-4-2.html",
    "title": "Release-Information Framework Studio 4.2",
    "keywords": "Release-Information Framework Studio 4.2 4.2.9 (28.08.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.9_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020083454 - JavaClient : Wird eine Anwendung als \"Frameless\" gestartet (z.B. der Pick-Monitor in eNVenta ERP), dann kann es passieren, dass eine Fehlermeldung angezeigt wird: Java-Exception: The frame is displayable. 2020083525 - Oracle : Beim automatischen Datenbank-Update kann es vorkommen, dass das Einlesen der Struktur-Informationen sehr lange dauert. 2019016813 - IDE : Wird eine Text-Collection per Paste in eine bestehende Text-Collection gemerged, werden die ausgewählten Texte in der Summary-Registerkarte nicht angezeigt. 2020011256 - IDE : Im Documentation-Editor wird beim Rückgängig machen der letzten Aktion (STRG+Z) der gesamte Text gelöscht, wenn lediglich eine neue Section hinzugefügt wurde oder seit dem CheckOut nichts verändert wurde. 2020062830 - IDE : Ändert man an einem Property im Getter oder Setter die Checkbox \"Write Individual\", dann wird der Methoden-Code nicht aktualisiert. 2020073327 - IDE : Beim Copy&Paste einer TextCollection werden die MLKeys nicht übertragen. 2020073331 - IDE : Nach Einfügen einer Text-Collection wird den Save-Button nicht aktiviert. 2020073346 - IDE : Im ClassView werden die Member nicht korrekt nach Name sortiert. 2020073361 - IDE : Wird im Basis-Form eine Form-Methode gelösch, die in einem Control-Event zugeordnet ist, dann wird in der Event-Zuordnung im agbeleiteten Form diese Methode weiterhin angezeigt. 2020073369 - IDE : Führt man im Workflow-Editor einen Doppel-Klick auf ein Global-Event aus um dieses zu öffnen, dann wird eine Exception angezeigt. Ein weiterer Doppel-Klick öffnet das Global-Event. 2020073372 - IDE : Wird ein neues Global-Event angelegt, dann wird eine SQL-Exception ausgelöst. Ein Speichern ist nicht mehr möglich. 2020083515 - IDE : Wird ein als Imported gekennzeichneter View customized, dann ist im Customizing die Checkbox \"Imported\" nicht aktiv. In der Folge wird beim Compile der DBTables ein Error ausgegeben: #error: 'FSErr[1064] No view definition has been specified. 2020083531 - IDE : Wird ein DataContract, dessen Contract Type auf \"IList\" oder \"Array\" steht, customized, dann wird in der Customization der Typ \"Single Item\" angezeigt. Note Wenn so ein Fall entstanden ist, dann muss der DataContract im Customizing-Package gelöscht und neu customized werden. 2020083513 - HTML Client : Ist an einem modalen Form \"HideModalHeader = true\" gesetzt, so wird mit dem Back-Button auf Android-Geräten nicht das Form geschlossen, sondern versucht, die Session zu beenden. 4.2.8 (31.07.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.8_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . HTML Client Neuerungen MLKeys und Preview im TemplateControl und ListView Im HTML-Editor des TemplateControls und ListViews können jetzt MLKeys verwendet werden. Außerdem gibt es dort nun eine Preview-Funktion. Weitere Informationen: TemplateControl und ListView . Unterstützung für das TabbedWindow Control Das TabbedWindow Control wird nun in vollem Umfang vom HTML Client unterstützt: Volle Unterstützung der TabTemplates Horizontale und vertikale ausrichtung Verwendung des DataSource -Properties, um TabPages aus dem Code heraus zu selektieren Overflow-Verhalten bei zu vielen Tabs: Sind die Tabs zu breit oder zu hoch für das Display, kann ganz einfach mit dem Mausrad oder per Touch auf mobilen Geräten durch die Liste gescrollt werden OnSelectedTabPageChange und OnSelectedTabPageChanged Events Modale Dialoge ohne Header Über ein neues Property HideModalHeader am Form kann der Header (mit Titel und Close-Button) ausgeblendet werden, wenn es als modaler Dialog aufgerufen wird. So steht etwas mehr Platz zur Verfügung. Da mit dem Header auch der Close-Button verschwindet, muss der Aufruf von this.Close() am Form anderweitig erfolgen, z.B. durch einen eigens implementieren Button oder ein Event. Fullscreen Der HTML Client wird auf mobilen Geräten ab sofort im Fullscreen-Modus ausgeführt. So steht noch etwas mehr platz für Controls zur Verfügung, da die Statusleiste und Softbuttons des Geräts die App nun überlappen. Form BadgeImages Zusätzlich zu den ImageButtons werden BadgeImages nun auch am Form über das Property BadgeImage DataSource unterstützt. Korrigierte Fehler 2020073096 - JavaClient : Wird die Anwendung über den FSClient-Launcher gestartet, dann erfolgt bei mehreren Anwendungen keine Gruppierung in der Windows Taskleiste. Note Jetzt erfolgt die Gruppierung in der Taskleiste nach der Adresse des Brokers. 2020073176 - Java-Client : Beim Entfernen und wieder Einfügen von dynamischen Grid-Spalten wird die Einfügereihenfolge nicht beachtet. 2020073067 - Oracle : Die Update-Logik in der Anwendung erzeugt Exceptions, wenn in der Business-DB Trigger ohne Tabellen-Bezug existieren. 2020073177 - Oracle : Bei paralleler Verarbeitung kann es passieren, dass der Connect zur Oracle-Datenbank eine Exception 'Timeout bei Verbindungsanforderung' erzeugt. Das betrifft z.B. das parallele Einlesen der Daten beim Start der IDE und das parallele Erzeugen von GlobalObjects in Services und im E-Gate. Note Beim Start der IDE wird jetzt die Anzahl der zusätzlichen Repository-Connections auf 8 erhöht. Mit dem Bug 2020062828 wurde für Oracle die Anzahl auf 4 begrenzt. 2020073201 - Package-Manager : Beim Branch einer Package-Version gehen alle MLKeys verloren. 2020072990 - IDE : In Methoden an Services und ServiceProxies generiert der Exception Editor Wizard durch die Verwendung von \"this.Global\" nicht kompilierbaren Code. 2020073068 - IDE : Der Documentation Chapter Tree wird falsch sortiert. Wenn man die Reihenfolge ändert, wird beim nächsten Öffnen des Chapter Tree wieder die falsche Reihenfolge angezeigt. 2020073205 - IDE : Beim Kopieren von Controls kann es zu einer NullReferenceException kommen. 2020073292 - IDE : Wenn man nach dem Laden eines Settings im Run- oder PublishWizard Framework Studio neu startet, gehen die Setting-Einstellungen verloren. 2020073317 - IDE : Wird ein neues Global-Object angelegt, dann wird dieses nach dem Wechsel auf einen anderen Namespace nicht mehr im Namespace-Baum angezeigt. 2020073335 - IDE : Bei der Bearbeitung des Source-Events im Workflow-Link kann es zu einem Absturz der IDE kommen. 2020073350 - IDE : Bei der Arbeit mit Text-Collections kann es passieren, dass in den Code der Text-Collection fälschlicherweise 2 Properties \"ID\" und \"Text\" generiert werden. In der Folge kann das zu Compile-Fehlern führen, wenn dadurch der Component-Code evtl. nicht zum Interface-Code passt. 2020073078 - Framework : Beim Neustart der Endanwendung unter Beibehalt des angemeldeten Benutzers wird der AuthenticationService nicht kontaktiert, um die Benutzerrollen neu auszuwerten. 2020072975 - HTML Client : Das OnValidated-Event wird gefeuert, obwohl sich im Textfeld nichts geändert hat. 2020073049 - HTML Client : Buttons und ImageButtons berechnen ihre Höhe unabhängig vom ShowCaption-Property. 2020073066 - HTML Client : In einem FieldPanel mit \"SynchronizedColumns = true\" wird für ausgeblendete Control Labels ggf. Platz reserviert, wodurch das Layout durcheinander gebracht wird. 2020073075 - HTML Client : FieldRows mit dem LabelMode \"None_Fill\" verursachen zur Laufzeit eine Exception, wenn das zugehörige FieldPanel \"SynchronizedColumns = true\" gesetzt hat. 2020073097 - HTML Client : Ausgeblendete Controls werden in manchen Situationen in der Fokusreihenfolge beachtet. Dies hat zur Folge, dass der Fokus ggf. in einem Control vor einem ausgeblendeten Control festhängt. 4.2.7 (26.06.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.7_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020031817 - Java-Client : Die Shortcuts Ctrl-H, Ctrl-T, Ctrl-Shift-T und Ctrl-Shift-O funktionieren nicht, wenn sich der Fokus in einem (Html)-Eingabefeld befindet. 2020062855 - Publish2Go : Wird eine Application per Publish2Go gepublished, kann es passieren, dass bei einer Application die Einstellung für den HTML-Client falsch ausgewertet wird. Auf der Broker-Startseite wird dann die Option \"HTML\" nicht angeboten. Oder bei mehren Applications wird die Option \"HTML\" fälschlicherweise bei einer normalen Application angeboten. Note Publish2Go-Pakete müssen mit der neuen Version komplett neu erzeugt werden, damit die Korrektur wirksam wird. 4.2.6 (16.06.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.6_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020052640 - IDE : Leitet man von einer Basis-Formklasse aus einem Basis-Package ab (Derive), zu der es eine Customization im aktuellen Package gibt, so kommt es zu einer Fehlermeldung und der Ableitung fehlen anschließend Controls. 2020062773 - IDE : Beim Copy&Paste wird der Control-Style nicht übertragen. Wird im Form-Designer ein neues Control mit einem vererbten Control-Style angelegt, dann wird der \"Control-Type\" auf eine alte Art verschlüsselt. 2020062779 - IDE : Wurde ein Control-Type gelöscht, dann führt das beim Öffnen eines Forms in der IDE und beim Compile zu einer Exception. Das passiert auch, wenn die betroffenen Controls bereits auf \"gelöscht\" stehen. 2020062828 - IDE : Das parallele Einlesen der Objekt-Daten beim Start der IDE mit mehreren Datenbank-Verbindungen bereitet unter Oracle Verbindungs-Probleme. Note Neues Verhalten nach der Korrektur. Unter Oracle wird die maximale Anzahl der zusätzlichen Repository-Verbindungen auf 4 begrenzt. Unter SQL-Server werden jetzt maximal 8 zusätzliche Verbindungen geöffnet. Nach 15 Sekunden werden die zusätzlichen Verbindungen wieder geschlossen. 2020062840 - IDE : Unter Oracle kommt es beim Checkout einer Textcollection zu einer Datenbank-Exception: ORA-00932: Inkonsistente Datentypen: CHAR erwartet, NUMBER erhalten. 4.2.5 (29.05.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.5_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Framework Studio Performance verbessert Die Performance der Framework Studio IDE wurde erheblich verbessert. Besonders zu spüren ist das beim Öffnen großer Elemente in Customizing Packages. Auch die Laufzeit des Compile-Wizard hat sich signifikant verringert. Erreicht wurde diese Verbesserung dadurch, dass die IDE beim Start einmal alle relevanten Informationen aus der Repository-Datenbank einliest. Direkt nach dem Start der IDE ist ein höherer Verbrauch an Arbeitsspeicher zu beobachten. Bei längerer Arbeit relativiert sich dieser Effekt, da die IDE bisher auch schon sehr viele Informationen in den Arbeitsspeicher gelesen hat. Um eine bessere Performance zu erzielen, werden die Daten parallel über mehrere Datenbank-Verbindungen eingelesen. Das bedeutet, Framework Studio öffnet in kurzer Zeit bis zu 8 zusätzliche Verbindungen zur Repository-Datenbank. Die zusätzlichen Verbindungen werden nach spätestens 15 Sekunden wieder geschlossen. MDT- und DBColumn-Änderungen im Service Release Im Service-Release-Modus können jetzt am Metadatentyp und an der DB-Column die folgenden Eingenschaften geändert werden: Caption, Tooltip, Description DisplayMinLength, DisplayMaxLength DisplayMinLines, DisplayMaxLines Korrigierte Fehler 2020042334 - Java-Client : Die Windows-Skalierung hat keinen Einfluss auf die Skalierung des Browser Controls. 2020042358 - Java-Client : In einer Grid-Combobox kann der Leer-Eintrag nicht ausgewählt werden, wenn an dem zugrundeliegenden Metadatentypen Values oder Value-Ranges definiert sind. 2019027232 - IDE : Es kommt vor, dass nach der Suche der Ergebnis-TreeView ganz nach rechts gescrollt wird. 2020031851 - IDE : Im \"Generated Code\"-Fenster und in der Method-History führt ein Klick mit der rechten Maustaste zu einer Exception. 2020042348 - IDE : Eine Exception wird geworfen, wenn der Datenbankname beim Anmelden an einem Repository ein Leerzeichen am Ende beinhaltet. 2020052462 - IDE : Der Form-Designer zeigt keine Control-Images an, wenn man ein Theme ungleich \"Default\" auswählt. Lediglich im Theme veränderte Bilder werden angezeigt. 2020052447 - Package Manager : Wird für eine Package-Version, die sich im Service-Release-Modus befindet, der Compile-Wizard ausgeführt, dann werden die Metadatentypen und DBTables nicht compiliert. Dadurch werden z.B. Änderungen an der Caption nicht gezogen. 4.2.4 (24.04.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.4_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020021741 - Java-Client : Werden in ein Html-Texteingabefeld mindestens 35 Zeilenumbrüche (p-Tags) eingefügt und erst danach Text, so kommt es beim nächsten Brokerrequest zu einer StackOverflowException. Die Anwendung ist dann unter Umständen nicht mehr bedienbar. 2020031863 - IDE : Beim Kopieren eines Browser-Controls kann es zu einer NullReferenceException kommen. 2020032095 - IDE : In einem abgeleiteten Workflow wird an Events einer Form-Instanz die Base-Eigenschaft angezeigt. Sie ist sogar änderbar. 2020042138 - IDE : Beim Kopieren und Einfügen eines ListView oder Template Controls in einem Package mit Package Prefix, wird den Template DataSources das Prefix im Namen mehrfach vorangestellt und weicht somit vom Namen im HTML Template ab. 2020032100 - Code-Generierung : Bei der Prüfung auf doppelte Controls werden bei Forms im neuen Layout weiterhin Controls aus dem Deprecated Layout berücksichtigt und führen unter Umständen zu einer nicht behebbaren Warning. 4.2.3 (27.03.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.3_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Labeln und Branchen im Package Manager Im Package Manager gibt es generell zwei Möglichkeiten, eine neue Package-Version zu eröffnen: Label ( ): Erzeugt eine neue Version auf gleicher Ebene und versiegelt dabei die Ursprungsversion. Ausgecheckte Elemente werden dabei in die neue Version übertragen. Branch ( ): Erzeugt eine neue Unterversion (eine Ebene tiefer) und verändert den Zustand der Ursprungsversion dabei nicht. Ausgecheckte Elemente verbleiben in der Ursprungsversion. Folgendes hat sich geändert: Beide Funktionen stehen nun immer zur Verfügung, wenn man Besitzer ( Owner ) des Packages ist. Auch beim Branchen wird nun geprüft, ob alle in der Ursprungsversion eingecheckten Elemente vom FrameworkCompiler kompiliert wurden. Ausgecheckte Elemente werden beim Branchen generell nicht in die neue Version übernommen. HTML Client Der ImageButton unterstützt nun das BadgeImage. Korrigierte Fehler 2020021640 - IDE : Öffnet man einen bestehenden Exception Editor / Message Box Wizard und öffnet die MLKey-Auswahl, dann ist der erste MLKey ist ausgewählt. Es sollte der aktuelle MLKey selektiert sein. 2020021722 - IDE : Der \"Multilanguage Text Migration\" Wizard weist in Custom Packages mit nur deutschen Texten bestehende passende MLKeys mit Fremdsprachentexten aus Basispackages nicht zu. 2020031861 - IDE : Wird im Message-Editor ein MLKey ausgewählt, der keinen englischen Text besitzt, dann wird im generierten Code kein Text angezeigt. Es sollte in diesem Fall ein Fallback auf den deutschen Text erfolgen. 2020031842 - HTML Client : ListView und Template Controls \"verschucken\" den Focus, wenn sie mittels Tastatur fokussiert werden. 2020031866 - HTML Client : In seltenen Fällen wird im OnLeave-Event in den FrameworkOnLeaveEventArgs der Activator nicht oder falsch befüllt. 2020031889 - HTML Client : Die Selektoren für ListViewItems sind nicht sichtbar, wenn die SelectorPosition am ListView auf \"MiddleLeft\" oder \"MiddleRight\" gesetzt ist. 4.2.2 (28.02.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.2_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Korrigierte Fehler 2020021533 - Broker : Wird ein im Treeview dargestelltes Element aus seiner Collection am Parent entfernt und anschließend eine Eigenschaft geändert, die zuvor zu einer geänderten Darstellung im Treeview geführt hätte (z.B. sDisplayName), so kann es zu einer Fehlermeldung kommen. System.ArgumentOutOfRangeException: index must reference an CollectionEntry. 2020011293 - IDE : Wird im Customizing-Package in einem Workflow ein Fired-Event verknüpft, welches aus dem Basis-Package kommt, dann wird bei der Verwendung dieses Events in einem anderen Workflow das dahinter liegenede Form nicht erkannt. Das verursacht Warnings beim Compile und bei Methoden-Aufrufe im Workflow-Link können keine Werte aus dem Quell-Form als Parameter übergeben werden. 2020021461 - IDE : Ein Verweis auf eine ältere Newtonsoft.Json.dll führt zu einer Exception beim Testen der Runtime Supervisor Url. 2020021519 - IDE : Öffnet man aus einem Customizing-Package heraus die Component aus dem Basis-Package, dann kann es vorkommen, dass in der Combobox DB-Connection ein falscher Wert angezeigt wird. Diese falsche Anzeige hat aber keine Auswirkung auf die tatsächlich verwendete Connection. 2020021539 - IDE : Beim Customizen von Methoden über das Contextmenü im Codeeditor wird eine falsche Deklaration angelegt. 2020021606 - HTML-Client : Ein SetFocus() and einem Control im Form.load() Event wird am Client nicht korrekt verarbeitet. Der Fokus wird nicht in das Control gesetzt. 2020021513 - Package-Merge : Unter Oracle kann es beim Package-Merge zu folgender Exception kommen: FrameworkSystems.FrameworkExceptions.FrameworkDbException (0x80004005): ORA-01461: Ein LONG-Wert kann nur zur Einfügung in eine LONG-Spalte gebunden werden ---> Oracle.ManagedDataAccess.Client.OracleException (0x80004005) 4.2.1 (31.01.2020) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.1_Setup_x64 Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Connection-Pooling überarbeitet Aufgrund verschiedener Probleme wurde das Connection-Pooling der FrameworkDataConnection komplett überarbeitet. Dabei gab es auch Verhaltens-Änderungen. Bisher hat der Pool immer alle existierenden Connections gezählt - sowohl den Vorrat an verfügbaren als auch die momentan verwendeten Connections. Jetzt steuern die FSPooling -Parameter nur noch den Vorrat. Das hat (im Vergleich zu früher) den Vorteil, dass das Pooling auch dann noch wirksam ist, wenn dauerhaft eine größere Anzahl an Connections in Verwendung ist. Der Connection-Pool stellt im Broker eine Menge von wiederverwendbaren Datenbank-Verbindungen zur Verfügung. Dabei kann über die FSPooling -Parameter das Verhalten des Pools gesteuert werden. Die Parameter haben die folgende Bedeutung: FSPoolingMin : Wird eine Connection nicht mehr benötigt, wird sie (z.B. am Ende eines Broker-Requests) wieder zurück in den Vorrat / Pool gepackt. Der Pool darf dauerhaft diese Anzahl an Connections beinhalten. FSPoolingMax : Das ist die maximale Anzahl der Connections, die sich im Pool befinden dürfen. Ist der Pool voll, dann wird die Connection nicht in den Pool zurückgepackt sondern sie wird direkt geschlossen. FSPoolingTimeout : (in Sekunden) Die Connections zwischen Min und Max verbleiben maximal diese Zeit im Pool. Werden sie nicht vorher wieder verwendet, werden sie nach dem Timeout aus dem Pool entfernt und geschlossen. Neuerungen Such-Funktionalität für die ML-Columns Korrigierte Fehler 2020011151 - Oracle : Wird in einer DB-Column eine Spalte mit dem Typ Boolean angelegt, dann bringt der Datenbank-Update-Assistent einen Fehler, wenn die entsprechende Spalte auf der Datenbank bereits korrekt angelegt ist. 2020011286 - Package-Manager : An der Package-Version werden im Register Language nicht alle Sprachen aus den Basis-Packages angezeigt, wenn man an der Using-Hierarchie Änderungen vornimmt. 2020011298 - Package-Manager : Bei Package-Hierarchien mit Context-Versionen werden die Sprachen aus dem Basis-Package nicht korrekt übernommen. 2020011377 - Package-Manager : Beim Import einer Package-Version kann es zu folgendem Fehler kommen: \"There is an open DataReader associated with this Connection which must be closed first.\" 2019120999 - IDE : Wird an einer Tabellen-Spalte, die in einer customizten DBTable hinzugefügt wurde, aus Versehen die CheckBox \"Not Null\" gesetzt, dann lässt sich diese nicht mehr entfernen. 2019121032 - IDE : Wenn Framework Studio abstürzt, dann läuft der Development-Broker im Hintergrund weiter. Dieser blockiert Dateien im Compile-Verzeichnis und muss manuell beendet werden. 2020011086 - IDE : Wird bei einer Sql-Server Repository-Connection ein Server-Name mit einem Port angegeben (z.B. 127.0.0.1,1433), dann wird beim Beenden der IDE eine Exception angezeigt. 2020011136 - IDE : Wird in der ListView-Ansicht des Workflows nach einem Namen gefiltert und anschließend in der angezeigten Liste mit Doppelklick ein Workflow selektiert, dann wird eine InvalidCastException angezeigt. 2020011258 - IDE : FS stürzt mit einer GDI+ Exception ab, wenn animierte Gifs für die Dokumentation ausgewählt werden. 2020011334 - IDE : Nach dem Import eines Service-Releases wird ein darin neu angelegter MLKey im Multilanguage Text Editor zwar angezeigt, jedoch kommt es beim Kompilieren zu einer Exception, weil der MLKey nicht generiert wird. 2019121005 - Framework : Am Typ FSSystemGuid fehlt die statische Methode FromString(string). 2020011254 - FS-Broker : Wird bei einem Metadatentypen ein Format-Pattern mit einem \"&\" Zeichen angegeben, dann verursacht das XML-Exceptions wenn man ein Form öffnet, das ein Control mit diesem Metadatentypen enthält. 4.2 (20.12.2019) Die Auslieferung umfasst die folgenden Pakete: FS_4.2.0_Setup_x64 FS_4.2.0_Requirements_x64 ( Requirements-Paket ) FS_4.2.0_RuntimeAdministration Die Liste mit allen aktuellen Installations-Paketen finden Sie hier . Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.2 Beta-Version Hinweise Die Installation-Routine der Release-Version führt für eine bereits installierte Beta-Version ein Update auf die Release-Version aus. Important Bitte beachten Sie alle Anweisungen und Hinweise in diesem Abschnitt, wenn sie bereits eine Beta-Version von Framework Studio 4.2 verwendet haben. Die Package-Exporte und Service-Release-Exporte der aktuellen Framework Studio 4.2 Version sind inkompatibel mit den vorangegangenen Framework Studio 4.2 Beta Versionen. Dies gilt in beide Richtungen. Führen Sie in jedem Fall einen Update auf die Release-Version durch, bevor sie neue Packages im Repository importieren. Verwenden sie keine Beta-Packages mehr. Im Laufe der Beta-Versionen gab es Änderungen am Repository . Bitte führen Sie auf allen mit der Beta-Version neu erstellten und upgedateten Repositories den Update erneut aus: Im Programm-Verzeichnis die FrameworkStudioUpgradeDatabase.exe starten und am Repository anmelden. Falls noch offene Scripte angeboten werden, diese bitte ausführen. Zeilenversionierung im SQL-Server Beim Anlegen neuer Runtime Repositories im SQL-Server hat Framework Studio versäumt, die Zeilenversionierung zu aktivieren. Dadurch kann es insbesondere bei längeren Transaktionen zu unnötigen Blockierungen von Select-Statements kommen. Dieser Fehler ist nun durch die Korrektur von Bug 2019110775 behoben. Warning Bestehende SQL-Server Runtime Repositories müssen manuell korrigiert werden! Details dazu finden Sie hier: Zeilenversionierung im SQL-Server . Korrigierte Fehler In der Version 4.2 sind alle Fehler-Korrekturen bis einschließlich Framework Studio 4.0.18 enthalten. Zusätzlich wurden die folgenden Bugs behoben. 2019027233 - Code-Generierung : Im generierten Code von ReportDocumentTypes wird der Package-Name verwendet statt dem Assembly-Prefix. 2019089003 - Doku-System : Ausgeblendete Controls (hidden/Collapsed) werden im Doku-Screenshot nicht gerendert. 2019100072 - Framework : Die MLColumn-Einträge werden nicht mit dem Record gelöscht, wenn nicht zuvor auf die fremdsprachigen Texte zugegriffen wurde. 2019099502 - Repository : Alle Sublabeled Tabellen sollen aus Performance-Gründen mit einem Index auf die PackageID-Spalte versehen werden."
  },
  "articles/neuheiten-4-2.html": {
    "href": "articles/neuheiten-4-2.html",
    "title": "Neuheiten Framework Studio 4.2",
    "keywords": "Neuheiten Framework Studio 4.2 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen . Neue Systemvoraussetzungen In dieser Version gibt es einige Anpassungen bei den Systemvoraussetzungen . Im folgenden sind die wichtigsten Änderungen aufgeführt. Datenbank-Server Es wird der Oracle Server 12.2 oder höher (18c, 19c, ...) unterstützt. Ältere Versionen werden nicht mehr unterstützt. Es wird der SQL-Server 2012 oder höher unterstützt. Ältere Version (z.B. SQL-Server 2008) werden nicht mehr unterstützt. Important Ein Betrieb mit einer älteren Datenbank-Version ist nicht möglich. Ein Connect auf so einen Datenbank-Server führt unmittelbar zu einer entsprechenden Fehlermeldung. Oracle Client Es wird nur noch der Oracle Managed Provider unterstützt. Der Oracle ODP Provider wird nicht mehr unterstützt. Framework Studio benötigt damit keinen separaten Oracle-Client mehr. 64 Bit Die folgenden Programme können nur noch auf 64-Bit Systemen installiert werden. Eine 32-Bit Installations-Routine wird nicht mehr angeboten: Framework Studio IDE / Package Manager Publish / Publish2Go Anwendungs-Broker Framework Studio Services 32-Bit wird weiterhin unterstützt für: Client-Rechner Print-Server .NET Framework 4.8 Framework Studio setzt auf das .NET Framework 4.8 auf. Der Installer ist im Requirements-Paket enthalten und muss ggf. vor der Installation von Framework Studio ausgeführt werden. Alternativ kann der Installer auch direkt bei Microsoft heruntergeladen werden: https://dotnet.microsoft.com/download/dotnet-framework/net48 Betriebssysteme Mit dem Umstieg auf das .NET Framework 4.8 können einige ältere Windows Betriebssysteme nicht mehr unterstütz werden. Es werden aktuell folgende Betriebssysteme unterstützt: Server Windows Server 2012 R2 - oder höher Client / Entwicklungs-Rechner Windows 10 (Version 18.03 - oder höher) Windows 8.1 Für die Endanwender-Rechner bzw. Terminal-Server gelten weiter die bisherigen Anforderungen. C# 7 Mit dem Update auf das .net Framework 4.8 unterstützt Framework Studio auch die C# Sprach-Features bis zur Version 7.3. Eine Übersicht der Features bietet die Web-Seite: https://docs.microsoft.com/dotnet/csharp/whats-new/csharp-7 In der folgenden Liste werden einige Features genannt, die seit C# 6 hinzugekommen sind. Der Einsatz dieses Features ist in Framework-Studio empfehlenswert: out variables - inline-Deklaration (C# 7.0) Folgende Features können ggf. sinnvoll sein: Tuples (C# 7.0) - nur innerhalb von Methoden-Code (z.B. bei Linq-Queries), nicht als Parameter oder Rückgabe-Typ von Methoden Inferred tuple element names (C# 7.1) Tuples support == and != (C# 7.3) Pattern matching (C# 7.0) Local functions (C# 7.0) - aber nur sehr gut überlegt!! MLKey Wörterbuch Eine zentrale Neuerung in der Version 4.2 betrifft das Handling der fremdsprachigen Texte. Diese werden jetzt in einem zentralen Wörterbuch verwaltet. Bisher wurden alle Texte am jeweiligen Element (z.B. Metadatentyp, ComponentProperty, FormControl) gepflegt. Jetzt werden an allen diesen Stellen Schlüssel (MLKeys) angegeben, die auf das zentrale Wörterbuch verweisen. Dadurch hat man erst einmal etwas mehr organisatorischen Aufwand, aber auf längerer Sicht betrachtet bringt diese Vorgensweise viele Vorteile: Redundanzen werden vermieden, weil existierende Texte wiederverwendet werden können und sollen. Dadurch erhält man zudem in der kompletten Anwendung durchgängige und einheitliche Bezeichnungen. Die fremdsprachigen Übersetzungen können sehr einfach und zentral gepflegt werden. Besonders im Customizing-Package ist das von großem Vorteil, weil jetzt nicht mehr die einzelnen Elemente ausgecheckt werden müssen. Das Wörterbuch kann auch im Service-Release bearbeitet werden. Der Export und Import von Texten ist sehr einfach. Es wird das standardisierte TMX-Format verwendet. Texte können so zwischen verschiedenen Packages und Versionen ausgetauscht werden. Auch eine Übersetzung durch Werkzeuge oder externe Dienstleister ist dadurch deutlich einfacher als bisher. Eine detailliert Beschreibung der Funktionalität finden sie im Kapitel MLKey . Es ist sinnvoll, die Texte des eigenen Packages in das Wörterbuch zu überführen. Bitte beachten sie dazu die Hinweise und Anleitungen für die Migration . Fremdsprachen im Customizing-Package Sprachen werden jetzt an der Package-Version organisiert und können somit in Customizing-Packages ergänzt werden. Code-Messages überarbeitet Die vom Exception- und MessageBox-Wizard generierten Code-Messages wurden überarbeitet. Das bisherige Konstrukt mit #region wurde durch eine Variante mit einem einfachen eingefärbten Kommentar // FSCodeMessage: ersetzt. Das macht den Quellcode kompakter und leserlicher – ohne extra aufklappen zu müssen. Der XML-Teil, welcher bisher die Informationen für die Wizard-Dialoge beinhaltet hat, entfällt. In der Vergangenheit konnte es sein, dass die XML-Informationen vom Code abwichen. Der Wizard hat dann den Code ignoriert und einfach ersetzt. Dadurch konnten wichtige Infos – wie z.B. ein MessageBox EventHandler – verloren gehen. Die Informationen werden jetzt aus dem Code geparsed. Kann (z.B. aufgrund von manuellen Anpassungen) der Code nicht geparsed werden, kann er nicht mehr durch den Wizard bearbeitet werden. Die Code-Messages können einen MLKey aus dem Wörterbuch verwenden. Die bisherige Variante mit TextCollection-Einträgen soll nach und nach durch die MLKeys ersetzt werden und so die ctMessage-TextCollections auslaufen. Bei MsgBox.Show() sind die Enum-Werte für Button und Icon leserlich ausgeschrieben. Bisher wurden dort nur die int-Werte verwendet. Die Konvertierung des bestehenden Codes in das neue Format erfolgt auf folgende Weise: Durch die MLKey-Konvertierungs-Routine – diese setzt alle Code-Messages automatisch auf einen MLKey und/oder das neue Format um. Durch manuellen Aufruf des Exception- oder MsgBox-Wizards. Beim Speichern wird der Code durch die neue Variante ersetzt. Bei beiden Konvertierungen wird nur der Code betrachtet - der alte XML-Teil wird ignoriert. Neue Messages werden immer im neuen Format generiert. Dabei ist es egal, ob ein Textcollection-Eintrag oder ein MLKey verwendet wird. Neue Text-Funktionen In Framework Studio 4.2 wurden im Zuge der Umstellung auf die MLKeys auch die Text-Zugriffe auf Text-Collections und DevMLStrings überarbeitet. Note Es muss eine Migration durchgeführt werden. Actions SetEnabled und SetVisible nullable Die Control-Actions SetEnabled und SetVisible haben neue Überladungen bekommen, welche das Zurücksetzen auf den im Property-Grid des Form-Designers eingestellten Wert ermöglichen. Dazu wurden folgende Überladungen ergänzt, bei denen der null -Wert zum Zurücksetzten verwendet werden kann: SetEnabled(bool? value) SetEnabled(FSbool value) SetVisible(FSVisibility? value) Caution Achtung, falls Reflection verwendet wurde! Sollte eine der ursprünglichen Methoden aus irgend einem Grund per Reflection angesprochen worden sein, so kann es nun zu dem Problem kommen, dass nicht mehr eine eindeutige, sondern mehrere Überladungen der Methode gefunden werden. Die Überladungen SetEnabled(bool value) und SetVisible(FSVisibility value) wurden entfernt, da Aufrufe vom Compiler direkt auf die entsprechenden Nullable-Überladungen umgelenkt werden. Forms und Workflows Obsolete setzen Soll ein Form oder ein Workflow nicht mehr verwendet werden, so können die für diese Elemente generierten Klassen mit dem Obsolete Attribut versehen werden. Dazu muss der Name des Elements mit _Obsolete enden. Beispiel: wlfArticleDetail_Obsolete Der Compiler erzeugt dann bei Verwendung der Elemente Warnings in der Form 'wflArticleDetail_Obsolete' is obsolete: 'Workflow 'wflArticleDetail_Obsolete' will be deleted in future version.' . Weitere Neuerungen Die MLColumn-Sprache kann zur Laufzeit beeinflusst werden. An den DBColumns können die Größen-Angaben überschrieben werden, auch wenn ein Metadatentyp zugeordnet ist. Compare with previous in Method- und Element-History Browsern Such-Funktionalität für die ML-Columns"
  },
  "doc/ide/code-builder.html": {
    "href": "doc/ide/code-builder.html",
    "title": "Code Builder",
    "keywords": "Code Builder Compile Options: Das Menü, mit dem Sie zum einen die Optionen zur Codegenerierung und zum Kompilieren festlegen, und zum anderen einen Kompiliervorgang starten können, wird über den Button Compile Options geöffnet. In diesem Fenster sehen Sie in der Zeile, beginnend mit Active Application , welche Applikation ausgewählt ist. Für diese Applikation werden dann durch das Starten des Kompiliervorgangs die Dynamic Link Librarys (DLLs) erzeugt. Mit den unten aufgeführten Checkboxen ( ) legen Sie fest, für welche Elementtypen der generierte Code neu kompiliert werden soll. Es ist nicht immer notwendig und wird aus Zeitgründen auch nicht empfohlen, alle Elemente in einem Namespace zu kompilieren. Stattdessen sollten Sie nur die Elemente kompilieren, an denen Sie auch tatsächlich Änderungen vorgenommen haben. Checkbox Resources Wählen Sie Resources , um alle Ressourcen neu ins Brokerverzeichnis zu kopieren. Checkbox Access Units Wählen Sie Access Units , wenn Sie neue Access Units (z.B. durch Hinzufügen eines neuen Forms) hinzugefügt haben und diese im Code ansprechen wollen. Warning Wenn Sie für die Anwendung keine Developer-Lizenz verwenden und neue Access Units hinzugekommen sind oder die Hierarchie geändert wurde, müssen Access Units mit dem Benutzer FrameworkCompiler recursive from root kompiliert werden. Checkbox Metadatatypes Wählen Sie Metadatatypes , um die Metadatentypen in einem Namespace zu kompilieren. Checkbox DBTables Wählen Sie DBTables , wenn Sie Änderungen an den DB-Tables vorgenommen haben. Checkbox Interfaces Wählen Sie Interfaces , wenn Sie Änderungen an Komponenten vorgenommen haben, welche die Methodendefinitionen, Methodenparameter oder Properties betreffen. Warning Der Sinn von Interfaces liegt darin, zirkulare Referenzen zu vermeiden. Die Interfaces werden daher grundsätzlich über alle Namespaces hinweg kompiliert. Checkbox Components Wählen Sie Components , wenn Sie Änderungen an den Komponenten vorgenommen haben, welche Methodendefinitionen, Methodenparameter, Properties oder Codes innerhalb von Methoden betreffen. Checkbox Global Objects Wählen Sie Global Objects , wenn Sie Änderungen an diesen vorgenommen haben und wenn Sie neue Komponenten angelegt haben. Checkbox Report Document Types Wählen Sie Report Document Types , wenn Sie Änderungen an diesen vorgenommen haben. Checkbox Custom Controls Wählen Sie Custom Controls , wenn Sie Änderungen an diesen vorgenommen haben. Checkbox Forms Wählen Sie Forms , wenn Sie Änderungen an den Forms vorgenommen haben. Checkbox Workflows Wählen Sie Workflows , wenn Sie diese geändert haben. Mit dem Button wählen Sie alle genannten Elemente aus, mit keines. Mit den darunter angeordneten Checkboxen legen Sie weitere Optionen zur Codeerzeugung und zum Kompilieren fest. Checkbox Use Saved Code Um die Codegenerierung zu beschleunigen, besteht die Möglichkeit, Framework Studio anzuweisen, auf bereits generierten und im Repository hinterlegten Code (sogenannten Saved Code) zurückzugreifen. Das hat den Vorteil, dass nicht der gesamte Code vor dem Kompilieren neu generiert werden muss, sondern lediglich die Teile, welche sich geändert haben. Falls es dabei allerdings zu Problemen kommt, können Sie Framework Studio anweisen, den Code komplett neu zu generieren. Checkbox Rebuild On Error Diese Option ist irrelevant, wenn Use Saved Code nicht aktiviert wurde. Andernfalls bewirkt das Aktivieren von Rebuild On Error , dass bei einem Kompilierfehler in einem eingecheckten Element ein zweiter Kompilierversuch ohne Saved Code gestartet wird. Der Kompilierversuch ohne Saved Code ist dann nötig, wenn Sie beispielsweise eine Komponente umbenannt haben, die von einer anderen, eingecheckten Komponente benutzt wird. Sie sollten die Option nur bei Problemen dieser Art aktivieren, da sich die Kompilierzeit mit Rebuild On Error beim Auftreten eines Fehlers deutlich erhöht. Checkbox Debugable Um den erzeugten Code zur Laufzeit mit Microsoft Visual Studio bereinigen zu können, aktivieren Sie die Option Debugable . Das führt dazu, dass im Applikations-Verzeichnis, zusätzlich zu den Dynamic Link Librarys (DLL) auch noch Programmdatenbankendateien und Quellcodedateien (.cs) von den einzelnen Namespaces erzeugt werden. Diese können mit Visual Studio geöffnet werden. Checkbox XMLDoc Aktivieren Sie diese Option, damit eine XML-Beschreibungsdatei erzeugt wird. Für weitergehende Informationen lesen Sie das Kapitel Verwendung von NDoc . Um einen Kompiliervorgang zu starten, stehen Ihnen mehrere Möglichkeiten zur Auswahl: Option Compile Namespace Der Code für den im Objekt-Baum dargestellten Namespace wird generiert. Danach werden die Dlls erzeugt und in das Compile-Verzeichnis ( Compile-Verzeichnis ) geschrieben. Die darunter liegenden Namespaces werden nicht berücksichtigt. Option Compile Namespace Recursively Auch die untergeordneten Namespaces werden in den Kompiliervorgang mit eingebunden. Option Compile From Root Unter diesem Menüpunkt werden die folgenden Kompilierarten angeboten, die sich grundsätzlich auf alle Namespaces beziehen: Option Recursively Alle Elemente werden kompiliert. Option Recursively With Restarts Alle Elemente werden kompiliert. Dabei wird Framework Studio nach der erfolgreichen Abarbeitung eines jeden Elementtyps neu gestartet. Dadurch wird der gesamte verwendete Speicher freigegeben. Diese Funktion ist dann sinnvoll, wenn ohne den Neustart nicht ausreichend Arbeitsspeicher für den Kompiliervorgang zur Verfügung stehen würde. Über die Tastenkombination [Strg]+[Shift]+[B] können Sie aus Framework Studio direkt einen Kompiliervorgang für den Elementtyp des aktuell geöffneten Elements anstoßen, ohne vorher das Menü Compile Options öffnen zu müssen."
  },
  "doc/ide/bearbeiten-von-elementen.html": {
    "href": "doc/ide/bearbeiten-von-elementen.html",
    "title": "Bearbeiten von Elementen",
    "keywords": "Bearbeiten von Elementen Die Elemente, die in Framework Studio bearbeitet werden können, werden alle auf der Registerkarte Namespaces verwaltet. Es folgt eine Übersicht der Elemente im Framework Studio: Namespace Namespaces bilden eine Ordnerstruktur, in der alle anderen Elemente geordnet abgelegt werden. Ein Namespace kann auch wiederum andere Namespaces beinhalten. Resource Eine Ressource stellt eine beliebige Datei dar, die beim Kompilieren in das Brokerverzeichnis kopiert wird. Dadurch kann die Anwendung diese Datei (z.B. ein Bild oder eine externe DLL) verwenden. ( Resources ) Access Unit Über Access Units wird die Anwendung in einzelne Bereiche eingeteilt. Diese Bereiche können dann durch Laufzeitlizenzen und abhängig von den Rollen eines Benutzers gesperrt werden. (Access Units( !TODO LINK ), Laufzeitlizenzen( !TODO LINK )) Metadatentype Ein Metadatentyp ist ein erweiterter Datentyp, der mehr Informationen enthält als ein normaler Datentyp unter .NET. Weitere Informationen sind z.B. Labels, Format und Controls. ( Metadatentypen ) Datasource Ein Datasource definiert eine Datenbankverbindung, die von der Anwendung zum Lesen und Schreiben der Anwendungsdaten benutzt werden kann. ( Datasource ) DBTable Ein DBTable ermöglicht Komponenten den Zugriff auf eine Datenbanktabelle, die über einen Datasource angesprochen werden kann. ( DBTable ) Component / Collection / Textcollection Eine Component ist eine funktionale Klasse, die bereits Grundfunktionalitäten wie das Lesen und Schreiben von Daten in eine Datenbank beherrscht. Eine Textcollection ist eine Sammlung von mehrsprachigen Texten. (Component / Collections( !TODO LINK ), Textcollections( !TODO LINK )) Report Document Type Hier werden ausdruckbare Reports und deren Schnittstelle definiert. (Report Document Type( !TODO LINK )) Custom Control Durch Custom Controls ermöglicht Framework Studio das Hinzufügen von eigenen, spezialisierten Controls, die nicht zu den Standard-Controls gehören. (Custom Controls( !TODO LINK )) Form Forms dienen der Visualisierung der Daten am Bildschirm. Sie enthalten Controls, welche die Daten anzeigen und bearbeiten können. (Form( !TODO LINK )) Global Event Global Events dienen dazu, anwendungsweit Nachrichten zu senden. (Global Events( !TODO LINK )) Workflow In Workflows wird die Kommunikation zwischen den Forms und dem Arbeitsablauf des Anwenders definiert. Workflows können Forms, Global Events, Links, Branches, Switches und andere Workflows enthalten. (Workflow Designer( !TODO LINK )) Data Contract Data Contracts definieren komplexe Datenstrukturen für Service-Schnittstellen. (Fehler! Verweisquelle konnte nicht gefunden werden.(( !TODO LINK ))) Service Contract Service Contracts legen fest, welche Operationen ein Service beinhaltet. (Fehler! Verweisquelle konnte nicht gefunden werden.( !TODO LINK )) Service Implementiert die im Service Contract definierten Operationen. (Service( !TODO LINK )) Service Host Legt Endpunkte und Übertragungsparameter für den Service fest. (Fehler! Verweisquelle konnte nicht gefunden werden.( !TODO LINK )) Service Proxy Kapselt einen Service Host nach außen. (Fehler! Verweisquelle konnte nicht gefunden werden.( !TODO LINK )) Transformation Transformationen werden genutzt, um einen Eingangsdatentyp in einen Ausgangsdatentyp umzuwandeln. Häufig wird dies in Bezug auf Data Contracts verwendet. (Transformationen( !TODO LINK )) Elemente erstellen Ein neues Element lässt sich erstellen, indem Sie auf der Registerkarte Namespaces den Namespace auswählen, in dem das Element abgelegt werden soll. Mit dem Button (New) der Registerkarte Namespaces oder dem entsprechenden Eintrag aus dem Menü wird im markierten Namespace ein neues Element angelegt. Es wird auch gleich im Hauptfenster geöffnet. Direkt nach dem Anlegen des Elements steht der Cursor in dem sich öffnenden Designer-Fenster auf dem Feld Name . Geben Sie hier den Namen des neuen Elements ein. Der Name lässt sich auch nachträglich noch ändern. Dazu öffnen Sie das Element und ändern die Bezeichnung im Feld Name oder wählen Sie aus dem Kontext-Menü des Elements auf der Registerkarte Namespaces den Eintrag aus. Warning Wird das Element bereits verwendet, kann es zu Problemen kommen, da nicht an allen Stellen der Name automatisch nachgezogen werden kann. Es empfiehlt sich, die Namen folgendermaßen zu vergeben: Namespace: XxxXxx Metadatentyp: mdt XxxXxx oder XxxXxx Component, die eine Datenbank-Tabelle anbietet: cd XxxXxx Andere Components: c XxxXxx Collections: cd XxxXxx Coll bzw. c XxxXxx Coll Textcollections: ct XxxXxx ReportDocumentTypes: rpt XxxXxx Form: frm XxxXxx Global Event: gev XxxXxx Workflow: wfl XxxXxx Elemente bearbeiten Um ein Element zu bearbeiten, öffnen Sie es mit einem Doppelklick auf der Registerkarte Namespaces . Im Hauptteil von Framework Studio öffnet sich dann ein Desginer-Fenster für das ausgewählte Element. Dort können die gewünschten Änderungen vorgenommen werden. Mit dem Button Save werden die Änderungen gespeichert. Warning Namespaces können nicht geöffnet werden. Mit einem Doppelklick wird der Namespace auf- oder zugeklappt. Elemente löschen Löschen können Sie ein Element mit dem Menüeintrag File / Delete … . Dazu wird das gewünschte Element im Objekt-Baum markiert. Diese Funktion können Sie auch über das Kontext-Menü eines Elements im Objekt-Baum nutzen. Der Löschvorgang wird erst wirksam, wenn Sie den Button (Save All) drücken. Warning Durch das Speichern eines gelöschten Elements wird im Hintergrund automatisch ein CheckIn durchgeführt. Es werden auch alle Änderungen an anderen, geöffneten Elementen gespeichert. Elemente kopieren / einfügen Es ist möglich, verschiedene Elemente zu kopieren oder auch zusammenzuführen (mergen). Das funktioniert auch, wenn es sich bei Quelle und Ziel um unterschiedliche Repositories handelt. Folgende Elemente können kopiert und gegebenfalls zusammengeführt werden: MDT ServiceHost 1 Workflow Resource DBTable Service Proxy 2 DataContract Namespace 1 Collection Report ServiceContract Component TextCollection GlobalEvent 1 Service 2 Form Warning 1 Element kann nicht gemerged werden. 2 Ableitung des Elements kann weder kopiert noch gemerged werden. Allgemein Copy Über das Kontextmenü eines Elements, über den Menüpunkt Copy im Edit -Menü oder über die Copy & Paste Buttons kann ein Element kopiert werden. Copy & Paste Buttons: Paste Wird ein Element ohne Basis und ohne ID kopiert, kann es überall eingefügt werden. Wird ein Element mit ID kopiert, kann dies nur eingefügt werden, wenn ein Element mit derselben ID noch nicht existiert. Eine Customization kann nur erstellt werden, wenn im Package noch keine Customization vorhanden ist und die passende Basis existiert. Grundsätzlich wird zwischen zwei verschiedenen Arten unterschieden, um ein Element einzufügen: Element am Namespace eingefügt Über das KontextMenü am Namespace kann das kopierte Element in den Namespace eingefügt werden. Dabei wird ein neues Element erstellt. Falls ein Element mit derselben ID bereits existiert wird über ein Dialog vorgeschlagen das kopierte Element in das bestehende Element einzufügen. Element in ein bestehendes Element des gleichen Typs einfügen Über das Kontextmenü eines Elements oder über den Menüpunkt Paste im Edit-Menü kann das kopierte Element in ein bestehendes Element desselben Typs eingefügt werden. Dieser Vorgang stand in älteren Versionen schon unter Merge bei Components zur Verfügung. Dialog zum zusammenfügen von Elementen mit gleicher ID: Kompatibilität Elemente bei denen Copy & Paste bereits vorhanden war (Components, Forms) können zwischen der alten und neuen Version kopiert werden. Das Kopieren mit ID wird jedoch erst ab FS3.11 unterstützt. Paste Dialog Allgemein Über den Paste Dialog kann beim Kopieren in ein bestehendes Element ausgewählt werden, welche Unterelemente wie kopiert werden. Zu beachten ist, dass der Paste Dialog sehr viele Freiheiten bietet. Dies ermöglicht natürlich auch fehlerhafte Stände zu erstellen. Dieser Mechanismus ist für versierte Benutzer konzipiert. Grundsätzlich sollte der Benutzer wissen, was er tut und VOR der Aktion sicherstellen, dass alle benötigten Elemente am Ziel vorhanden sind. Die zu kopierenden Unterelemente sind in Gruppen auf verschiedene Registerkarten aufgeteilt. Jeder Paste Dialog enthält eine Summary und die NeededTypes . Im obersten Bereich des Paste-Dialogs werden der Type und der Pfad des kopierten Elements angezeigt. Der Pfad des kopierten Elements ist nur für Elemente sichtbar, die aus einer Version ≥ FS 3.11 kopiert wurden. Paste Dialog: Angaben zum kopierten Element: Summary Die erste Registerkarte beinhaltet immer die Summary. Diese zeigt, ob beim Paste oder Merge Konflikte auftreten. Framework Studio versucht grundsätzlich bei der Aktion die benötigten Elemente im Ziel-Package auf folgenden Wegen zu finden: Über die interne ID: Das funktioniert meist dann, wenn Quell- und Ziel-Package identisch sind oder wenn Elemente aus einem gemeinsamen Basis-Package verwendet werden. Über den Namen: Wenn über die ID nichts gefunden wird, wird nach einem gleichnamigen Element (z.B. Metadatentyp, Component, Property) gesucht. Das ist vor allem dann sehr nützlich, wenn nach und nach mehrere Elemente in ein anderes Package kopiert werden. Wenn diese Wege nicht zum Ziel führen, wird dies als Konflikt betrachtet und der Benutzer muss nach einer Lösung suchen. Teilweise kann das auf den restlichen Registerkarten erfolgen. Manchmal ist es aber auch nötig, die Aktion abzubrechen, erst die Voraussetzungen zu schaffen (z.B. eine DBTable anlegen) und die Aktion anschließend noch einmal auszuführen. Für einige Elemente gelten Sonderregeln für das Kopieren und Zusammenfinden von Elementen. Diese sind dem Kapitel ( Kopieren vo¬n ID´s ) zu entnehmen. Über verschiedene Buttons kann ausgewählt werden, welche Unterelemente der Registerkarte selektiert und beim Einfügen berücksichtigt werden. Select all: Alle Unterelemente werden selektiert. Select none: Alle Unterelemente werden deselektiert. Select new: Es werden nur neu hinzugefügte Unterelemente selektiert Paste Dialog: Summary: Beim Einfügen eines Elements am Namespace kann außerdem ausgewählt werden, ob die ID des Elements kopiert werden soll. NeededTypes Bei den Needed Types werden alle Typen aufgelistet, die nicht zum Standard gehören. Diese können beliebig ausgetauscht werden. Das kann z.B. dann sinnvoll sein, wenn ein benötigtes Element vorher auch schon kopiert wurde und jetzt ggf. unter einem anderen Namen in einem anderen Namespace zu finden ist. Zusammenführen von Elementen Mit einem Merge kann erreicht werden, dass Änderungen in einer Kopie nachgezogen werden. Was nicht möglich ist, sind gelöschte Elemente durch den Merge zu entfernen. Es werden nur neu hinzugekommene oder geänderte beachtet. Beim Kopieren in ein bestehendes Element werden zusätzlich alle zu kopierenden Unterelemente gruppiert und in verschiedenen Registerkarten dargestellt. Die Unterelemente sind wiederum nach MergeAction und Name sortiert. Für jedes Unterelement kann separat entschieden werden, ob und wie es im Ziel eingefügt wird. Unterelemente: Unterelemente können einzelne Werte oder komplexere Elemente wie Methoden oder Properties darstellen. Alle Elemente werden gruppiert und in verschiedenen Registerkarten dargestellt. Die einzelnen Elemente können aus einer Liste ausgewählt werden. Für jedes Element kann separat entschieden werden, ob und wie es gemerged wird. Elemente, die im Ziel noch nicht vorhanden sind (Insert) werden in der Liste Grün dargestellt. Merge Action: Es stehen verschiedene Merge-Operationen zur Verfügung: Insert Das Element wird im Ziel neu eingefügt Der Eintrag wird in der Liste Grün dargestellt Replace Unter Target kann das Element, das im Ziel ersetzt werden soll, ausgewählt werden Replace with Das ausgewählte Source -Element ersetzt das „Target“-Element Target: Dieses Element wird beim Mergen ersetzt Source: Das Source -Element ersetzt das „Target“-Element beim Merge Merge Info: Bietet Informationen über das Merge Element z.B. die Art der Übereinstimmung im Ziel Kopieren von ID´s Um Parallelentwicklungen zu realisieren, ohne dass die internen IDs von Elementen in verschiedenen Versionen auseinanderlaufen, besteht nun die Möglichkeit die ID von Elementen zu kopieren. In der obersten Leiste des Paste Dialogs ist farblich gekennzeichnet, ob die IDs kopiert oder neu angelegt werden. Kopieren von IDs Aktiv: Kopieren von IDs Inaktiv: Für das Kopieren von IDs gelten folgende Regeln: Wenn das zu kopierende Element am Namespace eingefügt wird und aus demselben Package aber unterschiedlicher Version stammt, ist das Kopieren der ID´s optional. Beim Zusammenführen von Elementen im selben Package aber unterschiedlicher Version wird die ID automatisch kopiert, wenn die IDs der beiden Elemente übereinstimmen, ansonsten nicht. Wenn das zu kopierende Element aus einem anderen Package stammt, ist das Kopieren der ID´s nicht möglich. Kopieren von IDs: Kopieren von Unterelementen Es ist möglich Methoden, Controls, Form- und Component-Properties zu kopieren. Methoden können unabhängig von dem Parent-Element eingefügt werden. Die ID wird bei Unterelementen nur dann übernommen, wenn in demselben Package aber unterschiedlichen Versionen kopiert wird und die ID der Parent-Elemente übereinstimmt. Elemente aus einer älteren Version werden nicht mit ID kopiert. Beim Einfügen von Unterelementen in ein anderes Parent-Element wird der PasteDialog angezeigt. Beim Einfügen von Unterelementen aus einer älteren Version wird der Dialog nicht angezeigt. Sonderfälle Es gibt Ausnahmen oder Sonderfälle beim Kopieren oder Mergen, die nachfolgend aufgelistet sind: Metadatentype Merge von Indices Falls die ID oder der Name identisch sind, wird ein Replace angeboten. Fall ID und Name nicht übereinstimmen, aber dieselbe Konstellation von Spalten im Ziel enthalten ist und ASC/DSC identisch sind, wird ebenfalls ein Replace angeboten. In allen anderen Fällen wird ein Insert angeboten. TextCollection Merge von TextEntries Wenn der PK identisch ist, wird ein Replace vorgeschlagen. Wenn die ID´s oder die Namen identisch sind, aber der PK abweicht, wird ein Replace mit entsprechender Warning angezeigt. Beim Mergen werden ID und Namen als Felder zum Bearbeiten angeboten. Texte, die nicht bekannt sind (ISO nicht bekannt), werden nicht gemerged. Service Elemente Allgemein Ableitungen von Service Elementen können weder kopiert noch gemerged werden. Report Data Source Die angehakten Checkboxen von DataSources werden beim Kopieren von Ableitungen oder Customizations nicht mit kopiert. Die angehakten Checkboxen vom DataSources werden beim Merge nicht berücksichtigt. GlobalEvent Allgemein Das GlobalEvent kann nicht gemerged werden. Workflow Merge Allgemein Die Position oder Größe eines Elements wird beim Mergen nicht berücksichtigt. Wenn der Name oder die ID eines Elements identisch ist, wird, falls sich eine Eigenschaft geändert hat, ein Replace angeboten. Ein Merge-Konflikt wird angezeigt, wenn: Switch das Event (Name oder ID) nicht identisch sind Branch die Condition abweicht Link eine Eigenschaft des Links geändert wurde Form ISModal , ISEntranceInstance oder IsStartInstance geändert wurde Workflow IsEntranceInstance geändert wurde Resource Allgemein Ressources können nicht gemerged werden Namespaces Allgemein Namespaces können nicht gemerged werden Namespace Referencen werden nicht kopiert"
  },
  "doc/html-client/android-app.html": {
    "href": "doc/html-client/android-app.html",
    "title": "Android App",
    "keywords": "Android App Für die volle Integration des HTML-Clients in die mobile Welt, stellen wir im Google Play Store den Client als Android App zur Verfügung. Diese ist vom Funktionsumfang equivalent zur Browser-Version. Name der App : Framework Studio Mobile Client Store Link : https://play.google.com/store/apps/details?id=com.fs.htmlclient Note Wir können derzeit noch keine Aussagen zu einer Veröffentlichung der App für iOS treffen. Einrichten eines Brokers Es muss natürlich definiert werden, mit welchem Broker sich der Mobile Client verbinden soll. Nach dem Start der App wird der Login angezeigt. Über den Button „+ New“ können beliebig viele Broker zur Liste hinzugefügt werden. Es ist auch möglich, Urls von Development Brokern hinzuzufügen. Dabei ist zu beachten, dass der Mobile Client nur auf den Development Broker zugreifen kann, wenn dieser über das Netzwerk erreichbar ist. Dazu muss Framework Studio mit Administrator-Rechten ausgeführt werden. Ob der Development Broker vom Netzwerk aus zugreifbar ist, kann über das Tray-Icon geprüft werden:"
  },
  "doc/form/control/template.html": {
    "href": "doc/form/control/template.html",
    "title": "Template Control",
    "keywords": "Template Control Properties/Events Actions Note Dieses Control funktioniert nur im Mobile-Client . Im Java-Client wird das Control nicht angezeigt. Template Editor Der Template Editor bietet die Möglichkeit, das HTML/CSS Template für das Template Control sprachabhängig zu definieren. Dabei können Template DataSources definiert werden, auf welche aus dem HTML heraus mittels Template Variablen verwiesen wird. So können sehr einfach Businessdaten ins HTML eingebettet und formatiert werden. Der Editor kann im Property-Grid über das Property Template geöffnet werden. Allgemein Dropdown für Sprachauswahl Das HTML und CSS eines Template Controls kann, wenn gewünscht, für jede Sprache einzeln definiert werden. Ist für eine Sprache kein Template definiert, wird auf Deutsch zurückgegriffen. Button Validate Über diesen Button können die im HTML eingebetteten Template Variablen und Template MLKeys überprüft werden. Es werden folgende Fälle geprüft: Ist der Template MLKey parsebar und ist der MLKey-Name gültig? Ist die Template Variable parsebar? Passt das angegebene Format zum Datentyp? Zeigt die Template Variable auf eine existierende Template DataSource? Ist jeder Template DataSource eine valide DataSource zugeordnet Ist die DataSource einer Template DataSource weder private noch internal Template DataSources Auf der rechten Seite der Registerkarte HTML befindet sich die Liste der definierten Template DataSources. Jede Template DataSource zeigt auf ein Property des Forms in dem sich das Template Control befindet. Im Beispiel hat das Form ein Property oAddress vom Typ cdAddress (eine Component), welches wiederum einige Unterproperties hat. Wie im Bild zu sehen, verweist die Template DataSource Street auf das Property sStreet von oAddress . Der Name einer Template DataSource muss eindeutig sein. Aus dem HTML kann nun mittels einer Template Variable auf die Template DataSource zugegriffen und der Wert wie gewünscht im HTML formatiert werden. HTML Auf der linken Seite der Registerkarte HTML befindet sich der HTML-Codeeditor, in dem das HTML für das Template Control definiert werden kann. Note Das benutzerdefinierte HTML wird zur Laufzeit vom HTML Client (Angular) compiliert und optimiert. Grobe Fehler wie z.B. nicht geschlossene Tags oder invalides HTML können zu Anzeigefehlern führen, die unter Umständen auch andere Bereiche des HTML Clients betreffen. Templates sollten vor dem produktiven Einsatz in allen verfügbaren Browsern ausgiebig getestet werden. Button Use Base Mit dem Button Use Base kann das HTML Template z.B. nach einem Customizing wieder auf die Basis zurückgesetzt werden. Button Template Variable Mit dem Button Template Variable kann eine neue Template Variable erstellt, oder eine bestehende geändert werden. Button MLKey Mit dem Button MLKey wird das MLKey-Wörterbuch geöffnet. Dort kann ein neuer Template MLKey erstellt, oder ein bestehender geändert werden. HTML Aufbau Der benutzerdefinierte HTML Code wird im HTML Client in ein <div> -Tag mit der CSS-Klasse tpl verpackt. Es ist also nicht unbedingt nötig, um den eigenen HTML Code ein <div> -Tag als Container zu implementieren. Der generierte Code aus dem Beispiel sieht im HTML Client z.B. so aus: <hc-tpl-ctrl-content class=\"ng-star-inserted\"> <div class=\"tpl\"> <div class=\"wrapper\"> <div class=\"icon\"> <img class=\"img\" src=\"data:image/png;base64,iVBORw...\"> </div> <div class=\"text\"> <span class=\"header\">Adresse</span> <span>Max Mustermann</span> <span>Musterstraße 7a</span> <span>78333 Musterstadt</span> </div> </div> </div> </hc-tpl-ctrl-content> Das <div> -Tag mit der CSS-Klasse tpl kann im CSS wie gewünscht angepasst werden, ohne einen eigenen Container oder eine eigene CSS-Klasse verwenden zu müssen. Placeholder Die Konstante %FILESURL% kann im HTML verwendet werden, um zur Laufzeit die Broker-Url zu erhalten. Dadurch können z.B. in <img> -Tags auf Bilder, welche als Ressourcen im Framework Studio hinterlegt wurden, zugegriffen werden. Dynamische Bilder können über eine binäre Template-Variable realisiert werden. (siehe Abschnitt Images im Template ) Template Variablen Über den Button Template Variable öffnet sich der Template Variable Editor . Befindet sich der Cursor im Codeeditor auf einer bestehenden Template Variable, wird diese im Editor vorselektiert. Auf der linken Seite werden alle zur Verfügung stehenden Template DataSources aufgelistet. Auf der rechten Seite kann für die Template Variable ein passendes Format und/oder FormatPattern definiert werden. Durch die Aufteilung in Template DataSources und Template Variablen werden die Daten und deren Formatierung im HTML strikt voneinander getrennt. Beispielsweise könnte der Wert einer Template DataSource im englischen HTML anders formatiert werden als im deutschen HTML. Template Variablen werden im HTML-Code wie folgt angezeigt: {{ ds:[Name]|f:[Format]|fp:[FormatPattern]|pv:[PreviewValue] }} Dabei verweist [Name] auf den Namen der zugehörigen Template DataSource, [Format] und [FormatPattern] definieren das im Template Variable Editor ausgewählte Format und FormatPattern. PreviewValue ist derjenige Wert, der für die Template Variable angezeigt wird, wenn das Template auf der Registerkarte Preview zur Vorschau gerendert wird. Der Wert wird zur Laufzeit ignoriert. Note Es wird empfohlen, Template Variablen und Template MLKeys immer über den jeweiligen Editor zu ändern, um Syntaxfehler zu vermeiden. Template MLKey Template MLKeys werden im HTML-Code wie folgt angezeigt: {{ mlkey:[MLKey-Name] }} Dabei verweist [MLKey-Name] auf den Namen des zugehörigen MLKeys. Zum Beispiel \"SYS_OK\". CSS Das benutzerdefinierte HTML kann mittels CSS im CSS-Codeeditor auf der Registerkarte CSS beliebig angepasst werden. Beispiel: .tpl { display: flex; flex-direction: column; background-color: lightyellow; border: 0.1rem solid gray; border-radius: 0.3rem; } .tpl[tplDisabled] { background-color: grey; } .wrapper { flex: 1; display: flex; justify-content: left; padding: 1rem; padding-left: 1.5rem; line-height: 1.7rem; } .icon { flex: 0 0 auto; display: flex; flex-direction: column; align-items: center; justify-content: center; } .text { flex: 1; display: flex; flex-direction: column; justify-content: left; padding-left: 1.5rem; line-height: 1.7rem; } .img { max-height: 6rem } .header { font-weight: bold; margin-bottom: 0.3rem; } Wie im Kapitel HTML beschrieben, wird ein ListItem mit einem <div> -Tag der CSS-Klasse tpl umgeben. Im CSS-Code kann somit über den CSS-Selector .tpl auf das Element zugegriffen werden. REM anstatt Pixel Im CSS sollten Größenangaben ausschließlich mit rem angegeben werden. Der HTML Client skaliert die gesamte Anzeige anhand der vom Browser vorgegebenen Schriftgröße. Im HTML Client wird global für das HTML- und das BODY-Tag folgendes definiert: html { font-size: 62.5%; } body { font-size: 1.4rem; } In Desktop-Browsern wie z.B. Chrome, Firefox oder Edge ist der Standardwert der Schriftgröße 16px . 1rem ist per Definition genauso groß wie die Schriftgröße des HTML-Tags, also im Standardfall erst einmal 16px . Setzt man nun die font-size des HTML-Tags auf 62.5% , ergibt sich eine Schriftgröße von 10px , womit 1rem nun ebenfalls 10px groß ist. Da meist in Desktop-Browsern entwickelt und getestet wird, ergibt diese Anpassung Sinn, da es viel einfacher zu verstehen ist, mit Faktor 10, als mit Faktor 16 zu arbeiten. 0.5rem sind 5px , 5rem sind 50px usw. Deshalb wird im BODY-Tag auch die Schriftgröße auf 1.4rem gesetzt, was letztenendes 14px sind. Dies spiegelt die Standardschriftgröße des HTML Clients wieder. Probleme können nun enstehen, wenn REM- und Pixelwerte gemischt werden! Ein Beispiel: .tpl .remClass { width: 10rem; } .tpl .pxClass { width: 100px; } Nehmen wir an, es gibt zwei HTML-Elemente im Template mit den Klassen remClass und pxClass . Liefert der Browser eine Standardgröße von 16px , besteht kein Problem, die beiden Elemente sind exakt gleich groß, da 65.5% von 16px = 10px . Damit sind 10rem exakt 100px . Anders sieht es aber aus, wenn z.B. ein mobiler Browser eine Standardschriftgröße von 14px liefert. 62.5% von 14px = 8.75px , damit sind 10rem exakt 87.5px und die beiden HTML-Elemente sind plötzlich unterschiedlich groß. Dies kann je nach Gerät und verwendetem Browser zu unvorhersehbaren Skalierungsfehlern führen. Tip Es wird ausdrücklich empfohlen, im HTML/CSS des Template Controls rem als Größeneinheit zu verwenden. IsEditable Im CSS kann auch ein Style für das Template hinterlegt werden, wenn IsEditable auf false gesetzt wird. Wird ein Template Control im Designer oder per Action auf isEditable = false gesetzt, so wird am <div> -Tag tpl das HTML-Attribut tplDisabled hinzugefügt: ```html <hc-tpl-ctrl-content class=\"ng-star-inserted\"> <div class=\"tpl\" tplDisabled=\"true\"> [...] </div> </hc-tpl-ctrl-content> Im CSS-Code kann über den Attribute-Selector .tpl[tplDisabled] genau dieser Fall abgefragt werden. Im Beispiel wird der Hintergrund des Templates auf grau gesetzt. Images im Template Eine Besonderheit ist das Anzeigen von Bildern in einem Template Control mittels <img /> , wenn dieses über ein byte[] aus der Datenbank gebunden werden soll. Ein Anwendungsfall wäre z.B. das Anzeigen von Icons. Beispiel: <img class=\"img\" src=\"data:{{ ds:MimeType }};base64,{{ ds:Image }}\" /> Um ein Bild an ein HTML img-Tag zu binden sind zwei Template Variablen notwendig. Das byte[] mit den Bildinformationen alleine reicht abhängig vom genutzten Browser nicht immer aus (siehe Hinweis). Es muss zusätzlich der HTML Mime-Type spezifiziert werden, sodass der Browser weiß, um welches Bildformat es sich handelt. {{ ds:MimeType }} ist eine Template Variable vom typ FSstring oder string und gibt z.B. den Mime-Type \"image/png\" oder \"image/jpg\" zurück. {{ ds:Image }} ist eine Template Variable vom Type FSByteArray oder byte[] . Binärdaten werden als Base64-String zum Client übertragen. Da das HTML src -Attribut Base64 versteht, ist keine weitere Formatierung der Daten nötig. Tip Die Angabe des Mime-Types ist in den meisten Browsern wie Chrome, Firefox, Safari oder Edge (auch auf mobilen Geräten) nicht zwingend nötig. Manche proprietären Browser auf mobilen Geräten haben jedoch Schwierigkeiten, ohne die Angabe des Mime-Types, das Bild korrekt darzustellen. Sollten diese Browser keine Rolle für die Anwendung spielen, kann auch folgendes HTML genutzt werden: <img class=\"img\" src=\"data:;base64,{{ ds:Image }}\" /> Das Semicolon vor base64 ist ohne die Angabe des Mime-Types zwingend notwendig. Preview Wenn der HTML-Code gültig ist, wird auf der Registerkarte \"Preview\" eine gerenderte Vorschau des Templates angezeigt. Für die Vorschau werden die PreviewValues für die einzelnen Template Variablen verwendet. Sollte ein PreviewValue nicht gesetzt sein, wird stattdessen der DataSource Name angezeigt. Template MLKeys zeigen den im Wörterbuch hinterlegten Text an. Preview Size Mit der Preview Size kann im Editor die Größe der Vorschau geändert werden. Damit kann sehr einfach überprüft werden, wie sich das Template in unterschiedlichen Größen verhält. Diese Einstellung hat keinen Einfluss auf die Laufzeit. Fallback auf die Standardsprache Sollte für die im Template Editor ausgewählte Sprache (z.B. Englisch) kein HTML oder CSS vorhanden sein, so wird das HTML oder CSS der Standardsprache (Deutsch) verwendet. So kann z.B. für \"Englisch\" nur das HTML überschrieben werden. im Preview und zur Laufzeit wird dann das englische HTML mit dem deutschen CSS kombiniert."
  },
  "doc/form/control/picture.html": {
    "href": "doc/form/control/picture.html",
    "title": "Picture",
    "keywords": "Picture Properties/Events Actions Das Picture-Control dient als Positionsrahmen für Bilder. Ziehen Sie dazu das Control Picture per Drag & Drop auf das Form und hinterlegen Sie anschließend die URL für das Bild. Über den Datasource lassen sich auch dynamisch Bilder zuordnen. Das Picture-Control unterstützt, wie der Image-Button, die Formate GIF, JPG und PNG."
  },
  "doc/form/control/menu-item.html": {
    "href": "doc/form/control/menu-item.html",
    "title": "Menu-Item",
    "keywords": "Menu-Item Properties/Events Actions"
  },
  "doc/form/control/dashboard-container.html": {
    "href": "doc/form/control/dashboard-container.html",
    "title": "DashboardContainer",
    "keywords": "DashboardContainer Properties/Events Actions Der Dashboard Container kann Dashboards enthalten. Dashboards werden in Form von Registerkarten angezeigt und bestehen aus einer oder mehreren Spalte(n), die die Dashboard Items beinhalten. Das Dashboard Container Steuerelement ermöglicht es, mehrere Instanzen eines Formulars in einer vom Benutzer bestimmten Weise anzuzeigen. Das bedeutet, dass der Benutzer diese Instanzen erstellen, verschieben, maximieren, nach dem Maximieren wiederherstellen, vergrößern, verkleinern und schließen kann. Jedoch sind alle Aktionen auf das jeweilige Dashboard beschränkt. Folglich kann kein Dashboard Item aus dem Dashboard Container herausgeschoben werden. Am Dashboard lässt sich eine DataSource festlegen. Darin wird, sobald Änderungen am Layout vorgenommen werden, das neue Layout als XML-string hinterlegt. Wird die DataSource Broker-seitig verändert, so wird das neue Layout vom Client umgesetzt. Zusätzlich gibt es ein OnLayoutChanged-Ereignis am Dashboard Container, welches am Broker aufgerufen wird, sobald am Client eines dieser Layout ändernde Ereignisse auftritt: Positions-/Größenänderung der Dashboard Items Hinzufügen/Entfernen von Dashboard Items Maximieren/Wiederherstellen von Dashboard Items Hinzufügen/Entfernen von Registerkarten Umbenennen von Registerkarten Registerkartenwechsel Damit dies nicht zu oft geschieht, gibt es einen Bearbeitungsmodus, der für solche Aktionen (mit Ausnahme des Registerkartenwechsels) aktiviert sein muss. Der Bearbeitungsmodus kann durch die Methode SetEditable am Dashboard Container Steuerelement gesteuert werden. Ein Dashboard Item kann durch Spezifizierung des Dashboard Containers am Workflow Link geöffnet werden:"
  },
  "doc/ide/references.html": {
    "href": "doc/ide/references.html",
    "title": "References",
    "keywords": "References Wenn innerhalb eines Namespaces Klassen eines weiteren Namespaces genutzt werden sollen, müssen diese über ein using -Statement eingebunden werden. Dasselbe gilt, wenn Sie externe Klassen nutzen wollen, wie z.B. die des .Net Frameworks. Über den Dialog References können Sie sowohl interne, als auch externe Referenzen erzeugen. Wenn Sie als Datentyp für ein Property eine Klasse aus einem anderen Namespace auswählen, wird automatisch ein using für diesen Namespace generiert. Referenzen anlegen / löschen Um eine Referenz hinzuzufügen, wählen Sie zunächst den Namespace auf der Registerkarte Namespaces aus, dem die Referenz hinzugefügt werden soll. Öffnen Sie anschließend den Dialog References , in dem Sie im unteren Bereich der Registerkarte das Kontext-Menü zu dem Namespace aufrufen und den Eintrag References... aufrufen oder auf den Button (References) klicken. Erzeugen Sie anschließend eine neue Referenz, indem Sie in der Combobox den Bereich auswählen, für den die Referenz erzeugt werden soll und drücken den Button (New) . Sie sehen die neue Referenz jetzt als Eintrag in der Listbox. Nun werden noch die Einstellungen für die Referenz angepasst, wie nachfolgend beschrieben. Löschen können Sie eine Referenz, indem Sie in der Combobox den gewünschten Bereich auswählen und anschließend in der Listbox die zu löschende Referenz markieren. Mit dem Button (Delete) wird die Referenz gelöscht. Diese Aktion wird erst mit dem Button (Save All) im Repository wirksam. Wenn ein anderer Namespace innerhalb von Framework Studio referenziert werden soll, wählen Sie als Reference-Type \"Framework Studio\" . Über die Combobox Namespace haben Sie dann die Möglichkeit den Namespace auszuwählen, der eingebunden werden soll. Object-Type definiert, zu welchem Bereich die Referenz gehört. Da die einzelnen Bereiche eigene Assemblies erzeugen, ist dieser hier ebenfalls zu definieren. Der Standardtyp wird Component sein, da zumeist auf Components referenziert werden wird. Sollten Sie externe Klassen nutzen wollen, geben Sie als Reference-Type External an. Über den Datei-Auswahl-Dialog können Sie anschließend die COM-Component oder .Net Assembly auswählen, die Sie einbinden möchten. Referenzen bearbeiten Um eine Referenz zu bearbeiten, wählen Sie in der Combobox den gewünschten Bereich und anschließend in der Listbox die zu bearbeitende Referenz aus. Auf der rechten Seite des Fensters werden die Daten der Referenz bearbeitet. Name Hier können Sie die Namen der Referenz angeben. Framework Studio belegt diesen Namen mit ReferenceXX vor. Use In Sub Namespaces Über diese Checkbox können Referenzen an Sub Namespaces vererbt werden. Die vererbten Referenzen werden in den Sub Namespaces als Readonly mit dem Zusatz, aus welchem Namespace die Refernz stammt, dargestellt. Framework Studio Wählen Sie diesen Radio-Button, wenn Sie eine Framework-Studio-interne Referenz haben wollen. Namespace Hier benennen Sie für eine interne Referenz den Namespace, der verwendet werden soll. Object Type Hier geben Sie für eine interne Referenz an, welcher Bereich eingebunden werden soll. In der Regel werden Sie hier Component angeben. External Wählen Sie diesen Radio-Button, wenn Sie eine externe Assembly einbinden möchten. Assembly Hier können Sie ein Assembly angeben, das eingebunden werden soll. Mit dem Button Browse öffnen Sie eine Datei-Auswahl, in der Sie ein Assembly angeben können. In dieser Zeile können folgende Platzhalter verwendet werden: $CodeDirectory: Definiert das Compile-Verzeichnis des Brokers $DotNetDirectory: Definiert das Verzeichnis des .NET Framework 4.0 $GAC: Die Assembly soll aus dem GAC geladen werden From GAC Siehe Referenzen auf GAC-Assemblies Usings Hier müssen Sie angeben, welche Namespaces aus dem eingebundenen Assembly verwendet werden sollen. Mit dem Button [+] wird ein neuer Eintrag erstellt und mit dem Button [-] wird der aktuell markierte Eintrag gelöscht. Referenzen auf GAC-Assemblies Es können Assemblies aus dem GAC (Global Assembly Cache) in Framework Studio referenziert werden. From GAC Button: Nach dem Klick auf den Button erscheint eine Auflistung mit allen Assemblies, die im GAC des aktuellen PC‘s oder Servers vorhanden sind: GAC-Assembly Auswahldialog: Wird eine Assembly ausgewählt, erscheint diese mit dem Prefix $GAC und dem starken Namen im References-Dialog: $GAC-Prefix: Wie gewohnt können dann Usings definiert und die Assembly im Code verwendet werden. Caution Welche GAC-Assemblies auf einem PC oder Server vorhanden sind, ist unterschiedlich und von installierter Software abhängig. Wird eine Framework Studio Applikation auf einem PC oder Server veröffentlicht oder kompiliert, auf dem die referenzierten GAC-Assemblies nicht vorhanden sind, kann es zu Laufzeit- oder Compilierfehlern kommen. Es muss dann sichergestellt werden, dass etwaige Drittsoftware korrekt installiert ist."
  },
  "doc/ide/framework-designer.html": {
    "href": "doc/ide/framework-designer.html",
    "title": "Framework Studio IDE",
    "keywords": "Framework Studio IDE Mit dem Framework Designer gestalten Sie auf komfortable Weise Resources , Access Units , Metadatatypes , Datasources , DBTables , Components , Global Objects , Reports , Custom Controls , Forms und Workflows . Diese grundlegenden Elemente sind über die Registerkarte Namespaces ( Registerkarte Namespaces ) erreichbar. Andere Elemente wie Code-Templates , Laufzeitlizenzen und die Access Unit Hierarchie sind über das Menü Tools erreichbar. Nachfolgend werden die Registerkarten auf der linken Seite erklärt. Anschließend folgen allgemeine Funktionalitäten."
  },
  "doc/ide/framework-compiler.html": {
    "href": "doc/ide/framework-compiler.html",
    "title": "FrameworkCompiler",
    "keywords": "FrameworkCompiler Der FrameworkCompiler ist ein besonderer Benutzer innerhalb von Framework Studio . Seine Hauptaufgabe besteht darin, den kompilierten Code einer Anwendung, den sog. Saved-Code, in das Repository zu schreiben. Hintergrund ist das Entwicklungsmodell von Framework Studio . Mehrere Entwickler arbeiten an einer Anwendung, checken Elemente aus und ein. Der FrameworkCompiler ist die Instanz, die alle Änderungen zu einem gesamten funktionierenden Stand zusammenfügt. Dies könnte z.B. nachts über einen Job stattfinden, da zu dieser Zeit normalerweise auch kein Entwickler angemeldet ist. Warning Der FrameworkCompiler kann selbst keine Objekte auschecken und bearbeiten. Siehe hierzu Benutzer bearbeiten TODO! Link. Ein Compile-Vorgang mit dem FrameworkCompiler hat folgenden Ablauf: Als erstes wird der Workspace des FrameworkCompiler aktualisiert. Hier werden alle von den Entwicklern eingecheckten Objekte herangezogen. Danach wird der gesamte Code kompiliert. Der Quellcode (Saved Code) sowie die daraus erzeugten Assemblies werden nach einem erfolgreichen Compile-Vorgang in die Datenbank geschrieben. Nun wird der Compile-Stamp des FrameworkCompilers aktualisiert. Hieran wird festgesetzt, ob die Entwickler mit einem aktuellen Workspace arbeiten oder nicht. Ein erfolgreicher Durchlauf des FrameworkCompilers stellt somit sicher, dass sich im Repository ein sauberer Entwicklungsstand mit jeglichem Source Code und jeglichen Assemblies befindet, auf dem die Entwickler ihre tägliche Arbeit aufbauen können."
  },
  "doc/ide/dokumentation.html": {
    "href": "doc/ide/dokumentation.html",
    "title": "Dokumentation",
    "keywords": "Dokumentation Einer der größten Kostentreiber eines jeden Softwareprojektes sind schlechte Dokumentationen, welche die Wiederverwendbarkeit von Code einschränken und die Wartung erschweren. Je besser Ihr Code dokumentiert ist, desto effektiver werden Sie ihn nutzen können. Allgemeines Um die Übersichtlichkeit, Wiederverwendbarkeit und Wartbarkeit Ihres Codes zu gewährleisten, sollten Sie ihre Metadatentypen, Properties und Methoden entsprechend beschreiben. Um Metadatentypen und Components mit Kommentaren zu versehen, öffnen Sie diese im Framework-Designer und tragen die Beschreibung in das Feld Description ein. Dabei muss die Eingebesyntax, wie im Folgenden ausgeführt, beachtet werden. Zu Properties können Sie Kommentare hinterlegen, indem Sie die Component, die das Property enthält, über die Combobox auf der Registerkarte Property auswählen und auf der Property-Registerkarte Description einen Kommentar hinterlegen. Component: Bei Methoden sollten Sie Kommentare, Beschreibungen der Parameter, Beispiele u.ä. im Methodenkopf, also noch vor Deklaration der Methode hinterlegen. Ist der Code ordentlich dokumentiert, haben Sie mit NDoc eine einfache Möglichkeit, eine Entwicklerdokumentation im Stil der MSDN zu erstellen. Warning Dazu ist es allerdings notwendig, dass die Kommentare auch in MSDN-konforme Tags eingeschlossen sind. Syntax Damit die Kommentare von NDoc richtig verarbeitet werden, ist es wichtig, diese in Tags einzufassen. Ein Tag ist einfach eine Beschreibung, die den Inhalt definiert. XML benötigt für eine Beschreibung immer 2 Tags, einen öffnenden und einen schließenden. Der schließende Tag unterscheidet sich dabei von dem öffnenden, dass er ’\\’ vor der Tag-Bezeichnung trägt. Wenn Sie verschachtelte Tags benutzen, müssen diese von innen nach außen wieder aufgelöst werden. <summary> Zusammenfassung </summary> Tags, die Sie zum Beschreiben benötigen, sind: <summary> Beschreibung </summary> <param name =\"Parametername\"> Beschreibung </param> <returns> Returnparameter </returns> <remarks> Anmerkungen </remarks> <example> Beispiel </example> Sie können auch ein Code-Template anlegen, welches schon eine komplette Beschreibungsstruktur aufweist, so dass Sie die Tags nicht jedes Mal neu anlegen müssen. Wie Sie es vielleicht auch schon von Visual Studio her kennen, werden Kommentare im Code, die für externe Dokumentationszwecke gedacht sind, durch 3 führende Slashs ( /// ), interne dagegen durch 2 führende Slashs definiert. Beispiel eines Description-Templates: ///<summary> ///??? ///</summary> /// ///<param name=\"???\">???</param> /// ///<returns>???</returns> /// ///<remarks> ///??? ///</remarks> /// ///<example> ///??? ///</example> public void WriteView() Wenn Sie Kommentare in die Description-Felder eingeben, brauchen Sie keinen Slash voranstellen. Diese sind nur direkt im Code, wie bei Methoden notwendig. Weitere gültige Tags können Sie der NDoc-Hilfe entnehmen."
  },
  "doc/html-client/index.html": {
    "href": "doc/html-client/index.html",
    "title": "HTML-Client",
    "keywords": "HTML-Client Neben dem Java Client bietet Framework Studio auch einen HTML-Client für Desktop- sowie mobile Geräte an. Dieser unterstützt noch deutlich weniger Funktionen und Controls als der Java Client. Was derzeit schon mit dem HTML-Client möglich ist, erfahren Sie in diesem Kapitel. Aktivieren des HTML-Clients Damit der HTML-Client über den Run Wizard und die Broker-Startseite gestartet werden kann, muss in der Application die Checkbox Supports Html Client gesetzt werden. Dies soll vermeiden, dass bisher existierende Applikationen ohne Weiteres im HTML-Client gestartet werden können, da diese sehr wahrscheinlich auf Controls und Funktionalitäten aufbauen, die derzeit vom HTML-Client noch nicht oder nicht vollständig unterstützt werden. Browser-Unterstützung Desktop Der HTML-Client basiert auf modernster Webtechnologie und benötigt deshalb auch einen aktuellen Browser für die Ausführung. Für Desktopsysteme empfehlen wir folgende Browser : Chrome Firefox Edge Safari (OSX) Auch alle weiteren Browser, basierend auf der Chromium-Engine (Opera, Vivaldi), funktionieren problemlos. Note Internet Explorer 11 kann auf Grund der betagten JavaScript-Engine nicht mehr verwendet werden. Mobile Endgeräte Eine auf den HTML-Client ausgelegte Applikation kann über die Broker-Startseite natürlich auch von einem beliebigen mobilen Gerät aus gestartet werden, welches über einen aktuellen Browser verfügt. Die Unterstützung der Browser im mobilen Umfeld ist sehr schwer zu beurteilen, da es gerade auf Android eine extrem große Auswahl gibt. Wir empfehlen deshalb folgende mobilen Browser : Chrome Firefox Edge Dolphin Android Browser (ab Android 5.1) Safari (ab iOS 10)"
  },
  "doc/html-client/funktionsumfang.html": {
    "href": "doc/html-client/funktionsumfang.html",
    "title": "Funktionsumfang",
    "keywords": "Funktionsumfang Der HTML-Client befindet sich noch in der agilen Entwicklung. Verglichen mit dem ausgereiften JavaClient ist der Funktionsumfang des HTML-Clients noch überschaubar. Neue Funktionen und die Unterstützung für weitere Controls werden kontinuierlich weiter entwickelt und veröffentlicht. Note Wird in diesem Kapitel etwas nicht erwähnt, wie z.B. ein Property eines Controls, eine Action oder andere Client-Funktionalitäten, so muss davon ausgegangen werden, dass diese noch nicht unterstützt werden. Handhabung von nicht unterstützten Funktionalitäten Es gibt im Form Designer oder im Code Editor von Framework Studio keine Limitierungen, die den Entwickler auf den Funktionsumfang des HTML-Clients einschränken. Werden Controls, Actions oder anderweitige Funktionalitäten genutzt, die vom HTML-Client nicht unterstützt werden, so werden diese (so weit es möglich ist) vom Client ignoriert. Wenn z.B. ein Grid-Control in ein Form eingebaut wird, so wird dieses erst garnicht vom HTML-Client interpretiert. Dasselbe gilt für nicht unterstützte Properties an Controls. Frameset Der HTML-Client besitzt kein Frameset. Alle geöffneten Forms werden in einer einzigen Liste organisiert. Es ist irrelevant, welchem Frame ein Form in einem Workflow zugeordnet ist. MessageBox und ExceptionBox Werden vollständig unterstützt inkl. Buttons, Icons, DialogResult und EventHandler. Werden im Client als modale Popups angezeigt. Modale Forms Modale Forms, die das Wechseln zu einem anderen Form unterdrücken, werden vom HTML-Client vollflächig angezeigt. Dabei wird der Menü-Button ausgeblendet. Verhalten beim Drücken des „Zurück“-Button auf einem mobilen Gerät: Wenn am Form das Property IsCloseIconVisible auf true gesetzt ist, wird der modale Dialog geschlossen. Wird dem Form über die Action SetCloseButton ein Button zugewiesen, dessen Click-Event beim Schließen ausgelöst werden soll, wird dies beim Drücken des Zurück-Button ebenfalls ausgelöst. Ist das Property HideModalHeader am Form auf true gesetzt, so wird der Header mit dem Titel und ggf. dem Close Button komplett ausgeblendet, um mehr Platz für Controls zu schaffen. In diesem Fall muss das Schließen des Dialogs über einen eigens implementierten BUtton erfolgen, der am Form die Methode Close() aufruft. Drag & Drop Drag & Drop und alle damit verbundenen Events werden vom HTML Client nicht unterstützt. Shortcuts und ToolTips Da für den HTML-Client die mobile Welt im Vordergrund steht, werden Shortcuts und ToolTips noch nicht unterstützt, da diese auf einem Handy bzw. Tablet keinen Sinn machen. Control Styles Control Styles werden für alle im HTML-Client verfügbaren Controls unterstützt. Wird im Form Designer einem Control ein Control Style zugeordnet, so werden dessen Properties korrekt interpretiert bzw. die Property-Hierarchie beachtet. Actions Es werden derzeit folgende Actions unterstützt: ScanBarcode TakePhoto GetGeoLocation SetCloseButton SetEnabled SetImage SetVisible ViewDocument ViewDocument Action Die ViewDocument Action ist im HTML Client auf folgende Url-Schemen limitiert: http://*/* https://*/* mailto:* geo:* tel:* sms:* Zurück-Button auf mobilen Geräten Mobile Geräte (z.B. Android) besitzen teilweise einen Zurück-Button. Der HTML Client unterstützt diesen kontextabhängig. Es gibt drei Prioritätsebenen, die nacheinander durchlaufen werden. Wird in einer Ebene auf das Drücken des Zurück-Buttons reagiert, so werden die darunter liegenden Ebenen nicht mehr behandelt. Die Ebenen geordnet nach Priorität sind: Overlays Modale Dialoge Normale Anzeige Overlays Als Overlay definiert sich alles, was sich mit einem ausgegrauten Hintergrund über die restliche Anzeige legt, wie z.B. MessageBoxen oder die ComboBox-Auswahl. Wenn ein Overlay geöffnet ist und der Zurück-Button gedrückt wird, wird das Overlay geschlossen. Eine MessageBox kann nur durch den Zurück-Button geschlossen werden, wenn ein Abbrechen-Button vorhanden ist. Modale Dialoge Modale Dialoge können mit dem Zurück-Button geschlossen werden, wenn das Property IsCloseIconVisible am Form auf true gesetzt ist. Wurde dem Form über die Action SetCloseButton ein Button mit einem Click-Event zugeordnet, so wird beim Drücken des Zurück-Buttons das Click-Event ausgelöst. Normale Anzeige Befindet sich der HTML Client in einem normalen Form, wird beim Drücken des Zurück-Buttons das Beenden der Application angestoßen, was mit der Rückfrage, ob die Session beendet werden soll, einher geht. Befindet sich der HTML Client im Broker-Auswahldialog, wird die Anwendung ohne Rückfrage geschlossen."
  },
  "doc/html-client/fokussystem.html": {
    "href": "doc/html-client/fokussystem.html",
    "title": "Hinweis zum Fokussystem",
    "keywords": "Hinweis zum Fokussystem Ein besonderes Augenmerk muss auf die SetFocus Action in Verbindung mit den OnEnter und OnLeave Events an Controls gelegt werden, da in diesem Zusammenhang der JavaClient und HTML Client unterschiedlich reagieren. Vergleich zum JavaClient In der Programmierung für den JavaClient wird sehr oft der Fokus in einem OnLeave Event in ein anders Control gesetzt, welches nicht das direkt nachfolgende ist. Z.B. werden nach der Eingabe mehrere Textfelder übersprungen oder der Fokus in ein Grid gelegt. Diese Art der Programmierung funktioniert im JavaClient, da dessen Eventsystem synchron aufgebaut ist. D.h., der JavaClient kann bei einem OnLeave Event auf eine Antwort des Brokers warten, bevor er den Fokus tatsächlich in das gewünschte Control setzt. Dadurch wird das Fokussystem auch durch länger andauernde Requests nicht \"gestört\". Asynchrones Eventsystem in Browsern Das Eventsystem eines Web Browsers läuft hingegen asynchron ab. Bei einem Fokuswechsel kann zwar ein Broker Request abgesetzt werden (z.B. in einem OnLeave Event an einem Textfeld), auf dessen Response kann allerdings nicht gewartet werden. Dies hat zur Folge, dass der Fokus vom Browser ggf. in das nachfolgende Control gesetzt wird, bevor der Broker Request abgeschlossen ist. Je nachdem wie viel Zeit der Broker Request benötigt, kann dies in Verbinung mit der SetFocus Action zu seltsamen Effekten am Client führen. Das kann im schlimmsten Fall einen \"Focus-Lock\" hervorrufen, bei dem der Fokus in einem Control \"festhängt\". Dieses Dilemma kann technisch nicht gelöst werden. Aus diesem Grund gilt für die HTML Client Programmierung folgende Gundregel: Note In einem OnEnter oder OnLeave Event darf niemals eine SetFocus Action aufgerufen werden!"
  },
  "doc/html-client/controls.html": {
    "href": "doc/html-client/controls.html",
    "title": "Controls",
    "keywords": "Controls Symbol Bedeutung + Property oder Event wird vollständig unterstützt - Property oder Event wird nicht unterstützt o Property oder Event wird teilweise unterstützt (Anmerkung beachten) Allgemein Die folgende Auflistung beinhaltet diejenigen Properties und Events, die an allen verfügbaren Controls im HTML-Client vorhanden sind. Properties Name Unterstützt Anmerkung Alignment + BackColor + BorderColor + BorderRadius + BorderThickness + ButtonGroupDataSource + Caption + DockPanel.ItemSize + Font Family - Ist im Client hart definiert auf die Hierarchie Arial -> Helvetica -> Sans-Serif. Font Bold + Font Italic + Font Underline + ForeColor + IsEditable + LabelTemplate + MapEnterToTabAction - Margin + MaxSize + MinSize + Name + Padding + Shortcut - TabStop + ToolTip + Visibility + Events Name Unterstützt OnCanDrop - OnDrag - Form Properties Name Unterstützt BadgeImage DataSource + HideModalHeader + IsCloseIconVisible + MainMenu - PreferredSize - SymbolImage - Title + VerticalScrollbarOverlay - Events Name Unterstützt OnLoad + OnClose + Dock Panel Properties Name Unterstützt Anmerkung BackgroundImage - BackgroundScaleMode - DockPanelOrientation + Scrolling o Es wird immer VerticalOverlay verwendet, auch wenn Normal ausgewählt wurde, da in vielen Browsern die Breite der Scrollbar nicht berechnet werden kann. Spacing + Events Name Unterstützt OnEnter - OnLeave - Wrap Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - ContentAlignment + InvertFlowDirection + Spacing + WrapArrangement + Events Name Unterstützt OnEnter - OnLeave - Field Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - RowLabelTemplate + SynchronizeColumns + Events Name Unterstützt OnEnter - OnLeave - Field Row Properties Name Unterstützt FieldRowSize + LabelMode + OptimizeGeneratedLabels + Button Properties Name Unterstützt ShowCaption + TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + ImageButton Properties Name Unterstützt BadgeImage DataSource + CaptionAlign - ContextMenu - DataSource - DisabledImage + HighlightImage - Image + MouseOverImage + PressedImage + ScaleMode - ShowCaption + SymbolImage - TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + Label Properties Name Unterstützt DataSource + TextAlign + Events Name Unterstützt OnEnter + OnLeave + CheckBox Properties Name Unterstützt DataSource + ShowCaption + Events Name Unterstützt OnClick + OnEnter + OnLeave + Editfield Properties Name Unterstützt Anmerkung DataSource + DisabledBackColor o Wird dynamisch im Client berechnet DisplayLength + Editor o Nur \"PlainText”, \"HTML” wird nicht unterstützt Format + FormatPattern o Funktioniert nur mit Format \"Decimal\" Multiline + PasswordChar + Client generiert ein Password-Feld, wenn gesetzt. Das Passwort-Zeichen selbst kann aber nicht geändert werden (in Web Browsern technisch nicht möglich). ScrollBars + SelectionEnd - SelectionStart - TabStop + TextAlign + WordWrap + Events Name Unterstützt OnEnter + OnLeave + OnValidated + ComboBox Properties Name Unterstützt DataSource + DisplayLength + EditStyle + List + ListOrder + MaxDropDownSize + TabStop + Events Name Unterstützt OnEnter + OnLeave + OnSelectionChanged + RadioButton Properties Name Unterstützt CaptionDataSource + DataSourceOnValue + Events Name Unterstützt OnEnter + OnLeave + OnClick + Picture Siehe Picture . Note Im HTML Client muss einem Picture Control eine MinSize zugewiesen werden. Eine automatische Größenanpassung eines Picture Controls an den Inhalt ist nicht möglich. Properties Name Unterstützt CaptionAlign + DataSource + ScaleMode + ShowCaption + Events Name Unterstützt OnClick + OnEnter - OnLeave - ListView Siehe ListView . Properties Name Unterstützt DataSource + ItemArrangement + ItemSize + SelectedItems + SelectionMode + SelectorPosition + Spacing + Template + Events Name Unterstützt OnEnter - OnLeave - OnItemActivated + OnItemSelectionChanged + Template Control Siehe Template Control . Properties Name Unterstützt Template + Events Name Unterstützt OnEnter - OnLeave - Tabbed Window Properties Name Unterstützt DataSource + TabTemplateActive + TabTemplateDisabled + TabTemplateInactive + Events Name Unterstützt OnSelectedTabPageChange + OnSelectedTabPageChanged +"
  },
  "doc/comp/components.html": {
    "href": "doc/comp/components.html",
    "title": "Components",
    "keywords": "Components"
  },
  "doc/code-editor/index.html": {
    "href": "doc/code-editor/index.html",
    "title": "Code-Editor",
    "keywords": "Code-Editor Framework Studio bietet einen umfangreichen C#-Code Editor mit IntelliSense Funktion und Code Highlighting. Intellisense Der Code Editor beinhaltet die Funktionalität von IntelliSense, die kontextabhängig Code-Vervollständigung zur Verfügung stellt. Aufgerufen werden kann IntelliSense mit der Tastenkombination Strg + Leertaste an einer beliebigen Stelle im Code. Go to Definition Mit der Kombination Strg + Doppelklick oder über das Kontextmenü kann aus dem Code Editor heraus zu den angeklickten Zielen gesprungen werden. Dies funktioniert bei Properties und Methoden. Ausgenommen davon sind Methoden fremder Components. Go to Base Über den Eintrag Go to Base im Kontextmenü des Code Editors kann zu der Basis der aktuellen Methode navigiert werden. Compare with Base Über den Kontextmenüeintrag Compare with Base im Code Editor ist es möglich, Überschreibungen von Methoden mit deren Implementierung im Basis-Package zu vergleichen. Zum Vergleich wird ein externes Programm verwendet, welches mit dem Menüpunkt Tools / Options im Hauptfenster konfiguriert werden muss. (Vgl. Konfiguration von Method History Browser)"
  },
  "doc/code-editor/code-messages.html": {
    "href": "doc/code-editor/code-messages.html",
    "title": "Code-Messages",
    "keywords": "Code-Messages Wenn Sie eine Methode eines Forms bearbeiten, stehen Ihnen Editoren zum komfortablen Erstellen und Bearbeiten von mehrsprachigen Ausnahmen (Exceptions) und Meldungen (Message-Boxen) zur Verfügung. Diese können Sie über die Buttons Exception Editor Wizard und Message Box Editor Wizard aufrufen. Wenn Sie eine Textcollection ändern, indem Sie beispielsweise einen neuen Eintrag erzeugen oder einen bestehenden Eintrag ändern, dann muss die Textcollection dazu in der aktuellen Version für Sie ausgecheckt werden. Benutzen Sie dazu den Button Edit Message . Andere Benutzer können nun die Textcollection nicht bearbeiten. Beim Verlassen des Message Box Editors bzw. Exception Editors wird die Textcollection automatisch wieder eingecheckt, so dass auch andere Benutzer wieder auf die Textcollection zugreifen können. Beide Editoren weisen nur sehr geringfügige Unterschiede auf. Radiobutton ML Key Hier können sie einen MLKey angeben. Mit dem Auswahl-Button neben dem Textfeld öffnet sich der Dialog Select ML Key . Dies ist die Standard-Option. Neue Meldungen sollten immer über das Wörterbuch gezogen werden. Radiobutton New Message Wenn Sie diesen Radiobutton auswählen, wird ein neuer Text in die ausgewählte Textcollection eingetragen. Important Wenn Sie einen neuen Text hinzufügen, müssen Sie auch die Textcollection kompilieren, da es sonst beim Ausführen des Programms Fehlermeldungen gibt. Radiobutton Change Message Wenn Sie diesen Radiobutton auswählen, können Sie mit dem Button Choose existing Message einen bestehenden Eintrag aus der angegebenen Textcollection auswählen oder mit dem Button Search nach einem bestehenden Eintrag suchen. Button Change Collection Mit diesem Button kann die Textcollection geändert werden, aus der ein Text ausgewählt werden soll, bzw. in welcher der neue Text eingetragen werden soll. Als Default-Wert ist die Textcollection ctMessages ausgewählt. Button Choose existing Message Mit diesem Button kann aus der gewählten Textcollection ein existierender Eintrag ausgewählt werden. Feld Collection Zeigt an, welche Textcollection ausgewählt ist. Button Search Mit diesem Button öffnen Sie einen Suchdialog. In diesem Dialog wird die Suche auf die Textcollection, die im Exception Editor / Message Box Editor angegeben ist, eingeschränkt. Die Suchfunktionalität ist identisch mit den Möglichkeiten, die auf der Registerkarte Search im Framework-Designer zur Verfügung gestellt werden. Text-Grid Ist ein MLKey ausgewählt, wird hier nur der Text angezeigt. Der ML Key kann über das Textfeld bzw. den Auswahl-Button geändert werden. Die Bearbeitung der Texte-Inhalte erfolgt über das Wörterbuch . In diesem Grid kann der Text der Message in den verschiedenen Sprachen eingegeben werden. Wurde mit Choose existing Message ein Eintrag ausgewählt, wird dieser geändert und in die Textcollection zurückgeschrieben. Alle vorhandenen Message-Boxen, die diesen Eintrag verwenden, sind ebenfalls davon betroffen. Dem Text können Parameter zugewiesen werden. Die Parameter werden in der Form {0}, {1} usw. angegeben. Jeder Parameter kann mehrmals verwendet werden. Der Beleg {0} für Kunde {1} hat sich geändert. Wollen Sie den Beleg {0} speichern? Die Parameter werden in der Textbox String.Format... gefüllt. Combobox Icon (nur Message-Box) Gibt an, welches Icon verwendet werden soll Error Exclamation Information Question None Combobox Buttons (nur Message-Box) Gibt an, welche Buttons angezeigt werden sollen. Wird OK ausgewählt, ist es nicht notwendig, einen Event-Handler zu hinterlegen. Werden andere Buttons ausgewählt, muss ein Event-Handler hinterlegt werden. AbortRetryIgnore OK OKCancel RetryCancel YesNo YesNoCancel Combobox Default (nur Message-Box) Gibt den Button an, der beim Anzeigen der Message-Box ausgewählt sein soll. So kann z.B. bei den Buttons YesNo durch Angabe von Button2 das versehentliche Betätigen des Yes -Button verhindert werden. Button1 Button2 Button3 Die Nummer des Buttons entspricht der Angabe bei Buttons. z.B. YesNoCancel bedeutet Button1 = OK , Button2 = No , Button3 = Cancel Button Event Handler (nur Message Box Editor) Mit diesem Button kann angegeben werden, ob mit dem Klick in der Message-Box (z.B. auf OK oder Cancel ) ein Event angestoßen werden soll oder nicht. Ist der Button gedrückt, erscheint rechts daneben eine Combobox, mit der evtl. bestehende Methoden ausgewählt werden können. Mit dem Button New wird ein neuer Event-Handler angelegt. Es wird eine Methode OnMsgBoxClick1 angelegt. Der Parameter MsgBoxEventArgs hat ein Property DialogResult, damit abgefragt werden kann, welcher Button gedrückt wurde. public void OnMsgBoxClick1(object sender, MsgBoxEventArgs e) { if (e.DialogResult == DialogResult.OK) { //Code for Ok. } } Combobox Severity (nur Exception Editor) Hier können Sie den Schweregrad der Ausnahme (0-3) festlegen. Add Inner Exception (nur Exception Editor) Wenn die Checkbox gesetzt ist, können Sie das Property InnerException füllen. Geben Sie dazu die zu übergebende Variable im Textfeld an. Geben Sie dazu im Textfeld den Namen der lokalen Exception-Variable an. Textbox String.Format... In dieser Textbox können die Parameter der Message angegeben werden. Es ist möglich im Message Text Parameter anzugeben. Dies geschieht mit {0}, {1} usw. Diese Parameter können im Text auch mehrmals verwendet werden. Für jeden dieser Parameter kann hier, mit Komma getrennt, ein Wert angegeben werden. Der erste Parameter steht für {0} , der zweite für {1} usw. this.oOrder.lngOrderID, this.oOrder.lngCustomerID Button OK Schließt den Dialog und fügt den generierten Message-Code in den Code-Editor ein. Button Cancel Schließt den Dialog und verwirft die Änderungen. Wenn der Message-Box-Editor mit OK verlassen wird, wird an die Stelle im Code, an der sich der Cursor befindet der Code generiert. // FSCodeMessage: Really delete article {0}? MsgBox.Show(this.Global.FormatMLKeyText(MLKeys.MSG_9188180c5ac64a5384141b553eef8105, this.oSelectedArticle.sName), \"\", MsgBoxButtons.YesNo, MsgBoxIcons.Question, new MsgBoxEventHandler(OnDeleteQuestionMsgBoxClick)); Durch eine farbige Markierung ist dieser Code im Code-Editor gut zu erkennen. Um die Code-Message nachträglich zu ändern, setzen Sie den Fokus irgendwo in den generierten Code-Block und drücken erneut den entsprechenden Wizard-Button. Es öffnet sich wieder der Editor wie oben und die Daten der Code-Message werden angezeigt und können geändert werden. Bei Bedarf können auch einzelne Bestandteile wie z.B. der MLKey oder ein Enum-Wert direkt im Code geändert werden. Caution Die Struktur des Code darf jedoch nicht geändert werden, weil dieser sonst für eine spätere Bearbeitung mit dem Editor nicht geparsed werden kann. Der Code darf nicht mehrzeilig sein."
  },
  "doc/sql/grammatik.html": {
    "href": "doc/sql/grammatik.html",
    "title": "SQL-Grammatik",
    "keywords": "SQL-Grammatik Im Folgenden ist die Grammatik beschrieben, die vom Framework Studio SQL-Parser verstanden wird. Alle an die Datenbank geschickten Befehle müssen dieser Grammatik genügen, ansonsten kommt es zu SqlParser-Exceptions. Grammatik für SQL-Kommandos <select> SELECT [DISTINCT] { * | <resultColumn>[,…n] } FROM { <singleSource> | <joinSource> } [ WHERE <condition> ] [ GROUP BY <value>[,…n] [HAVING <condition>]] [ {UNION [ALL] | INTERSECT | EXCEPT} <select(ohne orderby)> ] [ ORDER BY <orderColumn>[,…n] ] <insert> INSERT INTO <identifierChain> ( <identifier>[,…n] ) { VALUES ( <value>[,…n] ) | <select> } <update> UPDATE <identifierChain> SET {<identifierChain> = <value> } [,…n] [ WHERE <condition> ] <delete> DELETE [FROM] <identifierChain> [ WHERE <condition> ] Grammatik für die Bestandteile der Kommandos <resultColumn> <identifierChain>.* | <value> [AS <identifier>] <singleSource> ( <singleSource> ) | <identifierChain> [ [AS] <identifier> ] <joinSource> ( <joinSource> ) | { <singleSource> | <joinSource> } { INNER | {LEFT | RIGHT | FULL} [OUTER] } JOIN { <singleSource> | <joinSource> } ON <condition> <condition> ( <condition> ) | NOT <condition> | <condition> {{ AND | OR } <condition>}[,…n] | <value> <predicate2> | EXISTS ( <select> ) <predicate2> { = | != | < | <= | > | >= } <value> | IS [NOT] NULL | BETWEEN <value> AND <value> | IN ( <select> | <value> [,…n] ) | LIKE <value> | LIKEESCAPE <value> <value> NULL | ( <value> ) | { - | + } <value> | <value> { + | - | * | / | “||” } <value> | <identifierChain> | [<identifierChain>.] <FunktionsName> ( [ <value> [,…n] ] ) | <searchedCaseWhen> | <simpleCaseWhen> | \"[[\" <natives sql fragment> \"]]\" | <stringLiteral> | <integerValue> | <decimalValue> <searchedCaseWhen> CASE {WHEN <condition> THEN <value>}[,…n] [ ELSE <value> ] END <simpleCaseWhen> CASE <value> {WHEN {<predicate2> | <value>} THEN <value>}[,…n] [ ELSE <value> ] END <orderColumn> <value> [ASC | DESC] <identifierChain> <identifier>[.<identifier>][,…n] <identifier> \"[\" <beliebige Zeichenfolge> \"]\" | <Wort, mit einem Buchstaben beginnend>"
  },
  "doc/sql/funktionen.html": {
    "href": "doc/sql/funktionen.html",
    "title": "SQL-Funktionen",
    "keywords": "SQL-Funktionen GETGUID GETGUID ( ) Liefert eine neue Guid mit folgendem Format: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server LOWER( REPLACE ( NEWID ( ), '-', '' ) ) Oracle LOWER( SYS_GUID ( ) )"
  },
  "doc/sql/datum-funktionen.html": {
    "href": "doc/sql/datum-funktionen.html",
    "title": "Datums-Funktionen",
    "keywords": "Datums-Funktionen GETDATE GETDATE ( ) Liefert das aktuelle Datum auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETDATE ( ) Oracle SYSDATE GETUTCDATE GETUTCDATE ( ) Liefert die aktuelle Weltzeit (UTC) auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETUTCDATE ( ) Oracle CAST(sys_extract_utc(systimestamp) AS TIMESTAMP) ADD_DAYS ADD_DAYS ( <Date Expression>, <Days> ) Addiert die übergebenen Tage zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( DAY, <Days>, <Date Expression> ) Oracle <Date Expression> + <Days> ADD_MINUTES ADD_MINUTES ( <Date Expression>, <Minutes> ) Addiert die übergebenen Minuten zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MINUTE, <Minutes>, <Date Expression> ) Oracle <Date Expression> + ( <Minutes> / 1440 ) ADD_MONTHS ADD_MONTHS ( <Date Expression>, <Months> ) Addiert die übergebenen Monate zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MONTH, <Months>, <Date Expression> ) Oracle ADD_MONTHS ( <Date Expression>, <Months> ) DAYS_BETWEEN DAYS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Tage zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF ( DAY, <Start-Date>, <End-Date> ) Oracle TRUNC ( <End-Date> - <Start-Date> ) MONTHS_BETWEEN MONTHS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Monate zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF (MONTH, <Start-Date>, <End-Date>) Oracle MONTHS_BETWEEN (<End-Date>, <Start-Date>) YEAR YEAR ( <Date Expression> ) Liefert eine 4-stellige Zahl, die dem Jahr des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server YEAR ( <Date Expression> ) Oracle EXTRACT ( YEAR FROM <Date Expression> ) MONTH MONTH ( <Date Expression> ) Liefert eine Zahl, die dem Monat des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server MONTH ( <Date Expression> ) Oracle EXTRACT ( MONTH FROM <Date Expression> ) DAY DAY ( <Date Expression> ) Liefert eine Zahl, die dem Tag (Tag des Monats) des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DAY ( <Date Expression> ) Oracle EXTRACT ( DAY FROM <Date Expression> ) HOUR HOUR ( <Date Expression> ) Liefert eine Zahl, die der Stunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( HOUR, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'HH24' ) ) MINUTE MINUTE ( <Date Expression> ) Liefert eine Zahl, die der Minute des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( MINUTE, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>,'MI' ) ) SECOND SECOND ( <Date Expression> ) Liefert eine Zahl, die der Sekunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( SECOND, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'SS' ) )"
  },
  "doc/sql/cast-funktionen.html": {
    "href": "doc/sql/cast-funktionen.html",
    "title": "Umwandlungsfunktionen",
    "keywords": "Umwandlungsfunktionen CHAR_TO_DATE CHAR_TO_DATE ( <Expression>, <format-Number>) Wandelt eine Zeichen-Kette in ein Datum um. Dabei wird das angegebene Format verwendet. Die Format-Nummer muss als konstante Zahl übergeben werden. Sie kann folgende Werte haben: Number Format YY Format YYYY 1 / 101 MM/DD/YY MM/DD/YYYY 2 / 102 YY/MM/DD YYYY/MM/DD 3 / 103 DD/MM/YY DD/MM/YYYY 4 / 104 DD.MM.YY DD.MM.YYYY 5 / 105 DD-MM-YY DD-MM-YYYY 6 / 106 DD MM YYY DD MM YYYY 7 / 107 Mon DD, YY Mon DD, YYYY 8 / 108 hh:mm:ss (24h) 10 / 110 MM-DD-YY MM-DD-YYYY 11 / 111 YY/MM/DD YYYY/MM/DD 12 / 112 YYMMDD YYYYMMDD 20 / 120 YYYY-MM-DD hh:mm:ss (24h) DATE_TO_CHAR DATE_TO_CHAR ( <date Expression>, <format-Number> ) Wandelt ein Datum in eine Zeichenkette um. Die Format-Nummer arbeitet wie bei der Funktion CHAR_TO_DATE. NUMBER_TO_CHAR NUMBER_TO_CHAR ( <Number Expression>, <Decimals>) Wandelt eine Dezimal-Zahl in einen Text um. Dabei wird die Zahl auf die übergebene Anzahl von Dezimal-Stellen gerundet bzw. abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, <Decimals> ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999.9999' ) ) Die Anzahl der Nachkommastellen ist gleich <Decimals> INT_TO_CHAR INT_TO_CHAR ( <Number Expression>) Wandelt eine Ganzzahl in einen Text um. Bei einer Dezimal-Zahl wird gerundet bzw. es werden die Dezimal-Stellen abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, 0 ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999' ) ) CHAR_TO_DECIMAL CHAR_TO_DECIMAL ( <Expression> ) Wandelt eine Zeichenkette in eine Dezimal-Zahl um. LOB_COMPARABLE LOB_COMPARABLE ( <Expression> ) Wandelt eine Langtext-Spalte so um, dass sie in einer Where-Condition bzw. in einem Order By verwendet werden kann. Das ist notwendig unter Oracle bei Spalten mit dem Typ CLOB und unter SQL-Server bei Spalten mit dem Typ text . Beispiel: SELECT memo FROM Tabelle WHERE LOB_COMPARABLE(memo) != 'text' ORDER BY LOB_COMPARABLE(memo) Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CONVERT ( VARCHAR(max), <Expression> ) Oracle CAST ( <Expression> AS VARCHAR2(4000) ) NLOB_COMPARABLE NLOB_COMPARABLE ( <Expression> ) Wandelt eine Unicode Langtext-Spalte so um, dass sie in einer Where-Condition bzw. in einem Order By verwendet werden kann. Das ist notwendig unter Oracle bei Spalten mit dem Typ NCLOB und unter SQL-Server bei Spalten mit dem Typ ntext . Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CONVERT ( NVARCHAR(max), <Expression> ) Oracle CAST ( <Expression> AS NVARCHAR2(2000) )"
  },
  "doc/package-manager/export.html": {
    "href": "doc/package-manager/export.html",
    "title": "Export einer Package-Version",
    "keywords": "Export einer Package-Version Über den Button kann die im Baum ausgewählte Package-Version in eine Datei exportiert werden. Diese Datei kann anschließend in einem anderen Repository wieder importiert werden. Es wird folgender Dialog angezeigt: Package File hier wird die Datei angegeben, in welche die Package-Version exportiert werden soll. Der Datei-Name wird automatisch mit dem Format <Datum_Package_Version> vorbelegt. Dieser sollte nach Möglichkeit nicht geändert werden. Export Code, Methods and Debug-Information mit dieser Checkbox wird angegeben, ob die Export-Datei den Code und die Debug-Informationen enthalten sollen. Der Code beinhaltet dabei sämtlichen Methoden-Code und auch den vom FrameworkCompiler generierten Code. Bei den Debug-Informationen handelt es sich um die im Debug-Modus kompilierten Assemblies mit ihren PDB-Dateien und den CS-Dateien. Include Base Packages Wenn diese Checkbox gesetzt wird, dann wird ein Bereich eingeblendet, in dem angegeben werden kann, welche Basis-Packages mit in die Export-Datei gepackt werden sollen. Dies funktioniert auch bei importierten Basis-Packages. Im Vergleich zum Export der einzelnen Package-Versionen hat dieses Vorgehen den Vorteil, dass auf jeden Fall der passende Compile-Stand des Basis-Packages verwendet wird – auch wenn das Basis-Package später neu kompiliert wurde und dafür ein aktuellerer FrameworkCompiler-Stand zur Verfügung steht. Wenn die Checkbox gesetzt wird, dann werden automatisch folgende Packages ausgewählt: Export unsealed Base Packages Damit werden alle Package-Versionen ausgewählt, die nicht versiegelt wurden. Diese Option ist z.B. beim Einsatz von noch offenen Vorab-Versionen sinnvoll. Export Service Releases Damit werden alle Service-Releases ausgewählt. Dies bedingt aber, dass im Ziel-Repository bereits ein aktueller Stand des Basis-Packages importiert wurde. Bei Bedarf können auch gezielt weitere Packages ausgewählt werden. Bei Package-Versionen, die sich im Service-Release-Modus befinden kann mit der Checkbox Export Full Package statt dem Service-Release-Paket die komplette Package-Version eingebunden werden. Beim Package-Import werden automatisch alle in der Export-Datei beinhalteten Packages importiert – die Auswahl kann nur beim Export getroffen werden. Bei Service-Releases erfolgt ein Import nur dann, wenn nicht bereits ein aktuellerer Service-Release-Stand vorhanden ist. Note Ein neues Repository kann mit so einer Export-Datei nicht angelegt werden. Dies ist nur mit dem Export des Default-Packages möglich."
  },
  "doc/print-server/config.html": {
    "href": "doc/print-server/config.html",
    "title": "Konfiguration Print-Server",
    "keywords": "Konfiguration Print-Server Registerkarte Printers Mit dem Link Add new Printer wird ein neuer Drucker angelegt. Es erscheint eine Drucker-Auswahl der auf dem Rechner installierten Drucker. Wählen Sie den gewünschten Drucker aus. Feld ID Hier wird die ID des Druckers angegeben. Diese wird automatisch erzeugt. Dabei handelt es sich um eine eindeutige Guid. Mit dem Link Generate ID kann eine neue ID generiert werden. Note Wird die ID nachträglich geändert, verlieren andere Programme die Zuordnung zu diesem Drucker. Feld Name Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Dieser Name ist frei wählbar und muss nicht mit dem physikalischen Namen des Druckers in Verbindung stehen. Der Name kann auch nachträglich geändert werden, weil die Zuordnung des Druckers über die ID erfolgt. Feld Path Bei Path wird der physikalische Name des Druckers angegeben. Mit dem Link Choose Printer können Sie diesen neu definieren. Mit dem Link Choose Folder kann ein Datei-Ordner ausgewählt werden. In diesen werden dann die Dokumente abgelegt. Dadurch wird der Typ des Druckers zu [Folder] geändert. Im Feld Path wird dann der Datei-Pfad angezeigt. Weitere Informationen dazu finden Sie im Feature Druck in einen Ordner . Feld Paper Source Hier können Sie den Schacht angeben, der zum Druck verwendet werden soll. Paper Source 1st Page(s) Hier können Sie bei Bedarf für die ersten Seiten eine abweichende Papier-Quelle angeben. Standardmäßig zieht diese Einstellung für die erste Seite. Wenn der Drucker z.B. für Duplex-Druck konfiguriert ist, dann kann die Anzahl der Seiten auf 2 gesetzt werden, damit das erste Blatt beidseitig bedruckt wird. Wenn hier ein Wert definiert ist, der von Paper Source abweicht, dann wird der Druck in 2 Schritten ausgeführt. Das kann die Verarbeitungsgeschwindigkeit verringern. Beim Ausdruck von mehreren Kopien wird der Druck in mehreren Schritten durchgeführt, damit die Reihenfolge der Seiten gewährleistet ist: ersten Seiten mit Schacht 1, Folgeseiten mit Schacht 2, ersten Seiten mit Schacht 1, Folgeseiten mit Schacht 2, usw. Wir dem Ausdruck als Start die Seite 2 oder höher übergeben, dann erfolgt der komplette Ausdruck auf dem Standard-Schacht. Note Der Schacht ( Paper Source und Paper Source 1st Page ) wird nur beim Ausdruck mit Crystal Reports berücksichtigt. Checkbox Use Word Mit Use Word können Sie einstellen, dass ein Crystal Report erst in ein Word-Dokument umgewandelt wird und dann auf den Drucker gesendet wird. Das kann bei der Verwendung von Fax-Druckern hilfreich sein, denn Crystal Reports schafft es meist nicht Steuertexte an den Drucker zu senden. Bei der Umwandlung in ein Word-Dokument bleiben diese erhalten und Word kann sie dann an den Drucker schicken. Note Mit Windows Server 2008 ist es nicht möglich, Word in einem Windows Dienst zu steuern. Deshalb muss in diesem Fall der Print-Service als Konsole-Anwendung gestartet werden. Registerkarte Database Connection Geben Sie hier die gewünschte Verbindung zu der Datenbank an, in der die Druckdaten abgelegt werden. Standardmäßig wird dazu das Runtime Repository Ihrer Anwendung verwendet. Bei Query Interval geben Sie den Rhythmus an, mit dem der Print-Service auf der Datenbank nach neuen Druckaufträgen schaut. Die Angabe hat das Format hh:mm:ss.millisekunden - Beispiel: 00:00:01.5000000 sind 1,5 Sekunden. Registerkarte Service Feld Name Dieser Name wird in Framework-Studio-Anwendungen ausgegeben. Feld ID Die eindeutige ID des Print-Service. Bei der Installation können Sie mit dem Link Generate ID eine neue ID erzeugen. Feld URL Die URL können Sie mit dem Link Set Default auf den eigenen Rechnernamen setzen. Dort ist auch z.B. eine IP-Adresse möglich. Es kann auch ein anderer Port als 20002 verwendet werden. Dann müssen auch die Konfigurationen der Clients, die mit dem Service kommunizieren sollen, auf den geänderten Port angepasst werden. Falls Sie auf einem Server mehrere Print-Services installieren, muss jeder Print-Service einen anderen Port erhalten. Feld Private Key , Public Key Für Private Key und Public Key müssen Sie mit dem Link Generate Keypair ein neues Schlüsselpaar generieren. Feld Culture gibt an, mit welchen Ländereinstellungen der Print-Service arbeiten soll. Diese Einstellung zieht beim Verarbeiten von Crystal Reports. Wenn hier nichts angegeben ist, dann ziehen die Standard-Einstellungen des Rechners. Beispiele: de-DE de-CH en-US Feld Log File Hier kann eine Datei angegeben werden, in der detaillierte Informationen protokolliert werden sollen. Das sind dieselben Informationen, die bei Start mit /Console in das Konsolen-Fenster ausgegeben werden. Zusätzlich werden die einzelnen Protokoll-Einträge mit einem Zeit-Stempel versehen. Der Benutzer, mit welchem der Service gestartet wird, muss Schreibrechte für diese Datei besitzen. Checkbox Delete Printjobs after Processing Wenn diese Checkbox gesetzt ist, dann löscht der Printserver die Druckjobs nach der Verarbeitung. Diese Aktion ist Bestandteil der Verarbeitung eines Jobs. Es wird also nur der aktuelle Printjob gelöscht. Der Druckjob muss die folgenden Bedingungen erfüllen: Es wurden keine PDF-Dateien für die Archivierung generiert (in diesem Fall kümmert sich eNVenta ERP im Archiv-Pool um das Löschen). Der Druckjob war erfolgreich (Status = 3). Das Löschen wird in das detaillierte Protokoll ausgegeben. Nach einem Update muss der Schalter explizit gesetzt werden. Feld Export Folder Wenn definiert, dann werden alle Druck-Jobs, die über den Print-Service verarbeitet werden, zusätzlich in diesen Ordner gespeichert. Dies kann bei der Analyse von Problemen helfen. Feld Trace Folder Wenn angegeben, dann werden in diesen Ordner Trace-Informationen des Print-Servers gespeichert. Diese Dateien können mit dem Session Trace Analyzer gelesen werden. Registerkarte Windows-Service Hier können nur Änderungen vorgenommen werden, solange der Service nicht installiert worden ist. Warning Ändern Sie diese Einstellungen auch niemals manuell in der Datei PrintService.exe.config . Ansonsten kann der Print-Service dem Windows-Dienst nicht mehr zugeordnet werden. Wenn Sie diese Einstellung nachträglich ändern möchten, dann müssen Sie: den Dienst mit dem Link stop beenden, den Dienst mit dem Link uninstall Service deinstallieren, die Änderungen vornehmen und speichern und den Dienst mit dem Link install Service wieder installieren. Dabei sollte der Benutzer-Account des Dienstes wieder der von vorher sein – ggf. vor der ganzen Aktion merken. Siehe auch Installation . Feld Service Name Unter diesem Namen wird der Service in den Windows-Diensten registriert. In dem Feld können Sie einen Namenszusatz angeben. Das ist vor allem dann notwendig, wenn Sie mehrere Print-Services auf einem Rechner installieren, da der Name in den Windows-Diensten eindeutig sein muss. Feld Description Diese wird als Description in den Windows-Diensten gespeichert. Registerkarte Print Adapter Hier können die vom Print-Service unterstützen Print-Adapter aktiviert und konfiguriert werden. Details dazu sind auf der Seite Print-Adapter ausgeführt. Registerkarte Runtime Supervisor Hier kann angegeben werden, an welchem Runtime Supervisor sich der Print-Service registrieren soll. Nähere Informationen dazu sind in der Dokumentation des Runtime Supervisor zu finden. Checkbox Enable Diese Checkbox muss gesetzt werden, damit der Runtime Supervisor aktiviert wird. Feld Runtime Supervisor Url Hier können der Server und der Port angeben werden. Die vollständige URL wird automatisch aufgebaut. Mit dem Button Test kann versucht werden, ob eine Verbindung zum Runtime Supervisor aufgebaut werden kann."
  },
  "doc/package-manager/sprachen.html": {
    "href": "doc/package-manager/sprachen.html",
    "title": "Sprachen",
    "keywords": "Sprachen In der Baumstruktur des Package Managers wird unterhalb jedes Default-Packages ein Ordner Languages angezeigt. In diesem Ordner werden alle Sprachen mit dem Symbol dargestellt, die von den Anwendungen angeboten werden können, die dieses Package als Default-Package verwenden. Durch einen Doppelklick auf eine Sprache wird ein Fenster geöffnet, in dem die beiden folgenden Eigenschaften festgelegt werden können: ISO Sprachkürzel nach ISO-Norm 639-1 Language Bezeichnung der Sprache Eine neue Sprache für ein Default-Package kann über das Kontextmenü der Baumstruktur oder das Symbol New / Language aus der Toolbar angelegt werden."
  },
  "doc/mlkey/import-export.html": {
    "href": "doc/mlkey/import-export.html",
    "title": "MLKey Import / Export",
    "keywords": "MLKey Import / Export"
  },
  "doc/mlkey/enventa-regeln.html": {
    "href": "doc/mlkey/enventa-regeln.html",
    "title": "eNVenta Regeln für MLKeys",
    "keywords": "eNVenta Regeln für MLKeys Allgemeine Regeln Texte aus den Test-Namespaces : Diese sollen nicht ins Wörterbuch aufgenommen werden. Unübersetzbare Texte : Texte, die nicht übersetzt werden können wie z.B. Eigennamen, müssen mit dem Kommentar untranslatable versehen werden. Sind weitere Hinweise im Kommentar nötig, beginnt der Kommentar mit untranslatable gefolgt von einem Zeilenumbruch. Der Text soll in diesem Fall nur in der deutschen Sprache angegeben werden. Abkürzungen im Namen eines MLKeys : Werden im Namen eines MLKeys bewusst Großbuchstaben als Abkürzungen für Teilworte verwendet, weil z.B. der Name sonst zu lang würde, so muss die Abkürzung nach folgendem Schema im Comment erläutert werden: {Abkürzung1} = {Begriff1}, {Abkürzung2} = {Begriff2} Beispiele: LBL_CCServicePort : Comment = CC = Cross Company LBL_CCNameDebit : Comment = CC = Cost Center Bezeichnung von MLKeys Normalfall Begriffe: LBL_{englische Bezeichnung} Beispiel: LBL_Search Sätze: MSG_{GUID} Beispiel: MSG_f39ceca46b3341ee8b9862d34cfd06b6 Einheiten LBL_{englische Bezeichnung}_Unit Beispiel: LBL _mm_Unit Zeichen LBL_{englische Bezeichnung}_Sign Beispiel: LBL_Plus_Sign für den Text „+“ Ziffern LBL_{englische Bezeichnung}_Digit oder LBL_{englische Bezeichnung}_Digits (Plural) Beispiele: LBL_Nine_Digit für den Text „9“, LBL_EightOClock_Digits für den Text „08:00“ Prozentzeichen LBL_{englischer Prefix}Percent (kein Unterstrich) Beispiel: LBL_DiscountPercent (de = „Skonto %“, en = „Discount %“) Abkürzungen / Ausgeschriebene Texte Wenn für einen englischen Begriff im deutschen am häufigsten eine abgekürzte Schreibweise verwendet wird, so wird der MLKey für den Text mit Abkürzung normal mit LBL_{englische Bezeichnung} benannt. Wird parallel dazu auch der im deutschen (oder anderen Fremdsprachen) ausgeschriebene Text benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Full benannt. Wird zu einem Begriff, zu dem es schon eine ausgeschriebene Schreibweise gibt eine Abkürzung benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Abbrev bezeichnet. Beispiele: LBL_ClerkScanner (de = „SB-Scanner“), LBL_ClerkScanner_Full (de = „Sachbearbeiter Scanner“) LBL_Reminder (de = „Wiedervorlage“), LBL_Reminder_Abbrev (de = „Wiedervorl.“) Spezialfall: Ein Buchstabe als Abkürzung LBL_{englische Bezeichnung}_Char Beispiele: LBL_Order_Char (de = „B“, en= „O“) LBL_Container_Char (de = „B“, en = „C“) Beschriftung von Mini-Buttons LBL_{englische Bezeichnung}_Mini Wird ein MiniButton (Control Style = MiniEmpty) auf einer Maske mit einer Caption von 1 bis 2 Buchstaben versehen (die typischerweise eine Abkürzung darstellen), so wird der MLKey dazu mit der eigentlichen Bezeichnung, ergänzt um _Mini beschriftet. Dabei ist darauf zu achten, dass die Beschriftungen pro Sprache eindeutig sind. Beispiele: LBL_Customer_Mini (de = „K“, en = „Cu“) LBL_CrossOver_Mini (de = „C“, en = „Cr“) Zwei unterschiedliche deutsche Begriffe, die im Englischen gleich heißen Wenn zwei unterschiedliche Begriffe im englischen durch den gleichen Text beschrieben werden, so werden die Bezeichnungen der MLKeys durch Anhängen eines Zählers beginnend mit 1 im Format _{Zähler} unterschieden. Beispiel: de = „Herkunft“, en = „Source“ => MLKey = LBL_Source de = „Quelle“, en = „Source“ => MLKey = LBL_Source_1 Tooltips Wenn ein Tooltip eindeutig einem einfachen Begriff zugeordnet werden kann, so wird der MLKey mit TTT_{englische Bezeichnung} benannt. Andernfalls wird das Format TTT_{GUID} verwendet. Beispiele: TTT_Fatal (de = „Fatale Einträge anzeigen“) `TTT_584b58008ed04cd2b40b78b70e52402c' (de = „Wert für die Kreditorenvorerfassung-Pufferzeit definieren.“) Note Wenn man einen Tooltip verwenden möchte, zu dem es bereits einen exakt passenden LBL_ Eintrag gibt, so soll dazu kein TTT_ Eintrag angelegt werden! Diese Einträge wären sonst ja logisch äquivalent. Kleingeschriebene Begriffe Sollte man ein Text (z.B. wegen einer Verwendung in einer Textcollection) berechtigterweise klein geschrieben sein und es soll trotzdem ein sprechender Key generiert werden, so ist dieser ebenfalls klein zu schreiben. Beispiel: de = „eins“, en = „one“ => MLKey = LBL_one Texte Alle Texte in allen Sprachen beginnen mit einem großen Buchstaben. Ausnahmen: Abgekürzte Einheiten (z.B. mm) Einträge in Textcollections, soweit diese zwingend alle klein geschrieben werden müssen. Vor Satzzeichen werden keine Leerzeichen verwendet. Ganze Sätze werden mit einem Satzzeichen beendet. Im Englischen werden bei Texten mit bis ca. 4 Worte (Beschriftungen von Eingabefeldern, Menüs, Buttons usw.) alle Worte bis auf Füllwörter wie of , to , in , ... groß geschrieben."
  },
  "doc/mlkey/draft.html": {
    "href": "doc/mlkey/draft.html",
    "title": "Text-Collections",
    "keywords": "Text-Collections Text-Collections arbeiten ebenfalls mit MLKeys. Im Grunde sind sie eine Auflistung von MLKeys. Arbeitsweise Das Wörterbuch wird in xml-Dateien gespeichert. Diese liegen im Broker-Verzeichnis im Ordner lang . Die Dateien werden separat prop Package und Sprache mit dem folgenden Datei-Namen abgelegt: <package>.<iso>.lang.xml Beispiel: <broker-directory> |--lang | |--CustomPackage.de.lang.xml | |--eNVenta.de.lang.xml | |--eNVenta.en.lang.xml | |--eNVenta.fr.lang.xml | |--SystemPackage.de.lang.xml | |--SystemPackage.en.lang.xml Zur Laufzeit werden diese Dateien bei Bedarf einmalig für die benötigten Sprachen eingelesen. Dabei wird die Package-Hierarchie berücksichtigt."
  },
  "doc/mdt/vererbung.html": {
    "href": "doc/mdt/vererbung.html",
    "title": "Vererbung von Metadatentypen",
    "keywords": "Vererbung von Metadatentypen Es ist möglich, Metadatentypen zu vererben. Das macht dann Sinn, wenn Metadatentypen aufeinander aufbauen und z.B. ein gemeinsames Format-Pattern verwenden. Sie können so in einem Basis-Metadatentyp mit allen Datentypen Controls und einem Default-Label definieren. Anschließend brauchen Sie diesen nur abzuleiten und die Ableitung hat die gleichen Eigenschaften wie die Basis. Dann können Sie noch z.B. das Label oder den Wertebereich ändern. In der Ableitung werden die nachträglich geänderten Werte fettgedruckt dargestellt. Eine Ableitung können Sie auf zwei Wegen erstellen: Einen Metadatentypen ableiten, indem Sie den Metadatentyp im Overview auswählen, den Button ( Derive ) drücken und in der Namespace-Auswahl angeben, in welchem Namespace die Ableitung angelegt werden soll. Einem vorhandenen Metadatentypen im Feld Base eine Basis (oder auch eine andere Basis) zuweisen. Warning Wird beim Ändern der Basis auch der Datentyp geändert, kann das evtl. Auswirkungen auf die Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren."
  },
  "doc/ide/window-menu.html": {
    "href": "doc/ide/window-menu.html",
    "title": "Window Menü",
    "keywords": "Window Menü Beim Verlassen von Framework Studio wird das aktuelle Layout automatisch abgespeichert. Es wird beim nächsten Start wieder ausgelesen. Das betrifft die Anordnung, Größe und Position der dockbaren Fenster. Menüpunkt Reset Window Layout: Setzt das Layout auf den Standard zurück. Menüpunkt Save Window Layout to file: Man kann das Layout also die Anordnung, Größe und Position der dockbaren Fenster in eine Datei speichern. Das ist sehr praktisch, wenn man z.B. auch über eine Remote-Verbindung auf seinem Rechner arbeitet. So kann man für die entsprechende Situation sein eigenes Layout erzeugen. Es wird eine Datei mit der Endung *.FS30Layout.xml erzeugt. Diese Dateien können nur mit der passenden Version von Framework Studio verwendet werden. Menüpunkt Load Window Layout from file: Lädt eine Layout-Datei und passt das Layout entsprechend an. Es können nur Layout-Dateien verwendet werden, die zu dieser Version von Framework Studio passen. Andere Dateien können dazu führen, dass einige Fenster falsch oder auch gar nicht angezeigt werden. Menüpunkt Close All Documents: Schließt alle offenen Elemente."
  },
  "doc/ide/view-menu.html": {
    "href": "doc/ide/view-menu.html",
    "title": "View Menü",
    "keywords": "View Menü Track Active Item Ist der Menüeintrag Track Active Item mit einem Häkchen versehen, so wird auf der Registerkarte Namespaces automatisch der Namespace ausgewählt, in dem das aktuell fokussierte Element im Framework Designer (z.B. ein Form oder eine Component) angelegt ist. Ist der Menüeintrag nicht mit einem Häkchen versehen, ist dieser Automatismus abgeschaltet. Stattdessen wird in den Designer Fenstern ein zusätzlicher Button (Track Item) angeboten, mit dem auf der Registerkarte Namespaces in den Namespace des Elements gewechselt werden kann."
  },
  "doc/form/default-control-styles.html": {
    "href": "doc/form/default-control-styles.html",
    "title": "Default Control Styles",
    "keywords": "Default Control Styles Default Control Styles sind Standardvorlagen für alle verfügbaren Controls. Durch diese Vorlagen können für alle Eigenschaften der Controls Standardwerte vorbelegt werden. Default Control Styles werden auf der Registerkarte Namespaces im Namespace FSGeneral / Controls angezeigt. Wenn Sie ein Default Control Style auf einem Form verwenden wollen, ziehen Sie das Control von der Registerkarte Toolbox des Framework-Designers auf die Registerkarte DefaultVariant des geöffneten Form-Designers (siehe dazu [ Design des Forms ](!TODO LINK)). Um Eigenschaften eines Default Control Styles zu ändern, öffnen Sie den Control Style Designer durch Doppelklick auf das Default Control Style im Objektbaum auf der Registerkarte Namespaces. Auf der Registerkarte Default Control Style werden in einem Property Grid alle Eigenschaften des Controls angezeigt. Eine komplette Liste der Eigenschaften der einzelnen Default Control Styles finden Sie unter Layout-Konzept . Wenn Eigenschaften an einem Default Control Style statt an der Instanz eines Controls auf einem Form festgelegt werden, hat das den Vorteil, dass diese Eigenschaften einheitlich in der gesamten Anwendung verwendet werden. Wenn dann nachträglich eine Eigenschaft (z.B. Hintergrundfarbe) an einem Default Control Style geändert wird, zieht diese Änderung automatisch an allen Stellen, an denen der Default Control Style benutzt wird und die Eigenschaft nicht explizit überschrieben wird. Custom Control Default Style Editor: Sie haben die Möglichkeit, eigene Default Control Styles zu definieren. Dazu müssen Sie eine Ableitung von einem der Basis Default Control Styles erstellen (Kontextmenü Derive im Objektbaum auf der Registerkarte Namespaces ). Für das so erstellte Default Control Style können Sie die Eigenschaften frei definieren, ohne das Original Default Control Style zu ändern. Dadurch erhalten Sie eine weitere Control-Vorlage, die Sie in Ihren Forms verwenden können. Basis Default Control Styles sind Button, Checkbox, Combobox, Editfield, Grid, ImageButton, Label, Line, Listbox, MainMenu, Panel, Picture, RadioButton, TabbedWindow, TrafficLight und TreeView."
  },
  "doc/documentation/vererbung.html": {
    "href": "doc/documentation/vererbung.html",
    "title": "Vererbung",
    "keywords": "Vererbung Ähnlich wie bei den Tooltips für Steuerelemente bietet auch die Dokumentation eine Vererbung bis auf Metadatentyp-Ebene an. Diese Vererbung soll dazu beitragen, Dokumentationen für Steuerelemente mit derselben Funktion nicht mehrmals verfassen oder kopieren zu müssen. Vererbung einer Dokumentation: Die Abbildung zeigt die Möglichkeit der Vererbung vom Steuerelement auf dem Form bis zum Metadatentyp ggf. auch über mehrere Packages hinweg, gesetzt den Fall, dass dem jeweiligen Steuerelement eine DataSource zugewiesen wurde. Eingebunden werden kann eine Dokumentation aus einem darunter liegenden Element mit Hilfe des base-Tags (siehe Base ). Vererbung in einem einzigen Package Im folgenden Beispiel wird gezeigt, wie mit Hilfe der Vererbung in der Dokumentation des Textfelds T die Dokumentationen aus dessen Component Properties (DataSource), der dazu gehörigen DBColumn und des wiederum damit verbundenen Metadatentyps eingebunden werden kann. Betrachtet wird das Szenario eines einzelnen Packages P1 (blaue Pfeile). Die Dokumentation des Metadatentyps M sieht wie folgt aus: Die Dokumentation der DBColumn D bindet mit Hilfe des base-Tags die Dokumentation des Metadatentyps ein. Beim Rendern wird an die Stelle des base-Tags somit die Dokumentation des Metadatentyps eingebunden: Am Component Property C ist dasselbe Verhalten zu erkennen: Letztlich bindet auch das Textfeld T die Basis-Dokumentation ein, was folgende Ausgabe ergibt: An der Dokumentation des Controls ist nun zu erkennen, dass die Information über das Drücken der F2 -Taste am Control auf dem Formular dokumentiert wurde. Dies könnte auf einem anderen Formular z.B. ein anderer Shortcut sein. Die restliche Dokumentation inklusive des rot markierten Beispiels würde aber automatisch übernommen werden. Diese Art der Vererbung ist also immer dann sinnvoll, wenn auf unterschiedlichen Formularen in der Anwendung Steuerelemente existieren, die genau dieselben DataSources verwenden. Beispiel In einer Anwendung gibt es auf 6 verschiedenen Formularen immer wieder ein Textfeld, welches eine Auftragsnummer anzeigt. Die Funktion des Textfeldes ist auf jedem Form dieselbe und beinhaltet auch immer die Daten desselben Component Properties (die Textfelder haben immer die gleiche DataSource), baut somit immer auf derselben DBColumn auf und ist damit auch vom selben Metadatentyp abhängig. Es wäre nun sehr umständlich, jedes Mal am Steuerelement selbst dieselbe Dokumentation zu hinterlegen. Sollte sich diese ändern, müssten alle 6 Stellen angepasst und erneut auf Fehler überprüft werden. Um dies zu vermeiden, kann die Vererbung genutzt werden. Da die 6 Textfelder immer auf demselben Component Property aufsetzen, kann die gesamte Dokumentation an diesem verfasst werden. Der große Vorteil dieses Vorgehens ist, wenn sich an der Dokumentation etwas ändert, muss nur die Dokumentation des Component Properties angepasst werden und beim nächsten Rendern haben alle abhängigen Textfelder die aktualisierte Dokumentation des Component Properties übernommen. Insgesamt gilt also: Die Dokumentation sollte so tief wie möglich im Framework Studio verfasst und auf möglichst viele Elemente vererbt werden. Entstehen in der Datasource Hierarchy an einer Stelle Lücken in der Dokumentation, wird die Dokumentation aus der nächst tieferen Ebene eingebunden. Befindet sich z.B. in der Dokumentation eines Textfelds T ein base-Tag, wird beim Rendern die Dokumentation aus dem Component Property verwendet. Ist jedoch keine Dokumentation an selbigem verfasst, wird automatisch in der tieferen Ebene nach einer Dokumentation geprüft. In diesem Fall würde die Dokumentation der DBColumn verwendet werden. Ist an selbiger auch keine Dokumentation verfasst, wird die des Metadatentyps eingebunden. Beispiel Eine leere Dokumentation verhält sich wie ein base-Tag: An einem Textfeld ist nicht explizit eine Dokumentation hinterlegt. Das per DataSource zugewiesene Component Property beinhaltet jedoch eine Dokumentation. Wie zu sehen ist, wird automatisch die Dokumentation des Component Properties für das Textfeld gerendert, wenn die Preview angezeigt wird. Eine nicht vohandene Dokumentation in einem Control, einem Property, einer DBColumn oder einem Metadatentyp verhält sich also genauso wie ein base-Tag ohne weiteres DocML. base-Tag ohne weiteres DocML: Das gezeigte base-Tag kann also entfernt werden, da sich die leere Dokumentation äquivalent verhält. Vererbung bei mehreren Packages Liegen mehrere Packages übereinander (grüne und orangene Pfeile), wird immer erst die höchste Customization des jeweiligen Elements betrachtet. Vererbung über mehrere Packages hinweg: Beispiel (grüne Pfeile): Wird die Dokumentation für die Customization vom Textfeld T im Package P2 gerendert, wird für ein base-Tag in P1 nach einer Dokumentation gesucht. Wird dort nichts gefunden oder erfolgt dort ein weiterer Base-Aufruf, wird an der Customization des Component Properties C in P2 gesucht usw."
  },
  "doc/documentation/docml.html": {
    "href": "doc/documentation/docml.html",
    "title": "DocML",
    "keywords": "DocML Bei einer Dokumentation in Textform bedarf es grundsätzlich der Möglichkeit, den Text zu formatieren und zu strukturieren. Für diesen Zweck bedient sich Framework Studio der eigens entwickelten Dokumentationssprache DocML . Ein Vorteil dieser Sprache ist, dass sie in beliebige andere Formate konvertiert werden kann. So ist die Vorschau einer Dokumentation in Framework Studio z.B. in Form von HTML realisiert. Es besteht aber auch die Möglichkeit, die gesamte Dokumentation als Worddatei zu exportieren. Um einen ersten Eindruck der Sprache zu bekommen folgt ein kurzer Auszug einer Dokumentation eines Formulars: Und hier die Ausgabe im Preview-Fenster in Framework Studio (HTML): Aufbau der Sprache Die Sprache DocML besteht weitestgehend aus dem Text, welcher die Dokumentation widerspiegelt sowie Tags, die mit Attributen versehen sein können, um den beinhaltenden Text zu formatieren oder zu strukturieren. Tags Ein Tag definiert sich durch eine öffnende eckige Klammer [ , einem Bezeichner (um welches Tag es sich handelt), gefolgt von einer schließenden eckigen Klammer ] : [ + Bezeichner + ] Beispiele: [b] , [tbl] , [f] , [ac] Dabei wird zwischen öffnenden und schließenden Tags unterschieden. Das schließende Tag beinhaltet nach der öffnenden Klammer einen Schrägstrich / : [/ + Bezeichner + ] Beispiele: [/b] , [/tbl] , [/f] , [/ac] Angewendet wird ein Tag immer auf den Text, der zwischen dem öffnenden und schließenden Tag steht: [b] Dies ist ein fett gedruckter Text [/b] Tags können ineinander geschachtelt werden um mehrere Formatierungen auf einen Textabschnitt vorzunehmen: [b][i] Dies ist ein fett gedruckter und kursiver Text [/i][/b] Es ist zu beachten, dass öffnende Tags genau in der umgekehrten Reihenfolge geschlossen werden müssen. Folgende Beispiele sind korrekt: [b][i] Ein Text [/i][/b] [i][b] Ein Text [/b][/i] [b][i][u] Ein Text [/u][/i][/b] Folgende Beispiele sind nicht korrekt: [b][i] Ein Text [/b][/i] [i][b] Ein Text [/i][/b] [b][i][u] Ein Text [/b][/u][/i] Eine komplette Auflistung aller verfügbaren Tags in DocML und deren Funktion findet sich im Kapitel Tag Reference . Leere Tags Eine besondere Untergruppe der Tags bilden die leeren Tags. Dies sind öffnende und schließende Tags in einem. Leere Tags können keinen Text oder andere Tags beinhalten. Leere Tags definieren sich durch eine öffnende eckige Klammer [ , den Bezeichner, einen Schrägstrich / und die schließende eckige Klammer ] : [ + Bezeichner + / + ] Beispiele: [screenshot/] , [img/] , [br/] Diese leeren Tags dienen z.B. dem Einfügen eines Bildes oder Zeilenumbruch in die Dokumentation. Tag-Attribute Die meisten Tags können in ihrem Verhalten durch Attribute gesteuert werden. Ein Attribut definiert sich durch einen Bezeichner gefolgt, von einem Gleichheitszeichen = sowie dem Attributwert in Hochkommas. Attribute können in öffnenden und leeren Tags vorkommen: In öffnendem Tag: [f bg=\"ff0000\" ] Text mit roter Hintergrundfarbe [/f] In leerem Tag: [screenshot caption=\"Auftragserfassung\" /] Im Kapitel Tag Reference ist ausführlich beschrieben, welcher Tag mit welchen Attributen gesteuert werden kann. Tag Reference Nachfolgend werden alle verfügbaren Tags und die zugehörigen Attribute der DocML -Sprache beschrieben. Die Tags unterscheiden sich in zwei Klassen, Inline-Tags und Block-Tags . Inline-Tags werden meist für Formatierungszwecke genutzt wie z.B. Fettschrift oder Textfarbe, während Block-Tags Strukturen wie Tabellen, Listen oder Abschnitte definieren. Warning Grundsätzlich gilt: Inline-Tags können keine Block-Tags beinhalten Inline-Tags Font Eigenschaften: Bezeichner: [f] Leeres Tag: nein Funktion: Wendet Schriftart, Schriftgröße, Schriftfarbe und Hintergrundfarbe auf den beinhaltenden Text an Attributes: Bez. Benötigt Mögliche Werte Funktion style nein Normal, Code Stellt die Schriftart zwischen Arial und einer Code-Schriftart um size nein XXXL, XXL, XL, L, Normal, S, XS, XXS oder XXXS Schriftgröße fc nein Systemfarben wie red , black , blue oder Farbangaben in HEX wie z.B. #FF00000 Textfarbe bc nein Systemfarben wie red , black , blue oder Farbangaben in HEX wie z.B. #FF00000 Hintergrundfarbe Beispiel: [f style=\"code\" size=\"xl\" fc=\"red\" bc=\"#00ff00\"]Möglichkeiten des Font-Tags[/f] Bold Eigenschaften: Bezeichner: [b] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als fett geschrieben Attributes: Keine Beispiel: [b]Dieser Text ist fett geschrieben[/b] Italic Eigenschaften: Bezeichner: [i] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als kursiv geschrieben Attributes: Keine Beispiel: [i]Dieser Text ist kursiv geschrieben[/i] Underline Eigenschaften: Bezeichner: [u] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als unterstrichen Attributes: Keine Beispiel: [u]Dieser Text ist unterstrichen[/u] Strikethrough Eigenschaften: Bezeichner: [s] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als durchstrichen Attributes: Keine Beispiel: [s]Dieser Text ist durchstrichen[/s] Subscript Eigenschaften: Bezeichner: [sub] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als tiefgestellt Attributes: Keine Beispiel: [sub]Dieser Text ist tiefgestellt[/sub] Superscript Eigenschaften: Bezeichner: [sup] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als hochgestellt Attributes: Keine Beispiel: [sup]Dieser Text ist hochgestellt[/sup] Align Left Eigenschaften: Bezeichner: [al] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als linksbündig Attributes: Keine Beispiel: [al]Dieser Text ist linksbündig[/al] Center Eigenschaften: Bezeichner: [ac] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als zentriert Attributes: Keine Beispiel: [ac]Dieser Text ist zentriert[/ac] Align Right Eigenschaften: Bezeichner: [ar] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als rechtsbündig Attributes: Keine Beispiel: [ar]Dieser Text ist rechtsbündig[/ar] Justify Eigenschaften: Bezeichner: [aj] Leeres Tag: nein Funktion: Markiert den beinhaltenden Text als Blocksatz Attributes: Keine Beispiel: [aj]Dieser Text ist im Blocksatz geschrieben[/aj] Image Eigenschaften: Bezeichner: [img] Leeres Tag: ja Funktion: Bindet eine Bildressource aus Framework Studio in die Dokumentation ein Besonderheiten: Wird nur das width- oder height-Attribut angegeben, wird das Seitenverhältnis des Bildes beibehalten. Werden keine Größenangaben gemacht, wird die Größe des Quellbildes verwendet. Eine Bildbezeichnung (caption-Attribut) kann nur definiert werden, wenn das inline-Attribut nicht definiert ist oder den Wert false hat. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja ID einer Framework Studio Bildressource Verweist auf das Bild, welches in der Framework Studio Resource eingebunden ist width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) height nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Höhe des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. height=“4.7in“) caption nein Text Bildbezeichnung inline nein true , false Wenn true wird das Bild wird ein Textzeichen im Textfluss behandelt, sonst wird eine neue Zeile eingefügt Beispiel: [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" height=\"1.5cm\" inline=\"true\"/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" caption=“Beispielbild“/] [img src=\"6600e9ad6c3d4ce4ab4c51b7d2a36844\" width=“3cm“ height=\"1.5cm\" caption=“Test“/] Screenshot Eigenschaften: Bezeichner: [screenshot] Leeres Tag: ja Funktion: Bindet einen automatisch generierten Screenshot des Forms als Bild in die Dokumentation ein. Besonderheiten: Kann nur in Form-Dokumentationen verwendet werden. Werden keine Größenangaben gemacht, wird die Größe des Forms verwendet. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein z.B. „2.3cm“, „3.3in“, „14,34cm“ Breite des angezeigten Bildes. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“) caption nein Text Bezeichnung des Screenshots Beispiel: [screenshot/] [screenshot width=\"17cm\"/] [screenshot width=\"14.3in\" caption=\"Kostenrechnung\"/] caption=\"Test\"/] Link Eigenschaften: Bezeichner: [lnk] Leeres Tag: ja Funktion: Erstellt einen Querverweis auf ein anderes Kapitel oder einen Hyperlink auf eine Url. Attributes: Bez. Benötigt Mögliche Werte Funktion src ja • ID eines Forms oder Documentation-Elements • Url mit führendem http:// Querverweis in der fertigen Dokumentation oder Hyperlink auf die angegebene Url text ja Text Der angezeigte Text des Links Beispiel: [lnk src=\"f037492b790d24c5b9f16cb4120465e25\" text=\"Artikeldetails\"/] [lnk src=\"http://www.google.de/\" text=\"Suchen mit Google\"/] Index Entry Eigenschaften: Bezeichner: [idx] Leeres Tag: ja Funktion: Erstellt einen Eintrag im Index der Dokumentation. Attributes: Bez. Benötigt Mögliche Werte Funktion entry ja text Definiert einen Haupteintrag im Index subentry nein Text Definiert einen Untereintrag unter dem Haupteintrag Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Base Eigenschaften: Bezeichner: [base] Leeres Tag: ja Funktion: Bindet die Basis-Dokumentation eines Controls, Component Properties, einer DBColumn oder eines Metadatentyps ein. Besonderheiten: Wird nur an Control, Component Property, DBColumn und Metadatentyp unterstützt. Mehr Information in den Kapiteln Vererbung und Customizing . Attributes: Keine Beispiel: [idx entry=\"Haupteintrag\"/] [idx entry=\"Haupteintrag\" subentry=\"Untereintrag\"/] Line Eigenschaften: Bezeichner: [line] Leeres Tag: ja Funktion: Erstellt eine Line als Absatztrenner über die komplette Seitenbreite. Attributes: Keine Beispiel: [line/] Break Eigenschaften: Bezeichner: [br] Leeres Tag: ja Funktion: Erstellt einen Zeilenumbruch. Attributes: Keine Beispiel: [br/] Block-Tags Section Eigenschaften: Bezeichner: [section] Leeres Tag: optional Funktion: Definiert einen Textabschnitt in einer Form-Dokumentation oder einem Documentation-Element, der durch die angegebene ID customizing-fähig ist. Siehe Customizing . Besonderheiten: Kann sich nur auf oberster Ebene und somit nicht in anderen Tags befinden. Wird nur in Form- und Documentation-Elementen unterstützt. Attributes: Bez. Benötigt Mögliche Werte Funktion id ja 32-stellige GUID Eindeutige ID des Textabschnitts customize Im Custom-Package before, after, override Überschreibungsart der gecustomizten Section Beispiel: [section id=“ f0bcfd1621444f6f9f24bc9305120809“/] [section id=“ f0bcfd1621444f6f9f24bc9305120809“ customize=“after“/] List Eigenschaften: Bezeichner: [lst] Leeres Tag: nein Funktion: Erstellt eine geordnete oder ungeordnete Liste von ListItems (li-Tags). Besonderheiten: Kann nur li-Tags beinhalten. Das Symbol kann nur definiert werden, wenn das type-Attribut als „unordered“ definiert ist. Attributes: Bez. Benötigt Mögliche Werte Funktion type ja ordered, unordered Definiert den Listentyp symbol nein disk, circle, square Definiert das Listensymbol bei ungeordneten Listen Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] [lst type=\"ordered\"] [li]ListItem 1[/li] [li]ListItem 2[/li] [li]ListItem 3[/li] [/lst] ListItem Eigenschaften: Bezeichner: [li] Leeres Tag: nein Funktion: Erstellt einen Eintrag in einer Liste. Besonderheiten: Kann nur innerhalb von lst-Tags verwendet werden. Attributes: Keine Beispiel: [lst type=\"unordered\" symbol=\"square\"] [li]Ein ListItem[/li] [li]Noch ein ListItem[/li] [/lst] Table Eigenschaften: Bezeichner: [tbl] Leeres Tag: nein Funktion: Erstellt eine Tabelle. Besonderheiten: Die Breite der Tabelle kann absolut als auch prozentual angegeben werden. Wird keine Breite angegeben, definiert sich die Tabellenbreite über die Summe der Spaltenbreiten. Ist die Tabellenbreite in Prozent angegeben, müssen auch die Spaltenbreiten in Prozent angegeben werden. Ist keine Tabellenbreite angegeben, müssen die Spaltenbreiten in absoluten Werten angegeben werden. Eine Tabelle muss eine Spaltendefinition (coldef-Tag) inkl. Spalten (col-Tags) sowie mindestens eine Zeile (row-Tag) beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. Beispiel: Ausgabe: Column Definition Eigenschaften: Bezeichner: [coldef] Leeres Tag: nein Funktion: Beinhaltet die Spaltendefinition einer Tabelle. Besonderheiten: Muss ein oder mehrere Spalten (col-Tags) beinhalten. Kann nur innerhalb eines tbl-Tags vorkommen. Kann innerhalb eines tbl-Tags nur einmal vorkommen. Kann nur col-Tags beinhalten. Muss innerhalb des tbl-Tags als erstes auftreten (vor jeglichen Zeilendefinitionen bzw. row-Tags). Attributes: Keine Beispiel: [coldef] [col width=\"50%\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] [/coldef] Column Eigenschaften: Bezeichner: [col] Leeres Tag: ja Funktion: Definiert eine Spalte innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines coldef-Tags vorkommen. Die Breite der Spalte kann absolut oder prozentual angegeben werden. Ist die Tabellenbreite (im tbl-Tag) prozentual angegeben, muss die Spaltenbreite ebenfalls prozentual angegeben werden. Ist keine Tabellenbreite (im tbl-Tag) angegeben, muss die Spaltenbreite absolut angegeben werden. Attributes: Bez. Benötigt Mögliche Werte Funktion width nein • Absolute Angaben wie z.B. „2.3cm“, „3.3in“, „14,34cm“ • Prozentuale Angaben wie z.B. „50%“, „75%“ Breite der Tabelle. Kommawerte müssen mit Punkt „.“ angegeben werden (z.B. width=“3.4in“). Die prozentuale Angabe bezieht sich auf die Seitenbreite bzw. die Fensterbreite im HTML fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein left, center, right Horizontale Ausrichtung der Spalte. Kann durch das colalign-Attribut an der Zelle überschrieben werden. Beispiel: [col width=\"4.5cm\"/] [col width=\"50%\" fc=\"#ddee32\" bc=\"#dd3331\" align=\"right\"/] Row Eigenschaften: Bezeichner: [row] Leeres Tag: nein Funktion: Definiert eine Zeile innerhalb einer Tabelle. Besonderheiten: Kann nur innerhalb eines tbl-Tags vorkommen. Muss innerhalb des tbl-Tags unterhalb des coldef-Tags stehen. Kann nur cell-Tags beinhalten. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. align nein top, middle, bottom Vertikale Ausrichtung der Zeile. Kann durch das rowalign-Attribut an der Zelle überschrieben werden. Beispiel: [row fc=“#ddee43“] [cell]Zelle links oben[/cell] [cell rowalign=“top“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row] Cell Eigenschaften: Bezeichner: [cell] Leeres Tag: nein Funktion: Definiert eine Zelle innerhalb einer Zeile. Besonderheiten: Kann nur innerhalb eines row-Tags vorkommen. Muss innerhalb eines row-Tags genauso oft vorkommen wie die Anzahl der Spalten im coldef-Tag der Tabelle. Attributes: Bez. Benötigt Mögliche Werte Funktion fc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Textfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. bc nein Systemfarben wie „red“, „black“, „blue“ oder Farbangaben in HEX wie z.B. „#FF0000“ Hintergrundfarbe für die gesamte Tabelle. Kann durch Spalten, Zeilen oder Zellen überschrieben werden. rowalign nein top, middle, bottom Vertikale Ausrichtung der Zelle. colalign nein left, center, right Horizontale Ausrichtung der Zelle. Beispiel: [row fc=“#ddee43“] [cell fc=“#3434ee“]Zelle links oben[/cell] [cell colalign=“center“]Zelle rechts oben[/cell] [/row] [row fc=\"GreenYellow\" bc=\"Linen\" align=\"bottom\"] [cell]Zelle links unten[/cell] [cell bc=\"black\" colalign=\"left\" rowalign=\"middle\"]Zelle rechts unten[/cell] [/row]"
  },
  "doc/documentation/doc2help.html": {
    "href": "doc/documentation/doc2help.html",
    "title": "Doc2Help",
    "keywords": "Doc2Help Important Da Framework Studio mittlerweile auch selbst in der Lage ist, mittels des HTML-Exports ( HTML ) komplette Online-Hilfen zu generieren, sollte diese Möglichkeit verwendet werden, da Doc2Help Größenbeschränkungen hat, die bei sehr umfangreichen Dokumentationen ggf. zu Fehlern führen können. Doc2Help ist eine Anwendung der Firma ComponentOne , die in der Lage ist, aus Word-Dateien Onlinehilfen in HTML zu generieren. Um normale docx-Dateien jedoch mit Doc2Help verarbeiten zu können, müssen einige Vorkehrungen getroffen werden. Framework Studio bietet die Möglichkeit, mit der Option Doc2Help in den Wizard-Optionen eben diese Vorkehrungen automatisch zu treffen. Um z.B. in einer von Doc2Help generierten Onlinehilfe über einen Url-Parameter ein bestimmtes Kapitel aufzurufen, muss an jede Überschrift in Word eine besondere Formatvorlage eingebunden werden und ein Parameter mit dem Namen asciiname definiert werden. Parameter am Kapitel für Doc2Help: Wird eine Dokumentation über den Export Wizard erstellt und die Option Doc2Help aktiviert ist, sind keine weiteren Anpassungen an der Word-Datei nötig. Die Dokumentation kann in Doc2Help importiert und sofort in eine Onlinehilfe konvertiert werden."
  },
  "doc/documentation/customizing.html": {
    "href": "doc/documentation/customizing.html",
    "title": "Customizing",
    "keywords": "Customizing Sections sind nur in Dokumentationen von Forms und Documentation-Elementen verfügbar und dienen dazu, längere Texte in Abschnitte zu unterteilen, die in Customizations dieser Elemente ausgetauscht oder ergänzt werden können. Beispiel: Eine Dokumentation eines Forms in Package P1 sieht wie folgt aus: Es ist zu sehen, dass der Text in zwei Sections unterteilt ist, die jeweils mit einer einmaligen ID ausgestattet sind. Wird dieses Form nun in einem Package P2 gecustomized und an der Funktion des Forms Änderungen vorgenommen, die danach nicht mehr mit der Dokumentation aus der Basis übereinstimmen, muss die Dokumentation der Customization ebenfalls angepasst werden. Meistens ist es jedoch der Fall, dass nur einzelne Teile oder nur wenige Sätze aus der bisherigen Dokumentation geändert werden müssen, um die Dokumentation zu korrigieren. Im konkreten Beispiel könnte im gecustomizten Form die Möglichkeit geschaffen worden sein, Auftragspositionen auch kopieren zu können. Diese Information sollte nun in die Dokumentation des neuen gecustomizten Forms eingefügt werden. Praktisch wäre natürlich eine Ergänzung nach dem ersten Satz „…editiert oder gelöscht werden.“ . Während in einem einzelnen Package die Sections funktionslos sind, stellen sie beim Customizing von Forms oder Documentation-Elementen einen Einsprungpunkt für zusätzliche Dokumentationen bereit. Um die zusätzliche Information in die Dokumentation einzufügen, muss im gecustomizten Form eine neue Section über den Button in der Werkzeugleiste erstellt werden: Customizing einer Section: Framework Studio erkennt, dass das Form gecustomized wurde und listet in der Combobox Base Section alle in der Basis verfügbaren Section-ID’s auf. Über das Panel Other des Editors kann zur Kontrolle der zu editierenden Section(-ID) die Basis-Dokumentation des Formulars angezeigt werden. Im Dialog für die Section-Auswahl gibt es drei Möglichkeiten, eine Section zu überschreiben: Override Die Section aus der Basis wird durch den neuen Text ersetzt. Before Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars vor dem Text aus der Basis eingefügt. After Der neue Text wird beim Rendern der Dokumentation des gecustomizten Formulars nach dem Text aus der Basis eingefügt. Wird der Dialog geschlossen, wird eine neue Section erstellt, die ein customize -Attribut beinhaltet, in der die ausgewählte Customizing-Methode steht. Die zusätzliche Information (Auftragspositionen können kopiert werden) kann nun eingegeben werden. Wird eine Vorschau der Dokumentation gerendert, erscheint der neue Text an der gewünschten Stelle in der Basis-Dokumentation (in diesem Fall hinter dem ersten Satz aus der Basis)."
  },
  "doc/documentation/control-features.html": {
    "href": "doc/documentation/control-features.html",
    "title": "Control Features",
    "keywords": "Control Features Es gibt einige Einstellungen, die speziell an Controls verfügbar sind. Machne dieser Einstellungen sind an allen Controls verfügbar, andere wiederum nur an Controls eines bestimmten Typs. Wenn ein Control im Designer ausgewählt ist, sind alle verfügbaren Einstellungen unter der Kategorie Documentation zu finden. Alle Controls Documentation Öffnet den Dokumentations-Editor (siehe Editor ) HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. TabbedWindow ChaptersForTabs Gibt an, ob die Registerkarten des TabbedWindow als eigenständige Kapitel in die Dokumentation gerendert werden sollen. Dieser Schalter ist nur für TabbedWindows auf oberster Ebene vorgesehen. Er zieht also nicht für TabbedWindows, die z.B. in einem Panel verschachtelt sind. ImageButton ShowImageInDocumentation Gibt an, ob das am Control hinterlegte Bild in die Control-Überschrift in der Dokumentation gerendert werden soll oder nicht."
  },
  "doc/documentation/chapter-tree.html": {
    "href": "doc/documentation/chapter-tree.html",
    "title": "Chapter Tree",
    "keywords": "Chapter Tree Allgemein Der Chapter Tree ist die zentrale Instanz, welche alle Form- und Documentation-Elemente in Kapitel organisiert. Zu erreichen ist der Chapter Tree über das Menü Tools -> Documentation -> Chapter Tree . Ein Form- oder Documentation-Element spiegelt in einer exportierten Dokumentation genau ein Kapitel mit eigener Kapitelnummer wider. Chapter Tree für die Organisation der Kapitel: Es gibt zwei Abschnitte im Chapter Tree. Der Documentation (Preparation) -Knoten beinhaltet alle Formulare und Documentation-Elemente, die in einer Anwendung neu hinzugekommen oder noch nicht in die Dokumentation eingebunden wurden. Sie werden alphabetisch aufsteigend aufgelistet. Der Documentation (Release) -Knoten spiegelt den Kapitelbaum der Dokumentation wieder, die mit dem Export Wizard gerendert werden kann. Als Text wird die im Dokumentations-Editor angegebene Caption des Formulars oder Documentation-Elements angezeigt. Ist diese nicht definiert wird in Klammern hinter dem Namen des Formulars oder Documentation-Elements der Zusatz “caption not set” angezeigt. Die Form- oder Documentation-Elemente können aus dem Chapter Tree mit einem Doppelklick auf den Knoten oder mit der Entertaste direkt geöffnet werden. Die Textbox am unteren Rand zeigt den vollen Namespace des aktuell ausgewählten Knoten an. Kapitelstruktur Wird die Dokumentation wie in der Abbildung mit dem Export Wizard in eine Word-Datei exportiert, folgt die Kapitelnummerierung der Ebene des Documentation (Release) -Knotens. Wie im Beispiel zu sehen hätten die folgenden Kapitel die angegebenen Kapitelnummern: Einführung in das Programm eNVenta = 1. eNVenta ERP = 2. Initialisierung = 5. eNVenta Init = 5.1 Da Word bis zu 9 Ebenen unterstützt, können auch im Chapter Tree die Formulare und Documentation-Elemente in bis zu 9 Ebenen (x.x.x.x.x.x.x.x.x) verschachtelt werden. Um ein Kapitel an eine andere Stelle einzufügen bzw. ein Kapitel aus dem Preparation- in den Release-Knoten zu verschieben, muss nur der entsprechende Knoten per Drag&Drop an die richtige Position gezogen werden. Sind nicht alle beteiligten Elemente im Framework Studio ausgecheckt, wird eine entsprechende Meldung angezeigt. Auschecken von beteiligten Elementen: Im Beispiel wurde der Knoten CSV Format Konversion aus dem Preparation-Knoten in den Release-Bereich unter das Kapitel eNVenta ERP -> Wv-Übersicht gezogen. Keines der Elemente war zu diesem Zeitpunkt ausgecheckt."
  },
  "doc/database/ml-column.html": {
    "href": "doc/database/ml-column.html",
    "title": "ML-Column",
    "keywords": "ML-Column Framework Studio bietet einen Mechanismus, um Dateninhalte in mehreren Sprachen zu speichern. Eine beliebige Tabellen-Spalte, in der eine Zeichenkette abgelegt ist, kann im Tabelleneditor als MLColumn markiert werden. Vorraussetzung ist jedoch, dass die Tabelle die Spalte FSRowID enthält, weil diese als eindeutige Referenz auf den Datensatz benötigt wird. Ist eine Tabellen-Spalte als MLColumn gekennzeichnet, dann werden die fremdsprachigen Texte in der Tabelle dbRun_MLStrings abgelegt. Die normale Tabellen-Spalte beinhaltet die Texte in Default-Sprache. Caution Fehlt einer Component das Property ROWID (mit Mapping auf die DB-Column FSRowID ), ist der Mechanismus für diese Component deaktiviert. Join-Components können keine ML-Columns aus mehreren Tabellen verabreiten, da die Component lediglich ein ROWID-Property betrachtet. Werden mehrere ROWID-Properties aus verschiedenen Tabellen eingebunden, dann ist es Zufall, welche ROWID für den MLColumn-Mechanismus herangezogen wird. Customizing-Package Die Eigenschaft MLColumn kann im Customizing-Package gesetzt werden. Somit kann man in Kunden-Umgebungen den Mechanismus gezielt für die gewünschten Tabellen-Spalten aktivieren. Anwendung in Default-Sprache Die Default-Sprache ist de - außer man definiert der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_DEFAULT_LANGUAGE eine andere Default-Sprache. Wird die Anwendung in der Default-Sprache gestartet, dann arbeitet Framework Studio mit der ganz normalen Spalte der Tabelle - ohne jegliche Sonder-Logik. Die fremdsprachigen Texte können nicht beeinflusst werden. Ändert man einen Text, dann bleiben die ggf. existierenden Übersetzungen unverändert erhalten. Bei Bedarf müsste man die Anwendung anschließend in den Fremdsprachen starten und den gewünschten Text dort ebenfalls anpassen. Anwendung in Fremdsprache Startet man die Anwendung mit einer Fremdsprache, dann greifen besondere Mechanismen. Die entsprechenden Component-Properties behandeln dann ausschließlich den fremdsprachigen Text mit einem Fallback auf die Default-Sprache. Die ML-Column-Logik wird von den ganz normalen Component-Properties behandelt. Dadurch wirkt sie sich automatisch auf alle Bereiche der Anwendung aus - inkl. Form-Databinding und Reporting. Load : Beim Zugriff auf das entsprechende Component-Property wird der Text aus der Tabelle dbRun_MLStrings gelesen. Existiert dort kein Eintrag, wird der Text der Default-Sprache aus der normalen Tabellen-Spalte verwendet. Update : Wird der Text geändert, dann wird der Eintrag in der entsprechenden Fremdsprache überschrieben. Der Text in der Default-Sprache kann nicht verändert werden. Wird der fremdsprachige Text geleert, dann wird beim Save der Component der Eintrag aus der Übersetzungs-Tabelle gelöscht und das Component-Property fällt auf die Default-Sprache zurück. Insert : Beim Anlegen eines neuen Datensatzes wird der eingegebene Text sowohl in der normalen Tabelle als auch in der Fremdsprache gespeichert. Delete : Wird der Datensatz aus der Datenbank gelöscht, dann werden auch alle zu dieser FSROWID gespeicherten Texte aus der Übersetzungs-Tabelle gelöscht. Such-Funktion Note Dieses Feature muss in der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_SEARCH_ENABLED aktiviert werden. Bei automatischen Suchfeldern werden die Fremdsprachen-Texte zusätzlich berücksichtigt. Wird die Anwendung in einer Fremdsprache ausgeführt, dann enthält die erzeugte SQL-Bedingung beinhaltet sowohl die normale Bedingung, welche den Treffer in der Default-Sprache sucht als auch einen Lookup auf die Texte in der entsprechenden Fremdsprache. -- Beipiel: Select [....] FROM Tabelle WHERE (Spalte LIKE 'abc%' OR EXISTS (SELECT 1 FROM dbRun_MLStrings WHERE ML_TableName = 'TABELLE' AND ML_ColumnName = 'SPALTE' AND ML_Iso = 'en' AND ML_FSROWID = FSROWID AND ML_SearchText LIKE 'abc%')) Note Der Lookup berücksichtigt die ersten 200 Zeichen des Textes. Die Fremdsprachen-Texte können auch Langtexte speichern. Diese lassen sich nicht indizieren. Aus Performance-Gründen erfolgt der Lookup über eine separate indiziere Spalte ML_SearchText . Diese wird (wenn das Feature aktiviert ist) von der Anwendung zusammen mit dem Langtext gespeichert. Sprache zur Laufzeit ändern Die Sprache ist mit dem Start der Anwendung an Global. SelectedLanguage festgelegt. Wird für einen bestimmten Code eine abweichende Sprache benötigt, dann kann dies über Global. UseMLColumnLanguage geschehen. Während der übergebenen Action kann so ein abweichender Iso-Code gesetzt werden. Über das Property Global. MLColumnLanguage kann die aktuell gültige Sprache ermittelt werden. this.Global.UseMLColumnLanguage(\"fr\", () => { // Erzeugen des Reports in französischer Sprache. }); Important Diese Funktion beeinflusst nicht die in der Oberfläche angezeigten Daten. Es gibt keine Möglichkeit dauerhaft auf die Sprache Einfluss zu nehmen. Tips für Entwickler Finden von MLColumns Wird eine DBColumn als MLColumn gekennzeichnet wird dafür der folgende Code generiert: public class Package_FSColumnName : FS.Demo.MDT.ArticleName { public Package_FSColumnName() { this.m_IsMLColumn = true; } } Dadurch können alle MLColumns mit dem Text this.m_IsMLColumn = true; über die Code-Suche gefunden werden. Dabei die Suche auf die DBTables einschränken."
  },
  "articles/aktuelle-pakete.html": {
    "href": "articles/aktuelle-pakete.html",
    "title": "Aktuelle Installations-Pakete",
    "keywords": "Aktuelle Installations-Pakete In dieser Liste sind alle aktuellen verfügbaren Installations-Pakete aufgeführt. Paket Version Name der Zip-Datei Framework Studio IDE 4.2 .9 FS_4.2.9_Setup_x64 Requirements-Paket 32 Bit 4.2 .0 FS_4.2.0_Requirements_x86 Requirements-Paket 64 Bit 4.2 .0 FS_4.2.0_Requirements_x64 Runtime Administration 4.2 .0 FS_4.2.0_RuntimeAdministration Authentication-Service 4.0 .16 FS4.0.16_AuthService Print-Service 4.0 .16 FS4.0.16_PrintService FSClient Launcher 32 Bit 4.0 .14 FSCL_4.0.14_Setup_x86 FSClient Launcher 64 Bit 4.0 .14 FSCL_4.0.14_Setup_x64 FSClient Launcher 32 Bit MSI-Installer 4.0 .14 FSCL_4.0.14_Setup_Msi_x86 FSClient Launcher 64 Bit MSI-Installer 4.0 .14 FSCL_4.0.14_Setup_Msi_x64 Runtime Supervisor 4.0 .14 RS_4.0.14_Setup_x64"
  },
  "doc/application/application.html": {
    "href": "doc/application/application.html",
    "title": "Application",
    "keywords": "Application"
  },
  "doc/allgemein/options.html": {
    "href": "doc/allgemein/options.html",
    "title": "Options",
    "keywords": "Options Die Options können in der IDE über den Menüeintrag Tools / Options geöffnet werden. IDE (Registerkarte) Login Get DLLs Mit der Checkbox Enable option 'Include Debug DLLs' by default wird im Login dafür gesorgt, dass beim Get DLLs die vom Framework Compiler erzeugten Debug-Informationen gezogen werden. Das beinhaltet (soweit vorhanden) die Debug-Informationen der Basis-Packages. Appearance Error Display Wird die Checkbox Legacy Error Window gesetzt, kann erzwungen werden, dass die Errors in derselben Art und Weise ausgegeben werden, wie es bis Framework Studio 2.6 der Fall war. Background Image Wird die Checkbox Disable gesetzt, wird in der Framework Studio Umgebung kein Hintergrundbild mehr angezeigt. Dies kann zu einer Performancesteigerung bei Remote Sessions beitragen (z.B. VNC). Documentation Indicators Zeigt an den Controls im Form-Designer an, ob eine Dokumentation gepflegt ist, bzw vererbt wurde. Siehe Dokumentationsstatus von Steuerelementen Form Control DoubleClick Gibt an, was im Form-Designer passieren soll, wenn auf ein Control Strg + Doppelklick ausgeführt wird. RadioButton Show Control Events : Zeigt den Events-Dialog für das Control an. Diese Option ist sinnvoll für normale Entwickler. Der Documentation-Editor kann über das Context-Menü des Controls geöffnet werden. RadionButton Show Documentation : Zeigt den Documentation-Editor für das Control an. Diese Option ist sinnvoll für Benutzer, die viel an Dokumentationen arbeiten. Die Control-Events können über das Context-Menü des Controls geöffnet werden. Show form designer grid Gibt an, ob im Form-Designer das Raster-Grid angezeigt werden soll. Bei der Arbeit über Remote Desktop kann dieses Grid die Performance sehr stark verschlechtern. Languages in designer Hier können die Sprachen eingestellt werden, die in den MLStrings und im Wörterbuch angeboten werden sollen. Die Reihenfolge wird - sofern dies möglich ist - von den Designer-Fenstern berücksichtigt. Es werden kommasepariert die Iso-Codes der Sprachen angegeben - z.B. de,en,fr . Wird keine Angabe gemacht, werden in allen Designer-Fenstern immer alle verfügbaren Sprachen angeboten. Code Editor Font Family Hier können Schriftart und -größe für den Code-Editor angepasst werden. Go to Definition with Ctrl+DoubleClick Schaltet im Code-Editor die Funktion Go to Definition (F12) mit Strg + Doppelklick ein. Es kann sinnvoll sein, diese Funktion zu deaktivieren, wenn man diese Funktion öfters aus Versehen auslöst. Dann bleibt immer noch die F12-Taste oder das Context-Menü zum Aufruf dieser Funktion. Context Tooltip Gibt an, ob im Code-Editor Informationen zu Elementen angezeigt werden sollen, wenn mit der Maus auf Code-Teile gezeigt wird. Compile / Debug (Registerkarte) Broker Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Host Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Compile Rootdirectory Gibt an, unter welchem Ordner Framework Studio die Compile-Verzeichnisse erzeugen soll. Diese Einstellung muss manuell in der Datei FrameworkStudio.exe.config angepasst werden. Beispiel: <configuration> <appSettings> <add key=\"CompileBaseDirectory\" value=\"C:\\FS\\Compile42\" /> [...] Visual Studio Path Hier kann angegeben werden, wo Visual Studio installiert ist. Die aktuell von Framework Studio unterstützten Versionen von Visual Studio werden automatisch erkannt. Wenn eine andere Version oder Edition (z.B. Visual Studio Express) verwendet werden soll, kann das entsprechende Programm angegeben werden. Mit dem Button Reset wird der Wert auf die Original-Einstellung zurückgesetzt. Diese Einstellung wird für das Menu View / Compiled Code in Visual Studio in den Designer-Fenstern verwendet. Außerdem wird der Ordner aus dieser Einstellung verwendet, um für die Arbeit mit Services das Programm WcfTestClient.exe zu finden. Visual Studio Arguments Hier können die Kommandozeilen-Argumente für das Öffnen der Quellcode-Dateien angegeben werden. Beim Einsatz von Visual Studio können die Standard-Einstellungen %file% /Edit beibehalten werden. Der Platzhalter %file% steht für die zu öffnenden Dateien. Dieser werden in dem Format \"Datei1.cs\" \"Datei2.cs\"… übergeben. Wenn dieser Platzhalter nicht angegeben ist, dann werden die Dateien an der Parameter gestellt. Utilities (Registerkarte) Mit dem Button [...] kann jeweils ein Dateiauswahldialog geöffnet werden. SvcUtil Gibt den Pfad zur SvcUtil.exe des Windows SDK an. Diese wird für die Generierung des Services verwendet. InstallUtil Gibt den Pfad zur InstallUtil.exe des .NET-Frameworks an. Crystal Report Designer Gibt den Pfad zum Crystal Report Designer an. Diff Tool Hier kann die ausführbare Datei für das Diff Tool angegeben werden. Diff Tool Data Dir Hier kann das Datenverzeichnis für das Diff Tool angegeben werden."
  },
  "doc/index.html": {
    "href": "doc/index.html",
    "title": "Framework Studio Technische Dokumentation",
    "keywords": "Framework Studio Technische Dokumentation"
  },
  "articles/update-4-2/neue-text-funktionen.html": {
    "href": "articles/update-4-2/neue-text-funktionen.html",
    "title": "Neue Text-Funktionen",
    "keywords": "Neue Text-Funktionen In Framework Studio 4.2 wurden im Zuge der Umstellung auf die MLKeys auch die Text-Zugriffe auf Text-Collections und DevMLStrings überarbeitet. Note Auch wenn keine MLKey-Migration ausgeführt wird, muss die Convert Messages Routine trotzdem ausgeführt werden, damit die Verarbeitung der Fremdsprachen-Texte korrekt funktioniert. Siehe Abschnitt Migration auf Version 4.2 Bei der Verwendung von this.Global.SelectedLanguage erfolgt kein Fallback auf andere Sprachen. Aus diesem Grund sollte dies nicht mehr verwendet werden. Für das ermitteln des Textes wurden deshalb einfachere Varianten geschaffen, die ohne explizite Angabe der Sprache arbeiten. Andere Stellen erhalten jetzt stattdessen das komplette this.Global um daraus die Sprach-Hierarchie inkl. Fallbacks zu ermitteln. Die Text-Ermittlungen benötigen auch immer einen Zugriff auf das GlobalObject, damit die zentralen Einsprungpunkte immer angelaufen werden. Text-Collection Soll für einen bestimmten Text-Collection-Eintrag der Text ermittelt werden, dann erfolgt dies idealerweise über die Factory -Klasse. Dort wird eine Methode GetText(global, id) angeboten. Diese Methode Liefert den Text in der aktuellen Sprache / Sprach-Hierarchie, welche über das GlobalObject festgelegt ist. string sText = ctTextCollFactory.GetText(this.Global,7); Wird der Text in einer bestimmten Sprache benötigt, dann muss über die Methode Get(global, id) der Text-Collection-Eintrag ermittelt und an diesem mit der Methode GetText(iso) der gewünschte Text ermittelt werden. string sText = ctTextCollFactory.Get(this.Global,7).GetText(sIsoCode); Text-Collection-Eintrag Manchmal wird auch mit bestimmten Einträgen der Text-Collection gearbeitet. Dieser bietet die folgenden Möglichkeiten, den Text zu ermitteln. Das Property Text liefert den Text in der aktuellen Sprache / Sprach-Hierarchie, welche über das GlobalObject festgelegt ist. string sText = oTextCollEntry.Text; Die Methode GetText(iso) liefert den Text in einer gewünschten Sprache. Dabei erfolgt kein Fallback auf eine andere Sprache. Ist in der angegebenen Sprache kein Text formuliert, wird String.Empty zurückgegeben. string sText = oTextCollEntry.GetText(sIsoCode); Über das Property Value wird ein Objekt mit dem Typ DevMLString zurückgegeben. Dieses hat aber selber keinen Bezug zum GlobalObject, weshalb ihm zur Ermittlung der Texte ein GlobalObject übergeben werden muss. Es sollten wenn möglich die o.g. Wege zur Ermittlung der Texte benutzt werden. Das Property Value ist nur in Ausnahme-Fällen zu verwenden. DevMLString Zur Ermittlung eines Textes muss ein GlobalObject übergeben werden. Es gibt dazu die folgenden Möglichkeiten: // Text in aktueller Sprache / Sprach-Hierarchie string sText1 = oDevMLString.GetString(this.Global); string sText2 = oDevMLString[this.Global]; // Text in bestimmter Sprache string sText3 = oDevMLString.GetString(this.Global, sIsoCode); Obsolete Schnittstellen Am DevMLString wurden einige Properties/Methoden auf Obsolete gesetzt, weil sie kein GlobalObject verwenden. Beim Compile werden betroffene Stellen als Warning ausgegeben. // Diese Aufrufe sind Obsolete!!! string sText1 = oDevMLString.GetString(sIsoCode); string sText2 = oDevMLString[sIsoCode]; string sText2 = oDevMLString.German; Migration auf Version 4.2 Um eine saubere Funktion der Fremdsprachen-Texte zu gewährleisten, müssen diese Aufrufe mit dem Update auf die Version 4.2 umgestellt werden. Ein sehr großer Teil der Aufrufe wird mit der Convert-Messages Routine in der MLKey-Migration automatisch umgesetzt. Es bleiben aber einige wenige Stellen übrig, die manuell nachgearbeitet werden müssen. Sie werden beim Compile durch die Obsolete-Warning erkannt. Im folgenden werden ein paar Code-Beispiele aufgeführt, die verdeutlichen, wie die Umstellung zu erfolgen hat. Alter Code neuer Code ctAbcFactory.Get(this.Global,7).Value[this.Global.SelectedLanguage] ctAbcFactory.GetText(this.Global,7) ctAbcFactory.Get(this.Global,7).Value[sIsoCode] ctAbcFactory.Get(this.Global,7).GetText(sIsoCode) oTextCollEntry.Value[Global.SelectedLanguage] oTextCollEntry.Text oTextCollEntry.Value.GetString(sIsoCode) oTextCollEntry.Value[sIsoCode] oTextCollEntry.GetText(sIsoCode) oTextCollEntry.Value.German oTextCollEntry.GetText(\"de\") oDevMLString.GetString(sIsoCode) oDevMLString[sIsoCode] oDevMLString.GetString(this.Global, sIsoCode) oDevMLString.German oDevMLString.GetString(this.Global, \"de\")"
  },
  "articles/update-4-2/mlkey-migration.html": {
    "href": "articles/update-4-2/mlkey-migration.html",
    "title": "MLKey Migration",
    "keywords": "MLKey Migration Ziel ist es, dass alle Texte aus den Records entfernt und in das Wörterbuch übertragen werden. Die Records erhalten dafür Verweise auf Einträge im Wörterbuch, die MLKeys . Generell teilt sich die Migration in zwei große Phasen auf: MLKeys erzeugen und zuordnen : Diese Phase kann parallel zur Weiterentwicklung durchgeführt werden. Es werden zum Einen neue Einträge im Wörterbuch angelegt und zum Anderen vorgemerkt, wo diese später verwendet werden sollen. MLKeys übertragen : In dieser Phase werden primär die vorbereiteten Zuordnungen an die Elemente übertragen: angegebene Texte werden entfernt und statt dessen die gewünschten MLKeys eingetragen. Dazu müssen alle betroffenen Elemente ausgecheckt werden. Zusätzlich werden weitere Umstellungen (z.B. bestehende Messages und Exceptions) durchgeführt. Abwärts-Kompatibilität Texte, die bisher an den Records definiert sind, funktionieren auch weiterhin, weil jeder MLString neben dem MLKey explizit gesetzte Texte versteht. So kann man nach dem Update auf die Version 4.2 die Migration in aller Ruhe angehen. Note In Kunden-Packages ist die Umstellung der eigenen Texte auf MLKeys empfohlen. Sie ist aber nicht zwingend notwendig. Das hat aber langfristig einige Nachteile zur Folge - insbesondere in Hinblick auf die Mehrsprachigkeit der Anwendung: Der Language Export / Import funktioniert nur für das Wörterbuch. Individuelle Texte an Records werden nicht (mehr) berücksichtigt. Das Pflegen von Fremdsprachen an den Records ist sehr aufwändig. Die MLKeys aus dem Wörterbuch bringen hingegen die Übersetzungen automatisch in alle Bereiche der Anwendung. Important Funktionale Packages, die als Produkt an mehrere Kunden vertrieben werden, sollten in jedem Fall migriert werden. MLKeys erzeugen und zuordnen Diese erste Phase der MLKey Migration dient zum Einen der Erzeugung der benötigten Einträge im Wörterbuch (MLKeys) und zum Anderen der Zuordnung, wo diese später verwendet werden sollen. Zentrales Werkzeug für diese Phase ist der Dialog Multilanguage Text Migration , welcher über das Menü Tools / Multilanguage Text Migration geöffnet werden kann. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Alle durch den Benutzer definierten Zuordnungen werden in der Ressource Migration.xml im Verzeichnis FSGeneral/Resources/lang gespeichert, welche automatisch bei der ersten Benutzung angelegt wird. Ist diese Datei bei der Bearbeitung mit dem Multilanguage Text Migration Dialog nicht ausgecheckt, so wird beim Speichern mit dem Button Save automatisch die neueste Version ausgecheckt, die Änderungen ergänzt und anschließend sofort wieder eingecheckt. Dieses Verhalten ist dann hilfreich, wenn mehrere Benutzer gleichzeitig mit dem Multilanguage Text Migration Dialog arbeiten. Andernfalls empfiehlt es sich, die Datei vor Beginn der Arbeit auszuchecken und erst nach Beendigung der Arbeit wieder einzuchecken. So werden unnötige Checkin- und Checkout-Vorgänge vermieden. Beim Speichern werden außerdem ggf. ungespeicherte Änderungen am Wörterbuch gespeichert. Generelles Vorgehen Die zu leistende Arbeit besteht in erster Linie darin, logisch identische Begriffe zusammenzuführen und logisch unterschiedliche Begriffe, die ggf. in einzelnen Sprachen Überlappungen mit anderen Begriffen haben, zu trennen. Beispiel: Die Begriffe Suche mit SQL , Suchen mit SQL , SQL Suche , SQL-Suche , Suchen SQL , Sql Suche und weitere Varianten sollten zu einem einzigen Eintrag zusammengefasst werden. (1) Load Data Important Zunächst sollten Tooltips außen vor gelassen werden. Dazu darf die Checkbox Include Tooltips NICHT gesetzt sein, wenn mit dem Button Load Data alle im Package angegebenen Texte eingelesen werden. Erst wenn allen Texten ein MLKey zugeordnet wurde, werden die im Folgenden beschriebenen Schritte nach dem erneuten Laden der Daten inklusive Tooltips ein zweites Mal durchgeführt. Note Wenn durch ein Basis-Package bereits Einträge im Wörterbuch existieren, so wird Framework Studio nach dem Laden automatisch einem mehrsprachigen Text aus dem Custom-Package den MLKey zuweisen, der mindestens in den angegebenen Sprachen die Texte in exakt der Schreibweise enthält. Die mit dem Button Load Data eingelesenen Texte werden in einer Tabelle angezeigt. Die einzelnen Spalten haben folgende Bedeutung: Record : Name des Elements, an dem der Text angegeben ist, z.B. frmArticle . Element : Name des Unterelements, an dem der Text angegeben ist, z.B. edtsName . Type : Typ des Unterelements, z.B. FormControl . Property : Eigenschaft, an der der Text angegeben ist, z.B. Caption . MLKey : Der MLKey, welcher zugeordnet werden soll, z.B. LBL_Name . {Sprachen...} , z.B. German , English usw.: Der Text, welcher in der jeweiligen Sprache angegeben ist, z.B. Name . Die Spalten können durch anklicken der Spaltenüberschrift sortiert werden. Meist wird man nach deutschem Text sortiert arbeiten. Ein Doppelklick in die Spalten Record oder Element öffnet das Designerfenster für das Element und springt soweit möglich zum Unterelement. In allen anderen Spalten wird beim Doppelklick der Text der Zelle als Filterkriterium in das Feld Search: gesetzt. Für die Filterfunktion mit dem Feld Search: gelten folgende Regeln: Groß-Kleinschreibung wird ignoriert Es wird in allen Spalten gesucht Es werden nur die Zeilen angezeigt, die ALLE der durch ein Leerzeichen getrennten Buchstabenfolgen enthalten In Anführungsstriche \" gekapselte Buchstabenfolgen müssen genau so in der Zeile enthalten sein, damit diese angezeigt wird Beispiel: Die Suche nach LBL_Quantity \" geliefert\" zeigt nur die Zeilen an, welche geliefert mit einem führenden Leerzeichen und LBL_Quantity in irgendeiner Spalte enthalten. (2) Auto Create MLKeys Nach dem Einlesen der Daten (zunächst ohne Tooltips, siehe Load Data ) sollten einmalig mit dem Button Auto Create MLKeys alle automatisch erzeugbaren MLKeys in das Wörterbuch eingefügt werden. Automatisch erzeugt werden MLKeys dann, wenn es zu gleichen Texten in einer Sprachen keine abweichenden Texte in anderen Sprachen gibt. Note Framework Studio weist danach automatisch den Zeilen einen MLKey zu, die nur Texte enthalten, welche zu einem MLKey aus dem Wörterbuch keinen Wiederspruch aufweisen. (3) Manuelle Zuweisungen Ist die Checkbox Show only missing keys gesetzt, so wird die Anzeige aller Texte in der Tabelle auf die Einträge reduziert, welchen bisher noch kein MLKey zugewiesen wurde - die noch zu bearbeitenden Einträge. Im unteren Bereich des Multilanguage Migration Dialogs werden im Bereich Details zum aktuell in der Tabelle selektierten Eintrag alle Eigenschaften angezeigt. Ist bereits ein MLKey zugewiesen, werden die Texte des MLKeys in der Tabellenspalte In MLKey angezeigt. In der oberen Tabelle können auch mehrere Zeilen gleichzeitig ausgewählt werden. So kann mehreren Zeilen gleichzeitig ein MLKey zugewiesen werden. Für die Zuweisung stehen mehrere Optionen zur Verfügung: Mit dem Button im Bereich Details kann ein bereits existierender MLKey ausgewählt werden, siehe Multilanguage Text Editor , insbesondere Suchen von MLKeys . Wurde bereits ein MLKey zugewiesen, so wird ein weiterer Button Set ... angeboten, mit dem der zuletzt zugewiesene MLKey den aktuell selektierten Zeilen zugewiesen werden kann. Mit dem Button im Bereich Details kann ein neuer MLKey (basierend auf den selektierten Zeilen) erzeugt werden. Wenn beim Erzeugen eines neuen MLKeys mehrere Zeilen ausgewählt wurden und diese in einzelnen Sprachen abweichende Texte enthalten, so wird pro Sprache bei Bedarf der folgende Dialog geöffnet: In diesem werden alle Varianten, sortiert nach Häufigkeit absteigend, aufgeführt. Durch Selektion und Bestätigung mit dem Button OK oder durch Doppelklick wird die Auswahl als Vorbelegung für den neuen MLKey verwendet (siehe Erfassen neuer MLKeys ). Important Bei der Zuweisung und Erzeugung von MLKeys sind die eNVenta Regeln für MLKeys zu beachten. Mit dem Button Rename MLKey ist es im Rahmen der Migration möglich, einen bestehenden MLKey umzubenennen. Alle manuellen Zuordnungen dieses MLKeys werden automatisch angepasst. (4) Bereinigungen Im Wörterbuch werden sich durch die vorangegangenen Schritte (z.B. durch die von Framework Studio automatisch generierten MLKeys) einige Unsauberkeiten eingeschlichen haben. Daher sind die folgenden Maßnahmen empfehlenswert: Maßnahmen im Wörterbuch: Sortierung nach MLKey: Folgen aufeinander logisch identische Begriffe? Suche Nach _1 , _2 , _3 usw: Sind diese Varianten nötig oder sollten anders benannt werden? Sortierung nach deutschem Text: Folgen aufeinander logisch identische Begriffe? In Custom-Packages sind dabei nur die MLKeys aus dem eigenen Package (zu erkennen an der Fettschreibung) und ihre Vorgänger und Nachfolger interessant. Außerdem können im Multilanguage Text Migration Dialog mit dem Button Find unused MLKeys alle MLKeys aus dem eigenen Package aufgelistet werden, welche im Wörterbuch existieren, jedoch nirgendwo zugeordnet sind. Diese gilt es, kritisch zu prüfen. (5) Abschluss Phase 1 Wurden die vorigen Schritte (zunächst ohne Tooltips, danach mit Tooltips) abgeschlossen, so kann nun mit Phase 2 ( MLKeys übertragen ) fortgefahren werden. MLKeys in Custom-Packages Im Customizing kann man grundsätzlich 2 verschiedene Arten von überschriebenen Texten unterscheiden: Texte, die eine ganz neue Bedeutung haben. Wenn z.B. ein relativ allgemeiner Metadatentyp in einem Component-Property verwendet wird, wird dort am Default-Label ein neuer Text formuliert. In diesen Fällen sollte auf jeden Fall ein entsprechender (ggf. neuer) MLKey zugeordnet werden. Ändern eines bestehenden Textes. Es wird z.B. ein Metadatentyp customized und das Default-Label geändert - aus dem Begriff \"Angebot\" wird z.B. \"Offerte\". Die Bedeutung bleibt aber dieselbe. In solchen Fällen gilt es zu prüfen, ob es evtl. ratsam ist, diese Änderung direkt im Wörterbuch vorzunehmen. So zieht diese für die gesamte Anwendung. Bei der Migration weist man dann diesen Einträgen den existierenden MLKey zu - auch wenn er identisch mit dem bereits zugeordneten MLKey aus dem Basis-Package sein sollte. In einem späteren Schritt der Migration wird eine redundante Zuordnung dann automatisch eliminiert. MLKeys übertragen Ist das Wörterbuch komplett vorbereitet (siehe MLKeys erzeugen und zuordnen ), ist es an der Zeit, die MLKeys in die Records zu übertragen. In diesem Schritt werden alle Aktionen ausgeführt, die einen Checkout der Records zur Folge haben. So wird die ggf. erhebliche Menge an Checkouts auf das nötigste reduziert. (1) Als FCUser anmelden Weil nach der Konvertierung sehr viel kompiliert werden muss, ist es empfehlenswert als FCUser zu arbeiten. So kann direkt nach dem Kompilieren der Complete Framework Compiler aufgerufen werden und es ist kein zusätzlicher FrameworkCompiler nötig. Mit dem Benutzer FrameworkCompiler anmelden - mit Refresh Workspace. Get DLLs ist nicht notwendig. Framework Studio direkt wieder beenden. Jetzt als FC-User anmelden - mit Refresh Workspace. Das übernimmt den Workspace vom Benutzer FrameworkCompiler. (2) Apply MLKeys Im Fenster Multilanguage Text Migration mit dem Button Load Data (inkl. den Tooltips) alle Daten einlesen. Es sollte jetzt keine offenen Zuordnungen mehr geben - wenn man die Checkbox Show only missing keys setzt, dürfen keine Einträge angezeigt werden. Mit dem Button Apply MLKeys wird die Routine gestartet. Es werden alle zugeordneten MLKeys an die entsprechenden Properties der Records übertragen. Dabei werden ALLE in den jeweiligen Sprachen gesetzten Texte aus den Records entfernt. Somit ziehen ab diesem Zeitpunkt die Texte nur noch aus dem Wörterbuch. (3) Convert Messages Mit dem Button Convert Messages im Fenster Multilangage Text Migration wird die Routine gestartet. Für diese Routine müssen keine Daten eingelesen werden - das gilt auch, wenn sie zu einem späteren Zeitpunkt erneut gestartet wird. Es werden alle Methoden-Codes analysiert und nach Exceptions- und MessageBox-Aufrufen gesucht. Diese werden in das neue Message-Format umgewandelt und die Verweise auf die Text-Collections werden durch den entsprechenden MLKey ersetzt. Warning Die Routine Apply MLKeys muss zuvor ausgeführt worden sein, damit die Message-TextCollections sauber zugeordnete MLKeys besitzen. Alter Exception-Code vor der Konvertierung: #region Required for Exception Editor support. Do not modify manually. //Component type is required. //Severity: 0 ; Buttons: OK; Icon:Error throw new FrameworkApplicationException (String.Format(FSGeneral.ctMessagesFactory.Get(this.Global,3550).Value[Global.SelectedLanguage],new object []{}),0 ); //<ExceptionEditor TextColl=\"Messages\" ID =\"832e0e50c2b748068ba38a2c4422aaab\" Severity=\"0\" EHID=\"\" ></ExceptionEditor> #endregion End of generated section Neuer Exception-Code nach der Konvertierung: // FSCodeMessage: Component type is required. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_445559f2ca44452e8d49ca9515b3a83e), 0); Es ist relativ wahrscheinlich, dass Warnings oder sogar Errors ausgegeben werden. Diese können erst einmal ignoriert werden. Es handelt sich dabei um inhaltliche Probleme und nicht um Compile-Errors. Die Convert Code Messages Routine kann zu einem späteren Zeitpunkt erneut ausgeführt und diese Probleme dann behoben werden. Important Damit sind die Message-Text-Collections jetzt obsolete. Sie dürfen aber nicht gelöscht oder geleert werden, weil sie ggf. noch von Customizing-Packages referenziert werden. (4) MLStrings Cleanup Nachdem alle MLKeys übertragen wurden, können jetzt noch einige Bereinigungen durchgeführt werden. Über das Menü Tools / Checks / MLStrings Cleanup kann das Cleanup-Fenster geöffnet werden. Dort stehen mehrere Routinen zur Auswahl. Diese sollten einer nach der anderen ausgeführt werden. Dabei ist es ratsam zuerst den Button Analyze zu benutzen. Erst nach der Sichtung der Infos und Warnings wird die Routine mit dem Button Cleanup ausgeführt. Clean MLKeys Wird in einem Record (z.B. DBColumn, Form-Control) der MLKey mit demselben Wert überschrieben, wie er in der Basis (z.B. Metadatentyp, Basis-Package) definiert ist, dann wird diese Überschreibung entfernt. Transfer translations Wurden trotz vererbtem MLKey Übersetzungen nur an Records gepflegt, dann wurden diese mit der Migration ggf. nicht in das Wörterbuch übertragen. Das wird mit dieser Routine nachgeholt. Wird an einem Record, der einen MLKey besitzt, eine Übersetzung gefunden und das Wörterbuch kennt diese noch nicht, wird diese in das Wörterbuch übertragen und der Text vom Record entfernt. Dabei gewinnt pro MLKey der erste Record. Wird ein weiterer Record mit gleichem MLKey aber einer anderen Übersetzung gefunden, dann wird dieser als Warning ausgegeben. Beim Cleanup verbleibt dieser Text am Record. Bei einem weiteren Lauf würde dieser Record mit der Routine Clean individual texts gefunden werden. Clean individual texts Die MLKey-Migration berücksichtigt nur Texte, die mindestens in Deutsch und Englisch gepflegt sind. Sind an einem Record nur andere Sprachen definiert, dann wird dieser Text nicht migriert. Oftmals erben diese Records schon einen Text aus der Basis und es sind nur einige Übersetzungen gepflegt. Diese sollen hier bereinigt werden. Es werden Texte, die identisch mit dem Wörterbuch sind, entfernt. Vom Wörterbuch abweichende Texte werden als Warning ausgegeben und NICHT entfernt. Diese müssen in einem weiteren Schritt bearbeitet werden. Warnings bearbeiten Jetzt müssen die aufgetretenen Warnings begutachtet und ggf. manuell bearbeitet werden. Clean individual texts mit Remove different Wurden im vorherigen Schritt die Warnings begutachtet, können mit dieser Aktion alle abweichenden Texte entfernt werden. (5) Compile und CheckIn Jetzt müssen alle Änderungen compiliert werden. Menü Compile / Compile Changes . Nachdem der Compiler erfolgreich beendet wurde, werden alle Elemente eingecheckt. Dabei sollte ein CheckIn-Kommentar z.B. MLKey Migration angegeben werden. Zum Abschluss noch über den Compile-Manager den Button Complete Framework Compiler aufrufen."
  },
  "articles/knowledge/snapshot-isolation.html": {
    "href": "articles/knowledge/snapshot-isolation.html",
    "title": "Zeilenversionierung im SQL-Server",
    "keywords": "Zeilenversionierung im SQL-Server Alle Microsoft SQL-Server Datenbanken, welche von Framework Studio genutzt werden, müssen mit aktivierter Zeilenversionierung arbeiten. Andernfalls können insbesondere längere Transaktionen unnötige Blockierungen auf Select-Statements zur Folge haben. Mit folgendem Statement kann die Einstellung überprüft werden. Dabei muss AdventureWorks durch den Namen der Datenbank ersetzt werden: SELECT snapshot_isolation_state_desc AS [READ_COMMITTED_SNAPSHOT], is_read_committed_snapshot_on AS [ALLOW_SNAPSHOT_ISOLATION] FROM sys.databases WHERE NAME = 'AdventureWorks' GO Das Ergebnis sollte ON, 1 sein. Mit folgenden Statements können die Einstellungen korrekt gesetzt werden. Dabei muss AdventureWorks durch den Namen der Datenbank ersetzt werden: ALTER DATABASE [AdventureWorks] SET READ_COMMITTED_SNAPSHOT ON GO ALTER DATABASE [AdventureWorks] SET ALLOW_SNAPSHOT_ISOLATION ON GO Beim Ausführen dieser Statements darf niemand angemeldet sein (auch keine Services) da exklusiver Zugriff auf die Datenbank benötigt wird. Framework Studio aktiviert die Zeilenversionierung beim Anlegen von Datenbanken automatisch."
  },
  "doc/tables/dbrun_config.html": {
    "href": "doc/tables/dbrun_config.html",
    "title": "dbRun_Config (Business-Datenbank)",
    "keywords": "dbRun_Config (Business-Datenbank) Diese Tabelle beinhaltet die Konfigurationen für den automatischen Datenbank-Update und die MLColumn-Logik. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Die Einstellungen müssen manuell per SQL vorgenommen werden. Wenn keine Einstellung existiert, dann zieht automatisch die Default-Einstellung. Spalte Beschreibung ConfigKey Schlüssel (siehe unten) ConfigValue Wert (siehe unten) ConnectionGroup Der Name der Connection-Group. Bei <NULL> zieht die Einstellung für alle Connection-Groups. Wenn für eine Connection-Group eine Konfiguration angegeben ist, dann hat diese Priorität. ConfigKey UNICODE Dieser ConfigKey stellt das Unicode-Verhalten des Update-Assinstenten ein. In ConfigValue sind folgende Werte zulässig: Disabled (Default) Neue Spalten werden ASCII (VARCHAR/ CLOB) angelegt. Enabled Neue Spalten werden Unicode (NVARCHAR/ NCLOB) angelegt. Adjust Bestehende Spalten werden auf Unicode umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. Important Diese Einstellung hat zur Folge, dass die GESAMTE Datenbank angefasst wird. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. ConfigKey LOB Dieser ConfigKey steuert, wie der Update-Assistent mit Langtext-Spalten umgehen soll. In ConfigValue sind folgende Werte zulässig Normal (Default) Neue Spalten werden mit LOB-Typen angelegt. Adjust Bestehende Spalten werden auf LOB-Typen umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. SQL-Server: text => varchar(max) / image => varbinary(max) Oracle: varchar2(2000) => CLOB Important ACHTUNG! Diese Einstellung hat zur Folge, dass große Teile der Datenbank angefasst werden. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. Bei Oracle kann sein ggf. sein, dass einige ältere Programme (wie z.B. SQL-Business) nicht mit dem Datentyp CLOB umgehen können. In diesem Fall muss der Schalter auf Normal gesetzt werden. ConfigKey ML_SEARCH_ENABLED Dieser ConfigKey aktiviert die Such-Funktion für die ML-Columns . 0 (Default) Das Feature ist deaktiviert. 1 Das Feature ist aktiv. Die Einstellung zieht für die komplette Datenbank. Die ConnectionGroup muss null sein. Caution Wird dieser Schalter nachträglich aktiviert, dann muss einmalig für bereits existierende Einträge in der Tabelle dbRun_MLStrings die indizierte Spalte ML_SearchText gefüllt werden. -- Sql-Server: UPDATE dbRun_MLStrings SET ML_SearchText = LEFT(ML_Text, 200); -- Oracle: UPDATE dbRun_MLStrings SET ML_SearchText = SUBSTR(ML_Text, 1, 200); ConfigKey ML_DEFAULT_LANGUAGE Dieser ConfigKey legt die Default-Sprache für die ML-Columns fest. Es muss der 2-stellige Iso-Code der Sprache angegeben werden (z.B. en , fr , it ). Default-Wert: de Die Einstellung zieht für die komplette Datenbank. Die ConnectionGroup muss null sein. Caution Wird die Default-Sprache geändert, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Wird die Default-Sprache nachträglich geändert, dann müssen in der Tabelle dbRun_MLStrings eventuell existierende Texte für die neue Default-Sprache entfernt werden."
  },
  "doc/sql/syntax.html": {
    "href": "doc/sql/syntax.html",
    "title": "SQL-Syntax",
    "keywords": "SQL-Syntax Framework Studio übersetzt alle SQL-Statements in die Syntax der verwendeten Ziel-Datenbank. Dazu werden alle Statements geparsed und für die Ziel-Datenbank wieder neu zusammengesetzt."
  },
  "doc/sql/operatoren.html": {
    "href": "doc/sql/operatoren.html",
    "title": "Operatoren",
    "keywords": "Operatoren || Verbindet 2 Zeichenketten. Beispiel: SELECT column1 || ' - ' || colum2 FROM tabelle Bei Zeichen-Ketten muss dieser Operator verwendet werden. Der + - Operator ist nicht zulässig. Wenn dennoch der + - Operator verwendet wird, versucht der Parser dies zu korrigieren. Das ist möglich, wenn bei der Operation Zeichen-Ketten oder bestimmte Zeichenketten-Funktionen beteiligt sind. Nicht erkannt wird z.B. das Verbinden von 2 Spalten. In diesem Fall kann es zu Fehlern auf der Ziel-Datenbank kommen. + - * / Addiert, subtrahiert, multipliziert bzw. dividiert 2 Zahlenwerte. Der Framework Studio SQL-Parser versteht die im Folgenden beschriebenen Operatoren und Funktionen. Diese werden Datenbank-spezifisch umgesetzt und können bedenkenlos in selbst formuliertem Sql verwendet werden. Funktionen, die der Parser nicht kennt, werden direkt ohne Konvertierung an die Datenbank weitergegeben. Das bedingt, dass diese Funktionen von der Datenbank verstanden werden. Ggf. Ist es in solchen Fällen nötig, selbst dafür zu sorgen, dass das Sql datenbankspezifisch formuliert wird."
  },
  "doc/sql/num-funktionen.html": {
    "href": "doc/sql/num-funktionen.html",
    "title": "Numerische Funktionen",
    "keywords": "Numerische Funktionen ABS ABS ( <Numeric Expression> ) Liefert den absoluten Betrag einer Zahl TRUNC TRUNC ( <Numeric Expression>, <Decimals> ) Schneidet eine Dezimal-Zahl auf die angegebene Anzahl Stellen ab. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server ROUND ( <Numeric Expression>, <Decimals>, 1 ) Oracle TRUNC ( <Numeric Expression>, <Decimals> ) ROUND ROUND ( <Numeric Expression>, <Decimals> ) Rundet eine Dezimal-Zahl auf die angegebene Anzahl Stellen. POWER POWER ( <Numeric Expression>, <y> ) Potenziert eine Zahl mit y SQUARE SQUARE ( <Numeric Expression> ) Quadrat eine Zahl. SQRT SQRT ( <Numeric Expression> ) Quadratwurzel einer Zahl CEILING CEILING ( <Numeric Expression> ) Rundet eine Zahl auf. FLOOR FLOOR ( <Numeric Expression> ) Rundet eine Zahl ab. LOG LOG (<Float Expression> ) Natürlicher Logarithmus einer Fließkommazahl. LOG10 LOG10 ( <Float Expression> ) Logarithmus mit der Basis 10. EXP EXP ( <float Expression> ) Gibt den exponentiellen Wert des angegebenen float-Ausdrucks zurück. (e x ) SIN SIN ( <float Expression> ) Sinus einer Fließkommazahl. TAN TAN (<Float Expression> ) Tangens einer Fließkommazahl. SIGN SIGN ( <Number> ) Gibt das Vorzeichen der Zahl zurück. Negativ -> -1, 0 -> 0, positiv -> +1."
  },
  "doc/mlkey/woerterbuch.html": {
    "href": "doc/mlkey/woerterbuch.html",
    "title": "Wörterbuch",
    "keywords": "Wörterbuch Alle mehrsprachigen Texte der Anwendung werden in einem zentralen Wörterbuch abgelegt. Organisiert werden die Einträge mit einem eindeutigen alphanumerischen Schüssel - dem MLKey . Die MLKeys und deren Texte können folgendermaßen genutzt werden: In den MLString -Properties überall in Framework Studio Im selbst geschriebenen Methoden-Code (siehe Programmierung ) In den Code-Messages (Exceptions, Message-Boxen) Multilanguage Text Editor Die Bearbeitung des Wörterbuchs erfolgt über den Multilanguage Text Editor . Dieser wird über das Menü Tools / Multilanguage Text Editor geöffnet. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Die Bearbeitung des Wörterbuchs funktioniert ohne Checkout-Mechanismus. Wenn mehrere Benutzer zur gleichen Zeit an denselben MLKeys arbeiten sollten, dann gewinnt derjenige, der zuletzt den Button Save drückt. Der Editor sammelt alle vorgenommenen Änderungen (Add, Edit, Delete) im Hintergrund. Mit dem Button Save werden diese in das Repository gespeichert. Dabei wird in einer Transaktion zuerst der aktuelle Stand frisch aus dem Repository gelesen, dann die Änderungen erneut auf diesen (evtl. durch einen anderen Benutzer veränderten) Stand angewendet und zuletzt der neue Stand wieder zurück in das Repository gespeichert. Das hat die Folge, dass nach einem Save Änderungen sichtbar sind, die zuvor von einem anderen Benutzer vorgenommen wurden. Eine Ausnahme sind die Basis-Packages. Diese werden aus einem Stand gezogen, den der FrameworkCompiler zum Zeitpunkt des Compile-Laufs in den Workspace gespeichert hat. Suchen von MLKeys Essentiell für die tägliche Arbeit ist das Auffinden von existierenden MLKeys. Dazu wird das Search Feld angeboten. Die Suche scannt alle Felder des MLKeys: MLKey, Comment, Obsolete, Texte. Die Groß-Klein-Schreibung wird nicht berücksichtigt. Es können mehrere Worte eingegeben werden. Dann müssen alle Worte oder Wortteile in irgend einem Feld auftauchen. z.B. MSG_ Artikel Save sucht nach Messages die mit Artikel und Save zu tun haben. Generell wird nach Wortteilen gesucht. Wenn man das Wort oder den Text in Anführungszeichen setzt, wird nach einem exakten Treffer und ganzen Worten gesucht. Das funktioniert auch mit mehreren Worten und in Kombination mit der normalen Suche. z.B. LBL_ \"Kunde\" Ziel des Wörterbuches ist es, Texte wiederzuverwenden und die Anzahl der Einträge auf das Nötigste zu reduzieren. Aus diesem Grund sollte man immer zuerst nach einem MLKey suchen, bevor man einen neuen erfasst. Zu einem logischen Begriff sollen keine zwei MLKeys existieren. Tip Die Suche sollte durchaus kreativ gestaltet werden - besonders bei Texten die eigentlich schon vorhanden sein müssten. Ein Beispiel dafür ist das Wort Einfügen . Möchte man dieses mit der englischen Bezeichnung Add nutzen, stellt man fest, dass es Einfügen schon mit mehreren Übersetzungen gibt, jedoch keine mit der englischen Bezeichnung Add . Sucht man dann aber direkt nach Add , so findet man den statt Einfügen zu verwendenden deutschen Text Hinzufügen . Erfassen neuer MLKeys Mit dem Button Add öffnet sich ein Dialog, in dem der neue MLKey erfasst werden kann. Textfeld MLKey Hier wird der MLKey angegeben. Im Customizing-Package wird der Package-Code automatisch vorbelegt. Note Der MLKey kann zu einem späteren Zeitpunkt nicht mehr geändert werden. Der MLKey kann frei vergeben werden, es gibt jedoch ein paar Regeln und Empfehlungen: Es handelt sich um einen C#-Identifier, der auch im Quellcode verwendet wird. Buchstaben, Zahlen, Unterstrich Groß-Klein-Schreibung ist relevant Der sprechende Name sollte sich nach Möglichkeit an den englischen Text anlehnen. z.B. LBL_Article Wenn der Text zu komplex ist - z.B. bei Messages oder Tooltips, dann kann der Name eine Guid enthalten. Diese kann mit dem Button Generate Guid angefügt werden. z.B. MSG_1c9f3024dfc340dfba0651cb92d90ad6 In Customizing-Packages erhält der MLKey einen Package-Code. Dieser wird automatisch vorbelegt. z.B. LBL_K87_SpecialArticle In der eNVenta/WS Standard-Entwicklung sind entsprechende Namensregeln einzuhalten. Wird dieser Dialog aus der MLKey-Suche heraus geöffnet, dann wird abhängig vom jeweiligen Context auch ein passender Präfix vorbelegt: LBL_ / LBL_<PackageCode>_ : Der Suchdialog wurde z.B. aus einem Caption- oder Default-Label-Property aufgerufen. TTT_ / TTT_<PackageCode>_ : Der Suchdialog wurde aus dem Tooltip-Property aufgerufen. MSG_ / MSG_<PackageCode>_ : Der Suchdialog wurde aus dem MessageBox- bzw. Exception-Wizard aufgerufen. Feld Comment Der Kommentar beschreibt bei Bedarf den MLKey genauer. Das ist sinnvoll, wenn der Text oder auch der MLKey erklärungsbedürftige Abkürzungen beinhaltet oder wenn es ähnliche Texte mit verschiedenen Verwendungszwecken gibt. Textfeld Obsolete Ein MLKey kann durch die Eingabe einer Obsolete-Message als veraltet markiert werden. Der Compiler wird bei Verwendung dieses MLKeys diese Message als Warning ausgeben. Weil das Löschen von MLKeys vor allem im Hinblick auf Customizing-Packages Compile-Errors erzeugt, sollte davon abgesehen und stattdessen diese Obsolete-Message verwendet werden. Ein Hinweis auf einen alternativ zu verwendenden MLKey ist empfehlenswert. Textfeld German Die Eingabe eines deutschen Textes ist Pflicht, weil Deutsch immer der letzte Fallback ist, wenn eine Fremdsprache nicht gepflegt ist. Fremdsprachen Über die Radio-Buttons kann festgelegt werden, welche Sprache im 2. Textfeld angezeigt oder bearbeitet werden soll. Diese Texte sind optional. Die angebotenen Fremdsprachen und deren Reihenfolge kann in den Options mit der Einstellung Languages in designer eingestellt werden. German lässt sich in diesem Dialog aber nicht steuern - diese Sprache wird immer im separaten Feld angezeigt. In der eNVenta/WS Standard-Entwicklung muss der englische Text gepflegt werden. Button Untranslatable Es gibt Texte, die nicht übersetzt werden können wie z.B. Eigennamen oder Einheiten. Dieser Button löscht alle Fremdsprachen-Texte und Schreibt den Text untranslatable in das Comment Feld. Mit der Routine MLKeys Cleanup ist es möglich, systematisch nach Texten zu suchen, die dafür geeignet sind. Bearbeiten von MLKeys Mit dem Button Edit wird für den selektierten MLKey der Bearbeitungs-Dialog geöffnet. Durch einen Doppelklick in das Grid kann der Bearbeitungs-Dialog ebenfalls geöffnet werden. Dabei wird der Fokus automatisch in das Feld gesetzt, das der angeklickten Grid-Zelle entspricht. Das ist praktisch, wenn man z.B. gezielt eine Fremdsprache bearbeiten möchte. Außerdem können einzeilige Texte direkt im Grid bearbeitet werden. Note Die logische Bedeutung des MLKeys darf zu einem späteren Zeitpunkt nicht mehr geändert werden. Der Dialog ist gleich aufgebaut wie der Add-Dialog. Es werden zusätzlich das Create Date des MLKeys und die Edit -Informationen der Fremdsprachen-Texte (Datum und Benutzer der letzten Bearbeitung) angezeigt. Note Der Benutzer wird bei alten Texten ggf. nicht angezeigt, weil dieses Feature erst zu einem späteren Zeitpunkt implementiert wurde. Der MLKey kann nicht bearbeitet werden. Wird im Customizing-Package ein MLKey aus dem Basis-Package geöffnet, dann sind einige weitere Felder für die Bearbeitung gesperrt: Comment / Button Untranslatable , Obsolete Die Texte können bearbeitet werden. Mit dem Button View History wird ein weiteres Fenster geöffnet, in dem die Version des Eintrages vor der letzten Bearbeitung angezeigt wird. Siehe Abschnitt History . Copy Entry / Paste Entry Wenn man ein oder mehrere Einträge selektiert hat, kann man mit dem Button Copy Entry diese in die Zwischenablage kopieren. Mit dem Button Paste Entry können diese Einträge z.B. in einer anderen Version des Packages eingefügt werden. Intern benutzt diese Funktion den Import- / Export-Mechanismus . Dieser verwendet ein XML im TMX-Format. Dadurch ist es möglich, das XML vor dem Paste Entry bei Bedarf in einem Text-Editor zu manipulieren, z.B. um den PackageCode des MLKey anzupassen. Mit Paste Entry werden neue MLKeys hinzugefügt. Enthält die Zwischenablage existierende Keys, dann wird vor dem Einfügen ein Auswahl-Dialog angezeigt. Ignore : Es werden keinerlei Einträge ersetzt. Lediglich unbekannte, neue MLKeys werden hinzugefügt. Replace : Es wird der komplette existierende Eintrag ersetzt. Wenn in der Zwischenablage ein Wert nicht gesetzt ist, dann wird dieser entfernt. Merge : Die beiden Einträge werden zusammengeführt. Dabei gewinnt jeweils der Text mit dem neueren Edit-Date. Mit dem Button Cancel wird die komplette Aktion abgebrochen. Dann werden auch keine MLKeys hinzugefügt. Customizing Jedes Customizing-Package verwaltet sein eigenes Wörterbuch. Es können neue MLKeys angelegt werden. Diese müssen den Package-Code enthalten, damit es in Zukunft keine Kollisionen mit Basis-Packages gibt. Bevor ein neuer MLKey angelegt wird, sollte immer geprüft werden, ob es nicht doch einen passenden MLKey gibt. Texte aus Basis-Packages können überschrieben bzw. ergänzt werden. So können z.B. Übersetzungen für Fremdsprachen gepflegt werden. Es muss darauf geachtet werden, dass die Bedeutung des MLKeys nicht geändert wird, weil dieser ggf. an mehreren Stellen in der Anwendung verwendet wird. Wird an einer bestimmten Stelle in der Anwendung ein anderer Text benötigt (in eNVenta kann das z.B. der Text \"Code1\" sein, der ersetzt werden soll) dann muss an dieser Stelle (jedoch möglichst weit unten in der DBColumn oder Metadatentyp) ein anderer MLKey zugeordnet werden. (siehe auch MLString-Vererbung ) Im Customizing-Package übersetzte Texte können exportiert und in das Basis-Package importiert werden. Zu einem späteren Zeitpunkt können die dann redundanten Übersetzung mit der MLKeys Cleanup Routine bereinigt werden. History Bei jeder Bearbeitung im Wörterbuch wird die Vorgänger-Version des MLKeys in einen separaten History-Bereich geschrieben. Aus dem Edit-Dialog heraus kann diese Information mit dem Button View History geöffnet werden. Gibt es keine Informationen, ist der Button deaktiviert. Die History arbeitet pro Sprache. Wird z.B. der englische Text bearbeitet, wird auch nur der alte englische Text mit seinem alten Änderungs-Datum in den History-Bereich übertragen. Die History-Informationen der anderen Sprachen bleiben unverändert. Eine leere Eigenschaft wird nicht historisiert - das gilt insbes. für Comment und Obsolete Message . Wird eine dieser Eigenschaften geleert, dann verbleibt der alte Text auch dann in der History, wenn später wieder ein neuer Text gesetzt wird. Wird ein MLKey gelöscht , wird der komplette Eintrag mit allen Sprachen in die History übertragen. Dieser kann jedoch zu einem späteren Zeitpunkt nicht mehr ohne weiteres gegriffen werden. Tip Wurde ein MLKey versehentlich gelöscht und es gibt einen Compile-Error mit dem entsprechenden MLKey, dann kann man diesen Eintrag wieder neu im Wörterbuch anlegen. Beim anschließenden Bearbeiten des MLKeys können dann die noch existierenden History-Informationen eingesehen werden. Gefüllt wird die History mit dem Save -Button. Framework Studio sammelt alle im Wörterbuch vorgenommenen Änderungen und speichert diese mit dem Save -Button in einem Rutsch. Dadurch kann ein Text auch mehrfach hintereinander geändert werden. Erst nach dem Save steht der alte Text in der History. Note Beim Labeln der Package-Version wird die History-Information nicht in die neue Package-Version übernommen. Die History-Informationen berücksichtigen nur das aktuelle Package. Weil für Basis-Packages das Wörterbuch aus dem letzten Framework-Compiler-Stand gelesen wird, enthält es keine History-Informationen."
  },
  "doc/mlkey/programmierung.html": {
    "href": "doc/mlkey/programmierung.html",
    "title": "Programmierung mit MLKeys",
    "keywords": "Programmierung mit MLKeys Klasse MLKeys Framework Studio generiert aus dem Wörtebuch eine Klasse MLKeys , die alle MLKeys beinhaltet. Sie wird im Compile-Schritt Ressource compiliert und steht somit in der kompletten Applikation zur Verfügung. Sie erbt die MLKeys aus dem Basis-Package - so z.B. auch die SYS_ -Keys aus dem System-Package. Die Klasse wird z.B. folgendermaßen verwendet: this.Global.GetMLText( MLKeys.LBL_Amount ); Alle Quellcodes, die mit MLKeys arbeiten, greifen auf diese Klasse zu - sowohl selbst geschriebener Methoden-Code als auch der von Framework Studio generierte Code. Dadurch findet der CSharp-Compiler alle Probleme, die im Zusammenhang mit MLKeys auftreten können: Compile-Error, wenn ein MLKey nicht mehr existiert. Auch wenn diese z.B. in einem Metadatentypen oder einem Form-Control verwendet werden. Eine Obsolete-Warning, wenn ein mit einer Obsolete-Message versehener MLKey verwendet wird. Die Obsolete-Message wird als Obsolete -Attribut vor den MLKey generiert. Eine Warning, wenn in einem Customizing-Package ein identischer MLKey definiert ist. Die generierte MLKeys -Klasse sieht in etwa so aus: public class MLKeys : BasisPackage_MLKeys { public static readonly MLKey LBL_Amount = new MLKey(\"LBL_Amount\"); public static readonly MLKey LBL_Article = new MLKey(\"LBL_Article\"); public static readonly MLKey TTT_Article = new MLKey(\"TTT_Article\"); public static readonly MLKey MSG_0da9815a719049ae806d3c0ba7d824ff = new MLKey(\"MSG_0da9815a719049ae806d3c0ba7d824ff\"); public static readonly MLKey MSG_0f2ad9d4385b49fc9667ed7eff2d925f = new MLKey(\"MSG_0f2ad9d4385b49fc9667ed7eff2d925f\"); [Obsolete(\"Please use LBL_Amount\")] public static readonly MLKey LBL_Amount2 = new MLKey(\"LBL_Amount2\"); } Warning Es sollten keine eigenen MLKey-Instanzen aus Strings erzeugt werden. Diese können vom Compiler nicht validiert werden. Code Editor Der Code-Editor bietet diverse Unterstützung bei der Arbeit mit der Klasse MLKeys . Im Intellisense werden alle MLKeys angeboten und im jeweiligen Tooltip wird zur besseren Orientierung der deutsche Text angezeigt. Fährt man mit der Maus über einen MLKey, dann wird ein Info-Tooltip mit dem deutschen Text angezeigt. Wird auf einem MLKey der Befehl Goto Definition (F12) ausgeführt, dann öffnet sich der Multilanguage Text Editor und es wird der entsprechende Eintrag selektiert. Methoden am Global-Object Das GlobalObject bietet mehrere Methoden an, mit denen ein MLKey in ein Text überführt werden kann. GetMLText(mlkey) GetMLText(mlkey, iso) GetMLKeyText(mlkey) FormatMLText(mlkey, args) FormatMLKeyText(mlkey, args) Für die Format-Funktionen wird die Client-Culture verwendet. Für die Verwendung einer spezifischen Culture gibt es entsprechende Überladungen: FormatMLText(culture, mlkey, args) FormatMLKeyText(culture, mlkey, args) cGlobal EntryPoint In der Klasse cGlobal gibt es einen zentralen Entry-Point GlobalGetMLText . Dieser wird JEDES MAL aufgerufen, wenn aus einem MLKey ein Text erzeugt wird."
  },
  "doc/mlkey/mlstring.html": {
    "href": "doc/mlkey/mlstring.html",
    "title": "MLString",
    "keywords": "MLString Framework Studio bietet eine durchgängige Unterstützung für die Mehrsprachigkeit. An allen Stellen, an denen für den Anwender sichtbare Beschriftungen, Tooltips oder Meldungstexte gepflegt werden bietet Framework Studio einen Editor zur Bearbeitung von mehrsprachigen Texten (Multi Language String / MLString ) an. Der Editor wird in Form einer Tabelle angezeigt, in der die Verschiedenen Sprachen des Textes angezeigt und bei Bedarf auch bearbeitet werden. Die fett gedruckten Angaben sind an dieser Stelle überschrieben. Die normal gedruckten Angaben sind aus dem Basis-Package oder dem Basis-Record geerbt. Siehe auch Abschnitt Vererbung . An erster Stelle steht immer der MLKey . Dieser stellt einen Verweis auf das Wörterbuch dar. Es kann direkt ein MLKey eingeben werden oder mit dem Auswahl-Button ein Such-Dialog geöffnet werden. Dabei handelt es sich um den voll funktionsfähigen Multilanguage Text Editor erweitert um eine Auswahl-Funktion. In diesem Dialog können, wenn kein passender MLKey gefunden wurde, auch ein neuer Key erfasst werden. Die Texte in den einzelnen Sprachen werden im Designer und auch zur Laufzeit der Anwendung aus dem Wörterbuch ermittelt. Die angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Important Ist ein MLKey angegeben, dann ist es davon abzuraten, einzelne Texte zu überschreiben. Im Property-Grid wird der MLString in einer Zeile dargestellt, die zur Anzeige der einzelnen Sprachen erweitert werden kann. Die einzeilige Anzeige stellt einen kombinierten Text in Format @{MLKey} - {deutscher Text} dar. In diesem Text man auch direkt mit vorangestellten @ -Zeichen einen anderen MLKey eintragen - z.B. @LBL_ArticleID . Ein MLKey kann auch (wie oben beschrieben) am entsprechenden MLKey-Eintrag eingetragen oder ausgewählt werden. Vererbung Mit den verschiedenen Records in Framework Studio werden auch die entsprechenden MLStrings vererbt. Dadurch werden im Idealfall die am Metadatentyp definierten Texte über die komplette Kette bis hin zu den Form-Controls durchgereicht. Ein vererbter Text kann an jeder beliebigen Stelle in der Kette überschrieben werden. Es gibt 2 Möglichkeiten: Einen anderen MLKey zuweisen Damit werden alle anderen Texte aus der Basis inkl. MLKeys und den überschriebenen Texten ausgeblendet. Auch wenn der neue MLKey z.B. keinen Text für fr definiert hat, wird ein in der Basis definierter fr Text ausgeblendet. Einen einzelnen Text überschreiben: Warning Darauf sollte möglichst verzichtet werden. Wenn lediglich die Übersetzung gepflegt wird, dann erfolgt dies besser im Wörterbuch. Wenn eine abweichende Bedeutung gewünscht ist, dann sollte ein anderer MLKey angegeben werden. Das überschreibt nur den Text der entsprechenden Sprache. Die anderen nicht überschriebenen Sprachen werden weiter aus der Basis gezogen. Caution In der eNVenta/WS Standard-Entwicklung ist das verboten. Das folgende Bild zeigt eine Vererbungs-Hierarchie. Die Pfeile stellen den Weg dar, über den der Text für das Control ermittelt wird. Dabei wird hier die Sprache fr mit den Fallback-Sprachen en und de verwendet. Der erste Text der auf diesem Weg gefunden wird, wird ausgegeben."
  },
  "doc/mlkey/mlkey-cleanup.html": {
    "href": "doc/mlkey/mlkey-cleanup.html",
    "title": "MLKeys Cleanup",
    "keywords": "MLKeys Cleanup MLKeys-Cleanup ist eine Wartungs-Routine, die Bereinigungen im Wörterbuch durchführt. Sie kann in der IDE über das Menu Tools / Checks / MLKeys Cleanup aufgerufen werden. Checkbox Reset identical overrides Es werden Texte gesucht, die im aktuellen Package denselben Inhalt haben wie im Basis-Package. Die Bereinigung entfernt diese Überschreibungen. Checkbox Find untranslatable (1) Es werden MLKeys gesucht, an denen die Texte in allen gepflegten Sprachen identisch sind. Es wird vorgeschlagen diese auf untranslatable zu setzen. Dazu kann der Button Untranslatable verwendet werden. Die Treffer werden als Information ausgegeben. (2) Es werden MLKeys gesucht, die als untranslatable gekennzeichnet sind, aber in Fremdsprachen einen Text besitzen. Die Treffer werden als Warnung ausgegeben. Note Es findet keine Bereinigung der Treffer statt. Dies muss bei Bedarf manuell erfolgen. Checkbox Find unused MLKeys Es werden MLKeys angezeigt, die nicht verwendet werden. Es wird dazu der komplette generierte Code nach Verwendungen von MLKeys durchsucht. Dieser Vorgang kann einige Zeit dauern, er kann aber bei Bedarf abgebrochen werden. Note Es findet keine Bereinigung der Treffer statt. Dies muss bei Bedarf manuell erfolgen. Checkbox Find missing MLKeys Es wird nach MLKeys im Code gesucht, die im Wörterbuch nicht existieren. Es wird dazu der komplette generierte Code nach Verwendungen von MLKeys durchsucht. Dieser Vorgang kann einige Zeit dauern, er kann aber bei Bedarf abgebrochen werden. Versehentlich gelöschte MLKeys können über die History wiederhergestellt werden. Button Analyze Dieser Button führt für die ausgewählten Operationen lediglich eine Analyse durch. Die gefundenen Treffer werden im Error-Fenster ausgegeben. Button Cleanup Nach einer Sichtung der mit dem Button Analyze gefundenen Treffer, kann mit diesem Button die Bereinigung ausgeführt werden."
  },
  "doc/ide/anwendung-starten.html": {
    "href": "doc/ide/anwendung-starten.html",
    "title": "Anwendung Starten / Fehlersuche",
    "keywords": "Anwendung Starten / Fehlersuche Hintergrundinformationen Application-Broker Das Brokerverzeichnis für den Application-Broker wird mit dem Button Broker Management im Application Dialog erzeugt. Dabei werden die folgenden Dateien in das Verzeichnis kopiert: Alle Ressourcen der Anwendung (z.B. Bilder) Java-Client Framework Studio Laufzeit-Assemblies Assemblies der Applikation (vom Benutzer FrameworkCompiler ) Ein Request des Clients ruft im IIS eine ASP.net Seite auf. Der IIS kopiert dann automatisch alle benötigten Assemblies aus dem Brokerverzeichnis in ein temporäres Verzeichnis und verwendet dann diese temporären Kopien, um den Request zu verarbeiten. Der Vorteil des Kopierens liegt darin, dass die original Assemblies nicht direkt vom IIS verwendet werden und dadurch auch nicht blockiert werden. Auf diese Weise wird gewöhnlich der Echtbetrieb einer Anwendung realisiert. Development-Broker Warning TODO! FSBrokerHost beschreiben Compile-Verzeichnis Beim Kompilieren der Anwendung werden alle Dateien in dieses Verzeichnis geschrieben. Das aktuell verwendete Compile-Verzeichnis kann über den Menüpunkt Compile / Open Compile Directory in Explorer geöffnet werden. Auf einem Rechner wird pro Framework Studio Entwickler, pro Package und pro Package-Version je ein eigenes Compile-Verzeichnis verwendet. Falls das aktuell zu verwendende Verzeichnis beim Start von Framework Studio noch nicht existiert, wird es automatisch angelegt. In den Compile-Verzeichnissen existieren immer die folgenden Unterordner: bin: Enthält alle Assemblies und ggf. Textdateien mit den benutzten Referenzen src: Enthält alle Source Dateien, die von Framework Studio generiert wurden. Durch das Kompilieren dieser Dateien werden die Assemblies der Anwendung (im Verzeichnis bin) erzeugt. Anwendung zum Testen starten Wenn Sie Ihre Anwendung während der Entwicklung zum Testen starten wollen, verwenden Sie dazu den Development-Broker . Dieser wird mit den Menüpunkt Compile / Run (oder mit der Taste F5 ) mit den zuletzt im [Run-Wizard](!TODO LINK) vorgenommenen Einstellungen gestartet. Wenn Sie die Einstellungen für den Start der Applikation (z.B. andere Business Datenbank verwenden) ändern möchten, öffnen Sie mit dem Menüpunkt Compile / Run… (oder der Tastenkombination Umschalt + F5 ) den [Run-Wizard](!TODO LINK). Dort können alle Einstellungen vorgenommen werden. Wenn Sie den Wizard anschließend mit Run beenden, wird die ausgewählte Applikation mit den vorgenommenen Einstellungen gestartet. Debugging Die Anwendung kann mit einem beliebigen .NET Debugger (z.B. Visual Studio) debuggt werden. Dazu müssen Sie die für Sie relevanten Teile der Anwendung Debuggable kompiliert haben ( Compile ). Dadurch werden entsprechende .cs- und .pdb-Dateien in das Unterverzeichnis \\src des Compileverzeichnisses ( Compile-Verzeichnis ) geschrieben. Nach dem Start der Anwendung muss der Debugger an den Prozess FSDevBrokerHost.exe angehängt werden (Visual Studio: Menüpunkt Debug / Attach to process ). Gegebenenfalls müssen Sie noch die relevanten .cs-Dateien im Debugger öffnen, um beispielsweise einen Breakpoint setzen zu können. Protokollieren der XML-Kommunikation In manchen Fällen ist es hilfreich, die Kommunikation zwischen Client und Broker zu analysieren. Dazu können sowohl die Anfragen des Clients (Request) als auch die Antworten des Brokers (Response) geloggt werden. Mit dem Menüpunkt Compile / Logging ... öffnen Sie den folgenden Dialog: Im Eingabefeld Directory wird das Verzeichnis angegeben, in das die Protokollierungsdaten geschrieben werden sollen. Das Verzeichnis wird beim Verlassen des Dialogs automatisch angelegt, wenn es noch nicht existiert. Der Benutzer Account, unter dem der IIS (Internet Information Services) läuft, muss Schreibzugriff auf dieses Verzeichnis haben. Es stehen vier Modi zur Auswahl: No Logging: Die Protokollierung ist abgeschaltet (Standardeinstellung) Log only last request and last response: Es werden genau zwei Dateien in das angegebene Verzeichnis geschrieben. In der einen Datei wird jeweils die letzte Anfrage des Clients gespeichert, in der anderen Datei jeweils die letzte Antwort des Brokers. Log each request and response to a unique file: Jede Anfrage des Clients und jede Antwort des Brokers wird in eine eigene Datei (mit Zeitstempel und aufsteigender Nummerierung) in das angegebene Verzeichnis geschrieben. Log each request and response to a unique file, for each token a new folder: Für jede Sitzung wird ein eigener Ordner im angegebenen Verzeichnis angelegt, in dem für jede Anfrage des Clients und für jede Antwort des Brokers eine eigene Datei geschrieben wird. Warning Es werden unter Umständen sehr viele Dateien auf der Festplatte angelegt! Diese müssen manuell wieder gelöscht werden. Die Log-Dateien können mit einem beliebigen XML-Viewer betrachtet werden."
  },
  "doc/form/control/combobox.html": {
    "href": "doc/form/control/combobox.html",
    "title": "ComboBox",
    "keywords": "ComboBox Properties/Events Actions Lazy-Loading Wenn ein Form Comboboxen beinhaltet, die sehr viele Listen-Einträge besitzen, dann kann das zu spürbaren Verzögerungen in der Anwendung führen, weil diese Listen zum einen im XML kommuniziert und auch vom Client aufbereitet werden müssen. Für diesen Fall gibt es einen neuen Mechanismus, bei dem solche Combobox-Listen erst bei Bedarf an den Client übertragen werden - und zwar dann, wenn die Combobox aufgeklappt wird. Comboboxen mit bis zu 50 Listen-Einträgen werden weiterhin komplett übertragen. Bei so kleinen Listen würde sich eine extra Anfrage an den Broker nicht rechnen."
  },
  "doc/form/control/checkbox.html": {
    "href": "doc/form/control/checkbox.html",
    "title": "Checkbox",
    "keywords": "Checkbox Properties/Events Actions"
  },
  "doc/form/control/button.html": {
    "href": "doc/form/control/button.html",
    "title": "Button",
    "keywords": "Button Properties/Events Actions"
  },
  "articles/knowledge/merhfacher-package-owner.html": {
    "href": "articles/knowledge/merhfacher-package-owner.html",
    "title": "Package-Owner in mehreren Repositories",
    "keywords": "Package-Owner in mehreren Repositories Framework Studio ist dafür konzipiert, dass ein Package über seine komplette Lebensdauer in genau einem Repository entwickelt wird - man darf also grundsätzlich nur in einem einzigen Repository der Owner sein. Insbesondere gilt das für Funktions-Packages, die exportiert werden und in einem Ziel-Repository zum Einsatz kommen. Caution Wird ein Funktions-Package in mehreren Repositories gleichzeitig entwickelt - ist man also Owner in mehreren Repositories , dann erzeugt das Kollisionen im Ziel-Repository . Werden Versionen desselben Packages aus mehreren Quell-Repositories in ein Ziel-Repository importiert, vermischen sich dabei die Änderungen aus beiden Repositories und verursachen Kollisionen. Besonders problematisch ist, solche Kollisionen erst nach dem Package-Import im Ziel-Repository auftreten. Im besten Fall führen sie dort unmittelbar beim Compile zu Fehlermeldungen und können so relativ schnell erkannt werden. Je nach Situation kann es auch passieren, dass solche Probleme erst zur Laufzeit in der Anwendung zutage treten und dort z.B. durch einen fehlerhaften Methoden-Inhalt zu Fehlverhalten führen. Solche Kollisionen können unmittelbar auftreten - sie treten eventuell aber auch erst zu einem viel späteren Zeitpunkt auf. Diese Kollisionen können sich z.B. folgendermaßen auswirken: Es existieren Unter-Elemente (z.B. Component-Properties) die dort nicht hingehören. Eine Methode hat den falschen Inhalt (aus der anderen Package-Version) Es fehlen Unter-Elemente (weil sie in der anderen Package-Version gelöscht wurden) ... Technischer Hintergrund In Framework Studio werden die Elemente mit einem fortlaufenden Zähler versioniert. Bei einem Check-Out wird die neue Versions-Nummer des Elementes mit Max+1 ermittelt. Dabei teilen sich alle Versionen eines Packages denselben Nummernkreis der Versions-Nummern. Beispiel: Wird in der Package-Version \"2.0\" ein Element ausgecheckt erhält es die Versions-Nummer 7, wird im Anschluss in der Package-Version \"3.0\" dasselbe Element ausgecheckt erhält es die Versions-Nummer 8. Wird diese Aktion in 2 jedoch verschiedenen Repositories durchgeführt, dann erhalten die Elemente in beiden Package-Versionen \"2.0\" und \"3.0\" dieselbe Versions-Nummer 7. Alle z.B. neu angelegten Component-Properties erhalten ebenfalls die Versions-Nummer 7. Importiert man diese beiden Package-Versionen \"2.0\" und \"3.0\" in dasselbe Ziel-Repository, dann ist dort die Versions-Nummer 7 ein Mix aus den Änderungen in beiden Package-Versionen. Spielregeln bei mehreren Repositories Grundsätzlich darf es nur ein Repository geben, indem man Owner ist. Wird von dieser Regel abgewichen, dann bedeutet das einen erhöhten organisatorischen Aufwand und es müssen einige Spielregeln beachtet werden. Wird von diesen Regeln abgewichen hat das Kollisionen zur Folge, die nur mit enormen Aufwand zu bereinigen sind. Versions-Nummern separieren Die Kreise der Versions-Nummern müssen voneinander separiert werden. Das erfolgt, indem in einem der beiden Repositories - idealerweise dem \"neueren\" - alle Versions-Nummern um den Wert 5000 erhöht werden. Es gibt dafür eine Funktion im Package-Manager: In der Datei FrameworkStudio.exe.config im Programm-Verzeichnis den folgenden Config-Schalter ergänzen: <?xml version=\"1.0\"?> <configuration> <appSettings> <!-- Aktivate PackageManager - Menu Tools / Lift Element Versions --> <add key=\"VersionLiftActive\" value=\"true\" /> ... Den Package-Manager starten und am \"neuen\" Repository anmelden Das gewünschte Package auswählen Menü Tools / Lift Element Versions (increase all Versions with 5000) ausführen. Im alten Repository keine Package-Version löschen Im alten Repository dürfen keine Package-Versionen mehr gelöscht werden, weil dies erneut Kollisionen im Ziel-Repository verursacht. Package-Versionen sollten statt dessen mit einem entsprechenden Kommentar durch Lock für eine weitere Bearbeitung gesperrt werden. Beim Löschen einer Package-Version werden die Versions-Nummern ebenfalls angehoben. Das ist notwendig, weil bei der Lösch-Aktion ggf. Versions-Nummern gelöscht werden, die bei einem späteren Check-Out in einer anderen Version des Packages erneut verwendet werden und so Kollisionen erzeugen. Wird also im \"alten\" Repository eine Package-Version gelöscht, dann werden die Versions-Nummern auf denselben Wert angehoben wie im neuen Repository. Das produziert in der Folge Kollisionen. Kollision bereinigen Ist in einem Ziel-Repository ein Kollision aufgetreten, muss diese behoben werden. Wird die Kollision sehr schnell erkannt, sollte man darüber nachdenken, ggf. eine Sicherung des Repositories zurückzuspielen. Anschließend muss dann eine korrigierte Variante der Package-Version importiert werden. Ist das zurückspielen der Sicherung keine Option, weil z.b. im eigenen Package Änderungen vorgenommen wurden, dann kann dies auf die Folgende Weise behoben werden: In den Quell-Repositories die Versions-Nummern separieren und die Package-Versionen neu exportieren Im Ziel-Repository alle Versionen des betroffenden Packages löschen. Saubere Stände der Package-Versionen neu importieren."
  },
  "articles/requirements.html": {
    "href": "articles/requirements.html",
    "title": "Systemvoraussetzungen",
    "keywords": "Systemvoraussetzungen Entwicklungs-Rechner Ein Rechner auf dem mit der Framework Studio IDE entwickelt wird bzw. ein Rechner oder Server auf dem der Framework-Compiler ausgeführt wird. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows 10 - mind. Version 18.03 Windows 8.1 Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 .NET Framework .NET Framework 4.8 - oder höher https://dotnet.microsoft.com/download/dotnet-framework/net48 Weitere Software Java-Runtime Crystal Reports Runtime Crystal Reports Designer Visual Studio: empfohlen zum Debuggen von Anwendungen Visual Studio 2017 oder höher Andere Versionen können auf eigene Verantwortung in den IDE-Options konfiguriert werden. Anwendungs-Server Rechner, auf dem Broker oder mit Framework Studio veröffentlichte Services laufen. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 Client-Betriebssysteme: Ein Broker oder Service kann prinzipiell auf einem Client-Betriebssystem (Windows 8.1, Windows 10) installiert werden. In einer Produktiv-Umgebung wird aber dringend der Einsatz eines o.g. Server-Betriebssystems empfohlen. Auf Client-Betriebssystemen können nur sehr wenige Benutzer parallel arbeiten. .NET Framework .NET Framework 4.8 - oder höher Weitere Software Crystal Reports Runtime IIS Print-Server Der Print-Service benötigt eine Verbindung zur Runtime-Repository-Datenbank und er muss die gewünschten Drucker ansprechen können. Er wird nicht von der Anwendung direkt kontaktiert, deshalb kann auch ein Client-Betriebssystem verwendet werden. Print-Service Die hier aufgeführten Systemvorrausetzungen gelten für den Print-Service Version 4.2. Framework Studio ist kompatibel mit älteren Versionen des Print-Service. Kommen diese zum Einsatz, gelten die Systemvorrausetzungen für die jeweilige Version. Framework Studio Print-Service 4.0.16 Framework Studio Print-Service 3.11 Betriebssystem siehe Entwicklungs-Rechner Es wird der Einsatz eines 64-Bit Betriebssystems empfohlen. Wenn z.B. ein spezieller Drucker-Treiber nur unter 32-Bit funktioniert, kann der Print-Service auch unter 32-Bit eingesetzt werden. Weitere Software Crystal Reports Runtime .NET Framework 4.8 - oder höher Einer der folgenden PDF Reader, wenn der PDF-Print-Adapter verwendet werden soll. Adobe Reader https://get.adobe.com/de/reader/ Foxit Reader https://www.foxitsoftware.com/de/pdf-reader/ Sumatra PDF https://www.sumatrapdfreader.org/ Microsoft Office 2003 oder höher, wenn der MSOffice-Print-Adapter verwendet wird oder bei der Benutzung einer Faxsoftware (z.B. Tobit-Fax). Open Office, wenn der OpenOffice-Print-Adapter verwendet wird. Authentication-Server Authentication-Service Framework Studio Authentication-Service 4.0 Betriebssystem siehe Anwendungs-Server Weitere Software .NET Framework 4.5 oder höher Oracle-Client Client-Rechner Rechner, auf dem die Anwendung mit dem Java-Client ausgeführt wird. Betriebssystem An das Betriebssystem werden grundsätzlich keine besonderen Anforderungen gestellt. Entscheidend ist, dass die Java-Runtime verfügbar ist. Je nach Framework-Studio-Anwendung kann es ggf. weitere Einschränkungen geben. Windows 10 Windows 8.1 Windows 8 Windows 7 SP1 Windows Vista SP2 Windows Server 2012 Windows Server 2008 Ubuntu Linux Mac OS X 10.9 Weitere Software Java-Runtime Crystal Reports Designer - sofern Reports bearbeitet werden sollen Je nach Framework-Studio-Anwendung ggf. weitere Software Java-Runtime Die Java Laufzeit-Umgebung wird benötigt am Client-Rechner und auf dem Entwicklungs-Rechner zur Ausführung der Anwendung. Windows-Rechner Framework Studio Client Launcher Der Clint Launcher ist im Requirements-Paket enthalten. Andere Betriebssysteme Java 8 mit Java Web-Start Auf anderen Betriebssystemen wie Linux oder MacOS wird die Java Runtime benötigt. Crystal Reports Runtime Diese Runtime wird benötigt auf dem Anwendungs-Server, dem Print-Service und dem Entwicklungs-Rechner. SAP Crystal Reports Runtime engine for .NET Framework 13.0.9 oder höher. Das Requirements-Paket enthält die Runtime in der Version 13.0.18. Bei 64Bit-Betriebssystemen muss die 64Bit-Version der Runtime verwendet werden. Crystal Reports Designer Der Crystal Reports Designer wird für die Bearbeitung der Crystal Reports auf dem Entwicklungs-Rechner benötigt und sofern erforderlich auch auf dem Client-Rechner. Crystal Reports 2008 Datenbank-Server Microsoft SQL Server 2014 - oder höher (Standard / Enterprise / BI) Microsoft SQL Server 2012 SP1 (Standard / Enterprise / BI) Die Express- und Developer-Editionen des SQL Server können zu Entwicklungs- und Test-Zwecken eingesetzt werden. Dabei sind aber entsprechende funktionale und lizenzrechtliche Einschränkungen seitens Microsoft zu beachten. Der Einsatz erfolgt auf eigene Verantwortung. Oracle 12.2 - oder höher (Standard / Enterprise) Es ist kein Oracle Client erforderlich. Framework Studio bringt mit dem Oracle Managed Provider eine eigene Client-DLL mit."
  },
  "articles/requirements-package.html": {
    "href": "articles/requirements-package.html",
    "title": "Requirements-Paket",
    "keywords": "Requirements-Paket Die Requirements für Framework Studio stehen in einem separaten Download zur Verfügung. FS4.2.0_Requirements_64Bit.zip FS4.2.0_Requirements_32Bit.zip Die Requirements werden benötigt, wenn Sie das erste mal eine Installation von Framework Studio durchführen. Damit die Installation der Requirements direkt von der Setup.exe angestoßen werden kann, kopieren Sie den Ordner Requirements (samt Inhalt) aus dem entsprechenden Paket direkt in den Ordner mit der Setup.exe. Die Struktur der Ordner muss dann folgendermaßen aussehen: FS_4.2.x_Setup_x64\\ FS_4.2.x_Setup_x64.exe Neuheiten.pdf Requirements_Readme.txt Requirements\\ CRRuntime_64bit_13_0_18.msi ... Enthaltene Bestandteile .net Framework 4.8 ndp48-web.exe Es wird empfohlen, diesen Web-Installer auszuführen. Damit erhalten sie automatisch die aktuellste Version und das passende Sprachpaket. ndp48-x86-x64-allos-enu.exe Der Offline-Installer spart den Download der Runtime. Er beinhaltet das .net Framework in englischer Sprache und die Version ist ggf. nicht mehr die aktuellste. Bei Bedarf gibt weitere Pakete direkt von Microsoft unter https://dotnet.microsoft.com/download/dotnet-framework/net48 Das .net Framework 4.8 muss installiert werden, bevor die Setup.exe ausgeführt wird. Es muss auf den folgenden Rechnern installiert werden: Anwendungs-Server Authentication-Server Print-Server Entwicklungs-Rechner Crystal Reports Runtime 64Bit: CRRuntime_64bit_13_0_18.msi 32Bit: CRRuntime_32bit_13_0_18.msi Die SAP Crystal Reports Runtime dient zur Aufbereitung der Druck-Belege. Sie muss auf den folgenden Rechnern installiert werden: Anwendungs-Server Print-Server Entwicklungs-Rechner FS Client Launcher 64-Bit: FSCL_4.0.14_Setup_x64.exe 32-Bit: FSCL_4.0.14_Setup_x86.exe Der Framework Studio Client-Launcher beinhaltet eine Java-Runtime zum Ausführen des Java-Clients. Er muss auf folgenden Rechnern installiert werden: Alle Rechner, auf denen die eNVenta-Anwendung ausgeführt wird Entwickler-Rechner zum Ausführen der Anwendung ggf. Anwendungs-Server, sofern auf ihnen die Anwendung ausgeführt werden soll"
  },
  "doc/sql/alpha-funktionen.html": {
    "href": "doc/sql/alpha-funktionen.html",
    "title": "Alphanumerische Funktionen",
    "keywords": "Alphanumerische Funktionen LENGTH LENGTH ( <text> ) Liefert die Länge des Ausdrucks LOWER LOWER ( <text> ) Text in Kleinbuchstaben. UPPER UPPER ( <text> ) Text in Großbuchstaben. LTRIM LTRIM ( <text> ) Schneidet die linken Leerzeichen der Zeichenkette ab. RTRIM RTRIM ( <text> ) Schneidet die rechten Leerzeichen der Zeichenkette ab. REPLACE REPLACE ( <text>, <search text>, <replace text> ) Ersetzt im übergebenen Text den Search-Text durch Replace-Text. SUBSTRING SUBSTRING ( <text>, <number start>, <number length> ) Gibt den Teil einer Zeichenkette zurück."
  },
  "doc/sql/aggr-funktionen.html": {
    "href": "doc/sql/aggr-funktionen.html",
    "title": "Aggregat-Funktionen",
    "keywords": "Aggregat-Funktionen COUNT COUNT ( <Expression> ) Liefert die Anzahl. MIN MIN ( <Expression> ) Liefert das Minimum. MAX MAX ( <Expression> ) Liefert das Maximum. SUM SUM ( <Number Expression> ) Liefert den Summe. AVG AVG ( <Number Expression> ) Liefert den Durchschnitt. VAR VAR ( <Number Expression> ) Liefert die Varianz. STDEV STDEV ( <Number Expression> ) Liefert die Standardabweichung."
  },
  "doc/resources/resources.html": {
    "href": "doc/resources/resources.html",
    "title": "Resources",
    "keywords": "Resources Allgemeines Ressourcen ermöglichen dem Entwickler, der Anwendung beliebige Dateien zur Verfügung zu stellen. Typische Beispiele für Ressourcen sind: von der Anwendung benötigte Bilder Custom Control Erweiterungen auf der Seite der Clients externe Bibliotheken (dlls), die von der Anwendung benutzt werden Bedeutung von Namespaces für Ressourcen Ressourcen können im Objekt-Baum ( Registerkarte Namespaces ) im Namespace FSGeneral / Resources angelegt werden. Beim Kompilieren von Ressourcen werden diese dann direkt ins Brokerverzeichnis kopiert. Außerdem können im Namespace FSGeneral / Resources weitere Namespaces angelegt werden. Diese Namespaces werden beim Kompilieren von Ressourcen automatisch als Unterverzeichnisse im Brokerverzeichnis angelegt, sobald sie eine Ressource enthalten. Die Ressourcen eines Unter-Namespaces werden dann ins entsprechende Unterverzeichnis des Brokers kopiert. Erstellen und Löschen von Ressourcen Für das Erstellen und Löschen ist zu beachten, in welchem Namespace die Ressource angelegt werden muss ( Bedeutung von Namespaces für Ressourcen ). Ansonsten werden Ressourcen wie alle anderen Elemente angelegt. Erstellen einer Ressource Löschen einer Ressource Bearbeiten von Ressourcen Durch einen Doppelklick auf eine Ressource im Objekt-Baum wird das Designer-Fenster geöffnet. Resource: Dort können Sie mit dem Button Import File einen Dateiauswahldialog öffnen. Dort wählen Sie die Datei aus, die ins Brokerverzeichnis kopiert werden soll. Nach dem Import wird der Name der Ressource mit dem Namen der ausgewählten Datei initialisiert. Sie können diesen Namen im Textfeld Name ändern. Im nicht editierbaren Textfeld Relative Path wird der Pfad relativ zum Brokerverzeichnis angezeigt, unter dem die Datei letztendlich angelegt wird. Der Pfad ergibt sich aus dem Namespace, in dem die Ressource angelegt wurde ( Bedeutung von Namespaces für Ressourcen ) und dem Namen der Ressource. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für Ressourcen angeboten werden, finden Sie unter Allgemeine Funktionalitäten ."
  },
  "doc/print-server/print-adapter.html": {
    "href": "doc/print-server/print-adapter.html",
    "title": "Print-Adapter",
    "keywords": "Print-Adapter Auf der Register-Karte Print-Adapter können diese bearbeitet und konfiguriert werden. Es folgt eine Aufstellung der standardmäßig zur Verfügung stehenden Print-Adapter. CRYSTAL Mit diesem Adapter können mithilfe der Crystal Reports gedruckt werden. Assembly: CrystalPrintAdapter Class: PrintServer.CrystalPrintAdapter Settings: ExportFolder : Diese Einstellung kann optional zu Test- oder Debug-Zwecken angegeben werden. Es werden alle Crystal-Reports vor dem Druck als RPT-Datei incl. Daten in diesem Ordner abgelegt. Beispiel: ExportFolder = C:\\temp\\RPT-Files IMAGE Der IMAGE-Adapter dient zum Drucken von Bildern. Assembly: ImagePrintAdapter Class: PrintServer.ImagePrintAdapter Settings: -keine- PDF Mit diesem Adapter können PDF-Dateien an den Drucker gesendet werden. Der Adapter verwendet ein externes PDF-Programm zur Verarbeitung der PDF-Dateien. In diesem Adapter kann ein beliebiges Kommandozeilen-Programm verwendet werden. Für den Einsatz von Sumatra PDF , Foxit Reader oder Acrobat Reader sollte bei Class auf entsprechend optimierten Adapter umgestellt werden (siehe unten). Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter Settings: ReaderPath : Dateipfad des PDF-Programms. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Programme\\Adobe\\Reader 9.0\\Reader\\AcroRd32.exe ReaderArgs : Die Kommandozeilen-Argumente zur Ansteuerung des PDF-Programms. Darin können die Platzhalter {file} und {printer} benutzt werden. PDF - Sumatra PDF Dieser PDF-Adapter ist speziell für den Sumatra PDF Reader optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class PrintServer.PdfPrintAdapter_SumatraPDF angegeben werden. Sumatra PDF ist ein einfacher, schlanker PDF-Viewer für Windows. Er kann von der Home-Page des Herstellers http://www.sumatrapdfreader.org heruntergeladen werden. Es gibt eine Installations-Routine und eine portable Version, welche lediglich aus der SumatraPDF.exe besteht. Im Normalfall kann die 32-Bit Version verwendet werden. Die 32-Bit Version hat eine etwas bessere Performance als die 64-Bit Version. Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_SumatraPDF Settings ReaderPath : Die SumatraPDF.exe der portablen Version kann direkt in das Print-Service-Verzeichnis gepackt werden. In diesem Fall braucht kein Reader-Path angegeben werden. Wird die installierte Version von Sumatra PDF verwendet, muss der Pfad angegeben werden. Beispiel: ReaderPath = C:\\Program Files\\SumatraPDF\\SumatraPDF.exe ReaderArgs : Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = -print-to \"{printer}\" \"{file}\" -exit-on-print PDF - Foxit Reader Dieser Adapter ist speziell für den Foxit Reader optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class PrintServer.PdfPrintAdapter_FoxitReader angegeben werden. Der Foxit-Reader kann über die Homepage des Herstellers heruntergeladen werden: https://www.foxitsoftware.com/de/products/pdf-reader/ Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_FoxitReader Settings ReaderPath : Dateipfad des Foxit Reader. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Program Files (x86)\\Foxit Software\\Foxit Reader\\FoxitReader.exe ReaderArgs : Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = /t \"{file}\" \"{printer}\" Timeout : Zeitdauer in ms, die angibt, wie lange gewartet werden soll, bis der FoxitReader-Prozess beendet wird. Der Standard-Wert ist 2000 ms. Wird der PrintService als Dienst ausgeführt, dann kann es sein, dass die FoxitReader.exe nach dem Druck nicht automatisch schließt. Nach Ablauf dieses Timeouts wird ein alternativer Versuch unternommen, den Reader zu schließen. Wenn der Timeout zu kurz bemessen ist, denn wird die FoxitReader.exe zu früh geschlossen und es wird kein Ausdruck erzeugt. Für die Ermittlung eines passenden Wertes ist es sinnvoll, sich durch mehrere Tests an einen Minimal-Wert heranzutasten. Dieser sollte dann mit genug Reserve als Einstellung verwendet werden. Z.B. minimal 300 ms – Einstellung 500 ms. Beispiel: Timeout = 2000 PDF - Acrobat Reader Dieser Adapter ist für den Adobe Acrobat Reader DC optimiert. Um diesen einzusetzen, muss beim PDF-Adapter die Class „PrintServer.PdfPrintAdapter_AcrobatReader“ angegeben werden. Assembly: PdfPrintAdapter Class: PrintServer.PdfPrintAdapter_AcrobatReader Settings ReaderPath : Dateipfad des Acrobat Reader. Diese Einstellung muss angegeben werden. Beispiel: ReaderPath = C:\\Program Files (x86)\\Adobe\\Acrobat Reader DC\\Reader\\AcroRd32.exe ReaderArgs : Wenn nicht angegeben, dann wird die folgende Standard-Einstellung verwendet: ReaderArgs = /t /n /h \"{file}\" \"{printer}\" WORD Mit diesem Adapter können Word-Dateien (.doc / .docx) an den Drucker gesendet werden. Assembly: MsOfficePrintAdapter Class: PrintServer.WordPrintAdapter Warning Word hat die Einschränkung, dass es nicht von einem Dienst-Programm gesteuert werden kann / darf. Aus diesem Grund ist der WORD-Adapter standardmäßig deaktiviert. Wird der Word-Adapter aktiviert, dann sollte der Print-Service nur im Console-Modus ausgeführt werden. Settings StaticApp : Optional - mögliche Werte 0 oder 1 Beispiel: StaticApp = 1 Standardmäßig wird für jeden Druck eine eigene Instanz von Word geöffnet. Wenn der Wert mit 1 angegeben ist, dann wird beim ersten Druck eine Word-Instanz geöffnet, die auch für alle folgenden Drucke verwendet wird. Diese Einstellung kann die Performance verbessern, sie kann aber auch die Stabilität des Print-Service verringern. EXCEL Mit diesem Adapter können Excel-Dateien (.xls / .xlsx) an den Drucker gesendet werden. Assembly: MsOfficePrintAdapter Class: PrintServer.ExcelPrintAdapter Warning Der EXCEL-Adapter ist standardmäßig deaktiviert. Wird der EXCEL-Adapter aktiviert, dann sollte der Print-Service nur im Console-Modus ausgeführt werden. Settings -keine-"
  },
  "doc/ide/compile-menu.html": {
    "href": "doc/ide/compile-menu.html",
    "title": "Compile Menü",
    "keywords": "Compile Menü In den folgenden Abschnitten werden die Menüpunkte im Menü Tools beschrieben. Compile Manager Wenn viele Namespaces kompiliert werden sollen und der Kompiliervorgang durch einen Fehler unterbrochen wird, kann mit dem Compile Manager der Kompiliervorgang fortgesetzt werden. In Verbindung mit dem FC-User ist das vor allem bei Update-Szenarien sehr vorteilhaft. Mit den Buttons in der Gruppe Add Namespaces to List werden die zu kompilierenden Elemente typweise in die Liste übernommen. In der Liste auf der rechten Seite werden alle Namespaces gesammelt. Beim Erstellen der Liste wird nicht geprüft, ob ein Namespace auch tatsächlich Elemente eines bestimmten Typs (z.B. Forms) beinhaltet. Es landen immer alle existierenden Namespaces in der Liste. Diese Liste versteht sich als eine Aufgabenliste, die durch kompilieren abzuarbeiten ist. Das Abarbeiten kann auf 2 Arten erfolgen: Der Button Compile in diesem Fenster. Es öffnet sich ein ganz normales Compile-Fenster, das wie z.B. beim Compile-CheckedOut die entsprechenden Namespaces kompiliert. Durch einen herkömmlichen Kompiliervorgang (über das Namespace-Registerkarte, aus einem Element heraus und auch Compile Checked Out). Ganz gleich, von wo aus der Compile gestartet wird, immer wenn ein Namespace erfolgreich kompiliert wurde, wird dieser aus der Liste entfernt. Mit dem Button Save kann die aktuelle Liste in eine Datei gespeichert werden. Die Datei wird in das Compile-Directory geschrieben. Mit dem Button Load kann diese Liste wieder aus einer Datei eingelesen werden. Das ist nützlich, wenn Framework Studio zwischendurch verlassen werden muss. So kann nach dem Neustart dort weitergemacht werden, wo zuletzt aufgehört wurde. Mit dem Button Complete FrameworkCompiler wird der FrameworkCompiler-Vorgang abgeschlossen. Dieser Button wird nur angezeigt, wenn ein FC-User oder der FrameworkCompiler angemeldet ist. Folgende Aktionen werden ausgeführt: Prüfen, ob etwas ausgecheckt ist. Für diese Aktion muss alles eingecheckt sein. Refresh des FrameworkCompiler-Workspaces (nur wenn man als FC-User angemeldet ist). Beim Arbeiten mit dem FC-User können Elemente aus- und eingecheckt werden. Die SavedCodes und Assemblies wurden generiert und jetzt muss noch der Workspace vom FrameworkCompiler aktualisiert werden, damit dieser wieder zu den generierten Informationen passt. Das ist notwendig, wenn das Package exportiert werden soll oder anschließend andere User beim Refresh des eigenen Workspaces den vom FrameworkCompiler verwenden ( FrameworkCompiler Version and checked out im Login-Dialog). Aktualisieren des Compile-Stamps. Das beinhaltet die Information, dass der FrameworkCompiler erfolgreich gelaufen ist und sorgt dafür, dass die rote Kennzeichnung im Package-Manager verschwindet. Beim normalen Kompilieren in FrameworkStudio wird das nicht durchgeführt, weil dieser Stempel sicherstellen soll, dass ALLES kompiliert wurde. Warning Diese Aktion sollte nur dann ausgeführt werden, wenn sichergestellt ist, dass auch wirklich alles kompiliert wurde. Compile Checked Out Mit dem Menüeintrag Compile Checked Out werden alle vom Benutzer ausgecheckten Elemente kompiliert. Falls nötig, werden weitere Elemente kompiliert. Das betrifft insbesondere die folgenden Fälle: Wenn mindestens eine Component ausgecheckt ist, werden auch Interfaces und GlobalObjects kompiliert. Wenn mindestens ein Form ausgecheckt ist, werden auch Access Units mit kompiliert. Diese Funktion verwendet im Hintergrund den Compile Manager . Wenn beim Kompilieren ein Fehler auftritt, dann kann der Kompiliervorgang im Compile-Manager fortgesetzt werden. Compile Changes !TODO: muss noch genauer beschrieben. Run / Run… Mit dem Menüeintrag Run werden die Testumgebung ( Start / Stop current development FSDomain ) und ein Client für die Applikation gestartet. Es werden dazu die zuletzt im [ Run-Wizard ](!TODO LINK) vorgenommenen Einstellungen verwendet. Mit dem Menüeintrag Run… wird zunächst der [ Run-Wizard ](!TODO LINK) gestartet und anschließend die Testumgebung mit Client für die Applikation gestartet. Run Without Compile !TODO: muss noch genauer beschrieben. Run Wizards… !TODO: muss noch genauer beschrieben. Start / Stop current development FSDomain Mit dem Menüeintrag Start current development FSDomain starten Sie alle im [ Run-Wizard ](!TODO LINK) konfigurierten Dienste (Service Hosts) und den Development Broker ( Development-Broker ). Mit dem Menüeintrag Stop development FSDomain wird der Development Broker beendet. Open Client Start Page !TODO: muss noch genauer beschrieben. Development Service Host Options Mit dem Menüpunkt Development Service Host Options können die folgenden beiden Schalter gesetzt werden: Compile forces stop of Development Broker Service Host: Ist diese Option mit einem Häkchen versehen, wird der Development-Broker automatisch beendet, wenn in Framework Studio ein Kompiliervorgang gestartet wird. Andernfalls werden Sie beim Start eines Kompiliervorgangs gefragt, ob der laufende Development-Broker beendet werden soll. Die Beendung des Development-Brokers ist nötig, um kompilieren zu können. Der Schalter ist im Standard gesetzt. Autostop of Development Broker Service Host after run of application: Ist diese Option mit einem Häkchen versehen, wird der Development-Broker automatisch beendet, wenn die Testapplikation geschlossen wird. Logging Mit dem Menüpunkt Logging wird ein Dialog geöffnet, in dem alle Einstellungen zur Protokollierung der Xml Kommunikation zwischen Client und Broker vorgenommen werden. Siehe Protokollieren der XML-Kommunikation AutoCompile Report !TODO: muss noch genauer beschrieben. Open Compile Directory In Explorer Mit dem Menüpunkt Open Compile Directory In Explorer wird das Kompilierverzeichnis ( Compile-Verzeichnis ) im Windows Explorer geöffnet. Open Development Broker Directory In Explorer Mit dem Menüpunkt Open Development Broker Directory In Explorer wird das im IIS freigegebene Verzeichnis des Development-Brokers ( Development-Broker ) im Windows Explorer geöffnet. Open User Directory In Explorer Mit dem Menüpunkt Open User Directory In Explorer wird das Verzeichnis im Windows Explorer geöffnet, in dem Framework Studio benutzerbezogene Daten ablegt. Dazu gehören verschiedene Konfigurationsdateien sowie ggf. Trace- und Log-Dateien. Application… !TODO: muss noch genauer beschrieben. Get Dll‘s Mit diesem Menüpunkt können die Dll‘s vom FrameworkCompiler, die Debug-Dll’s vom aktiven Package oder die Debug-Dll’s von allen Basis-Packages in das eigene Compile-Verzeichnis geschrieben werden."
  },
  "doc/ide/application.html": {
    "href": "doc/ide/application.html",
    "title": "Application",
    "keywords": "Application Um Ihre Anwendung erzeugen zu können, müssen Sie zunächst Ihre Anwendung geeignet konfigurieren. Mit einem neuen Repository wird unter dem Namespace FSGeneral > Applications automatisch ein Application-Element angelegt. Dieses kann aus dem Namespace-Tree oder über den Menüeintrag Compile > Application aufgerufen werden. Start Workflow: Hier wird angegeben, welchen Workflow die Applikation starten soll, nachdem sie gestartet wurde. Export: Über dieses Häkchen wird definiert, ob die Application bei einem Package-Export mit exportiert werden soll oder nicht. Registerkarte Broker General Supports Html Client Mit dieser Checkbox kann definiert werden, ob die Application mit dem HTML-Client gestartet werden kann. Ist die Checkbox gesetzt, dann wird in der Broker-Startseite der HTML-Client angeboten. Wird der HTML-Client aktiviert, muss sichergestellt werden, dass alle Fenster, die in der Application vom Benutzer erreicht werden auch vollständig vom HTML-Client unterstützt werden. (Siehe auch HTML-Client ) Service Name Name des Services unter dem der Broker erreichbar ist. Service Address Wenn Sie in der Checkbox Service Address einen Haken setzen, können Sie im dazu gehörigen Textfeld manuell die Adresse angeben, über welche die Applikation zu erreichen ist. Directory Hier wird das Web-Verzeichnis angegeben, in welches die vom Broker benötigten Dateien kopiert werden sollen. Über den Button haben Sie auch die Möglichkeit, das Verzeichnis über einen Auswahldialog zu suchen. Configuration Hier kann die Applikation manuell erweitert werden. Registerkarte Design Auf dieser Registerkarte werden allgemeine Design-Einstellungen für die Anwendung vorgenommen. Beispiele dafür sind: Start- und Hintergrundbild Größe auf dem Bildschirm Icon der Anwendung Unterstützung von Transparenz Standardfarben (z.B. Hintergrundfarbe der Menüs) Anwendungstitel DockLayoutXml Dieses XML ist das initiale Layout für das Docking-Framework des Java-Clients. Beendet ein Benutzer den Java-Client, speichert sich dieser das aktuelle Layout auf dem Client-Rechner. Beim nächsten Programm-Start liest er es wieder ein. Ist kein Layout gespeichert – z.B. beim ersten Start der Anwendung oder nach dem Zurücksetzen des Layouts durch den Benutzer – dann zieht diese Einstellung aus der Application. Das XML muss durch den Java-Client erzeugt und darf nicht von Hand bearbeitet werden. Mit den folgenden Schritten können Sie das XML aktualisieren: Am Client-Rechner das Layout der Anwendung zurücksetzen. Wenn die Anwendung keinen Befehl dafür kennt, dann im Ordner %USERPROFILE%\\FSJavaClient\\ den entsprechenden Ordner löschen. Die Anwendung neu starten. Alle Fenster wie gewünscht anordnen. Dabei können auch Fenster aus dem Arbeitsbereich in einen Docking-Bereich platziert werden. Es sollten ausschließlich die notwendigen Fenster angeordnet werden, um unnötige Informationen zu verhindern. Achten Sie darauf, dass sich die gewünschten Fenster im Vordergrund befinden. Beenden Sie die Anwendung. Das Layout wird jetzt vom Client gespeichert. Es befindet sich im entsprechenden Ordner unter %USERPROFILE%\\FSJavaClient\\ Öffnen Sie die Datei docking.xml mit einem Editor und fügen Sie deren Inhalt in das Property DockLayoutXml ein. Registerkarte Frameset Wenn in der Checkbox Use General Frame Set ein Haken gesetzt ist, wird ein Standard-Frameset verwendet. Dieses Standard-Frameset können Sie mit dem Button General Frame Set modifizieren. Wenn in der Checkbox Use General Frame Set kein Haken gesetzt ist, können Sie ein eigenes Frame Set im Textfeld Frame Set definieren. In der Combobox legen Sie den Frame fest, in dem Formulare standardmäßig geöffnet werden, wenn für ein solches nicht explizit angegeben wird, in welchem Frame es geöffnet werden soll. Registerkarte Authentication Wenn die Benutzer der Anwendung authentifiziert werden sollen, können Sie auf dieser Registerkarte das Authentifizierungssystem von Framework Studio aktivieren und die nötigen Einstellungen vornehmen. Zum Aktivieren der Authentifizierung muss in der Checkbox Enable Authentication ein Haken gesetzt werden. Im Bereich Default Login wird der Standardbenutzer angegeben, der automatisch von der Anwendung am Authentifizierungsdienst angemeldet wird, bis sich der Benutzer mit eigenem Namen und Passwort angemeldet hat. Programmbereiche, die diesem Default-Benutzer zur Verfügung gestellt werden, können also von allen noch nicht an der Anwendung angemeldeten Benutzern eingesehen werden. Dazu muss insbesondere das Login-Fenster gehören. Default User Name Name des Standardbenutzers Default User Password Passwort des Standardbenutzers Im Bereich Application Identity werden Eigenschaften festgelegt, mit denen sich die Anwendung am Authentifizierungsdienst (als Service) anmeldet. Service Name Unter diesem Namen wird die Anwendung im Authentifizierungsdienst angezeigt. Service ID Über diese Nummer (vom Typ Guid ) wird die Anwendung eindeutig identifiziert. Wenn diese Nummer geändert wird, betrachtet der Authentifizierungsdienst diese Anwendung als eine andere Anwendung, auch wenn der Name identisch ist. Mit dem Button New Guid kann automatisch eine neue, eindeutige ID generiert werden. Warning Wenn Benutzern Rollen für eine Anwendung zugeordnet wurden und anschließend die Anwendung eine neue ID bekommt und somit als eine andere Anwendung am Authentifizierungsdienst erkannt wird, dann gelten die Rollen der Benutzer nicht für die Anwendung mit der neuen ID! Service Description In diesem Feld können Sie eine Beschreibung der Anwendung angeben. Diese Beschreibung wird im Verwaltungswerkzeug für den Authentifizierungsdienst angezeigt."
  },
  "doc/documentation/indicators.html": {
    "href": "doc/documentation/indicators.html",
    "title": "Dokumentationsstatus von Steuerelementen",
    "keywords": "Dokumentationsstatus von Steuerelementen Da die Dokumentation der Steuerelemente eines Formulars über den Designer stattfindet, ist nicht immer ersichtlich, welches Steuerelement schon eine Dokumentation beinhaltet oder ob das Steuerelement beim Rendern eine Dokumentation aus der Basis erhält. Um dies zu visualisieren, gibt es in den Framework Studio Optionen die Option Documentation Indicators . Wird diese Checkbox aktiviert, werden für alle Steuerelemente kleine Vierecke in der rechten oberen Ecke angezeigt. Die Quadrate können dabei zwei Farben annehmen: Gelb Das Steuerelement enthält in diesem Formular keine Dokumentation. Es steht aber eine Dokumentation aus der DataSource des Steuerelements (Component Property, DBColumn, Metadatentyp) oder aus einem Basis-Package zur Verfügung und würde bei einem Export ausgegeben. Grün Das Steuerelement enthält in diesem Formular eine Dokumentation. Wenn an einem Steuerelement kein Quadrat existiert, gibt es an diesem Steuerelement keine Dokumentation sowie auch keine Dokumentation aus der DataSource bzw. eines Basis-Packages."
  },
  "doc/tables/ml_config.html": {
    "href": "doc/tables/ml_config.html",
    "title": "ML_Config (Business-Datenbank)",
    "keywords": "ML_Config (Business-Datenbank) Caution Diese Tabelle ist veraltet. Die Default-Sprache kann seit Framework Studio 4.2.1 in der Datenbank-Tabelle dbRun_Config mit dem ConfigKey ML_DEFAULT_LANGUAGE definiert werden. Existiert der neue ConfigKey nicht, dann erfolgt weiterhin ein Fallback auf diese Tabelle. Es wird empfohlen die Konfiguration in die neue Tabelle zu übertragen und diese Tabelle zu löschen. Die ML-Columns arbeiten standardmäßig mit der Default-Sprache de Deutsch. Ist die \"führende\" Sprache nicht de , dann kann über diese Tabelle die korrekte Default-Sprache eingestellt werden. Das geschieht in der Business-Datenbank, wo auch die Übersetzungs-Tabelle dbRun_MLStrings abgelegt ist, welche die anderssprachigen Werte speichert. Die Einstellung muss in dieser Datenbank stehen, damit sichergestellt ist, dass die Übersetzungs-Tabelle immer mit derselben Konfiguration angesprochen wird - unabhängig davon, wie die Anwendung FS-seitig konfiguriert ist. Die Tabelle muss bei Bedarf manuell per SQL angelegt werden. Dazu können die folgenden Scripte verwendet werden. Das Iso-Sprach-Kürzel de muss entsprechend durch das gewünschte Iso-Sprach-Kürzel ersetzt werden. -- SQL-Server CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR(2), CONSTRAINT PK_ML_CONFIG PRIMARY KEY CLUSTERED (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); -- Oracle CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR2(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR2(2) NULL, CONSTRAINT PK_ML_CONFIG PRIMARY KEY (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); Caution Wenn die Konfiguration geändert wurde, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Die Konfiguration darf nicht nachträglich geändert werden, weil ansonsten die in der Übersetzungs-Tabelle abgelegten Texte nicht mehr stimmen. Wenn die Konfiguration zu Beginn bei Einrichtung der Business-Datenbank vorgenommen wird, dann muss im Anschluss sichergestellt werden, dass die Tabelle dbRun_MLStrings leer ist. Wenn bei einer Änderung der Konfiguration doch dbRun_MLStrings -Inhalte erhalten bleiben sollen, müssen alle Einträge, für die neue Default-Sprache gelöscht werden."
  },
  "doc/tables/dbrun_mlstrings.html": {
    "href": "doc/tables/dbrun_mlstrings.html",
    "title": "dbRun_MLStrings (Business-Datenbank)",
    "keywords": "dbRun_MLStrings (Business-Datenbank) In dieser Tabelle werden die Fremdsprachen-Texte für die ML-Columns abgelegt. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Spalte Beschreibung ML_TableName Der Name der Datenbank-Tabelle (Uppercase) ML_ColumnName Der Name der MLColumn-Tabellen-Spalte (Uppercase) ML_FSRowID Die FSRowID des referenzierten Datensatzes. Diese kann für SQL-Abfragen verwendet werden. ML_Iso Der 2-stellige Iso-Code der Fremdsprache (Lowercase) ML_Text Der fremdsprachige Text (Langtext) ML_SearchText Indizierte Spalte mit den ersten 200 Zeichen des fremdsprachigen Textes. Sie wird für SQL-Abfragen verwendet."
  },
  "doc/package-manager/package.html": {
    "href": "doc/package-manager/package.html",
    "title": "Packages",
    "keywords": "Packages In der Baumstruktur des Package Managers werden alle Packages des Repositories in alphabetischer Reihenfolge auf der ersten Ebene dargestellt. Durch Doppelklick auf ein Package wird ein Fenster geöffnet, in dem grundlegende Eigenschaften des Packages bearbeitet werden können. Package Eigenschaften: Name Name des Packages. Manufacturer Name des Package Herstellers. Owner Ist in der Checkbox ein Haken gesetzt, wird dadurch angezeigt, dass Sie der Eigentümer des Packages sind. Wenn Sie ein neues Package erstellen, sind Sie automatisch der Eigentümer. Warning Der Eigentümer eines Packages ist der einzige, der Lizenzen für ein Package erstellen kann. Diese Eigenschaft kann nicht geändert werden! Wenn man Eigentümer eines Packages ist und dieses zunächst exportiert, um es anschließend wieder zu importieren, ist man nicht mehr Eigentümer des importierten Packages! Package prefix Hier kann ein Präfix angegeben werden, das einheitlich bei allen neu erstellten Elementen in diesem Package dem normalen Namen voran gestellt wird. Dadurch werden Namenskonflikte zwischen verschiedenen Packages vermieden. Beispiel (Package prefix = NV1 ): Neues Form wird mit dem Namen NV1 _frm initialisiert. Damit das Präfix verwendet wird, muss außerdem die im Folgenden beschriebene Checkbox gesetzt sein."
  },
  "doc/package-manager/package-version.html": {
    "href": "doc/package-manager/package-version.html",
    "title": "Package-Versionen",
    "keywords": "Package-Versionen In der Baumstruktur des Package Managers werden unterhalb eines Packages alle definierten Entwicklungsstände (Versionen) mit dem Symbol für Version dargestellt. Durch Doppelklick auf eine Version wird ein Fenster geöffnet, in dem alle Einstellungen zu der Version vorgenommen werden können. Package Name des Package Herstellers ( nicht editierbar ). Version Name Bezeichnung der Version. Es wird empfohlen, ausschließlich gültige Versionsnummern in dem Format \"Major.Minor.Build.Revision\" (z.B. 3.11 oder 3.11.1.5) zu verwenden. Es funktionieren auch andere Versions-Bezeichnungen, allerdings können diese dann nicht korrekt sortiert werden. Version ID Die interne ID der Package-Version ( nicht editierbar ). Product Name Der Name des Produkts. Dieser kann z.B. bei Versions-Informationen innerhalb der End-Anwendung ausgegeben werden. Assembly Prefix Kürzel, welches vor die Assemblies und den internen Elementnamen (Komponenten, Forms, Tabellen, …) gehängt werden soll. Der Assembly Prefix kann nur bearbeitet werden, wenn noch kein Compiler ausgeführt wurde bzw. es noch keinen Workspace für diese Package-Version gibt. Ist das Feld gesperrt, kann diese Sperre mit dem Button Edit aufgehoben werden. Dies hat zur Folge, dass alle Workspaces für diese Package-Version und ALLE davon abhängigen Package-Versionen gelöscht werden. Anschließend müssen alle diese Package-Versionen neu kompiliert werden. Version State: Open: Die Package-Version ist offen und befindet sich in der Entwicklung. Es gibt keinerlei Einschränkungen bei der Arbeit. Bei jedem Compile mit dem FrameworkCompiler / Compile-Wizard wird ein neuer Compile-Stempel erzeugt – das bedeutet, dass alle anhängigen Package-Version ebenfalls neu kompiliert werden müssen. Sealed: Die Package-Version ist versiegelt. Es können keine Änderungen vorgenommen werden. Es kann sich kein Entwickler mehr an dieser Package-Version anmelden. Damit eine Package-Version in den Status Sealed versetzt werden kann, darf nichts mehr ausgecheckt sein und alle Änderungen müssen mit dem FrameworkCompiler / Compile-Wizard kompiliert sein. Service Release: An der Package-Version können nur Änderungen an Methoden-Inhalten vorgenommen werden – es darf keine Schnittstellen-Änderungen mehr geben. Bei einem FrameworkCompiler / Compile-Wizard bleibt der Compile-Stempel erhalten. Dadurch brauchen abhängige Package-Versionen nicht neu kompiliert werden und es ist ein sehr schneller Update möglich. Der Version State kann jederzeit geändert werden. Dabei werden entsprechende Plausibilitäten geprüft, um eine Fehl-Bedienung zu unterbinden. Button Lock Damit kann eine Package-Version gesperrt werden, damit sich niemand mehr daran anmelden kann. Mit dem Klick erscheint ein Dialog, in dem eine Begründung eingegeben werden kann. Diese Begründung wird im Login-Dialog angezeigt. Falls noch Benutzer angemeldet sind, wird dieser Dialog angezeigt. Hier gibt es die folgenden Möglichkeiten: Cancel: den Vorgang abbrechen. Retry: es erneut versuchen, nachdem z.B. dem Benutzer Bescheid gegeben wurde. Kill User Sessions: die Sitzungen der Benutzer zu beenden. Bei dieser Aktion wird 130 Sekunden gewartet. Das ist die Zeit, die im Extremfall benötigt wird, bis ein Benutzer zum Beenden seiner Sitzung gezwungen wurde. (60 Sekunden bis zur Hinweismeldung + 60 Sekunden bis zum endgültigen Abbruch + 10 Sekunden Reserve) Während dieser Dialog angezeigt wird, können sich keine neuen Benutzer mehr anmelden. Dieser Mechanismus wird automatisch verwendet, um eine Package-Version während eines Upgrades vor einer Benutzung abzusichern. Button Status… Öffnet einen Dialog zum Festlegen einer Statusmeldung, die jedem Nutzer dieser Package Version beim Einloggen und in der Entwicklungsumgebung selbst angezeigt wird. Wird kein Informationstext angegeben, so wird der Status nicht angezeigt. Ansonsten ist er an den unten aufgeführten Positionen in der Entwicklungsumgebung sichtbar. Wird in der Combobox Name ein Status ausgewählt, dann gelten die Einstellungen, die in dem entprechenden Dialog gepflegt sind und es wird, sofern vorhanden, an allen Stellen zusätzlich der als nächstes greifende Status angezeigt. Login Dialog in der Detailbeschreibung zu einer Package Version: Status Bar im FrameworkDesigner: Im Check Out Dialog: Check In Dialog: Bei Status Rot muss im Check-In Dialog zusätzlich eine Begründung eingegeben werden, bevor der Check-In möglich ist. Diese Begründung wird mit dem Zusatz #warning State Red in den Check-In-Kommentar eingefügt. Über den Menüpunkt Tools / Package Versions States im Package Manager wird dieser Dialog geöffnet. Hier können mehrere Package Version Status gepflegt werden. Wenn mehrere Status den selben Namen haben, werden sie dem Datum entsprechend nacheinander aktiv, sofern der Name an einem Package hinterlegt ist. FS Version Framework Studio Version, mit der die Package Version bearbeitet werden kann. ( nicht editierbar ) Button Upgrade Note nur aktiv, wenn die FS Version der Package-Version kleiner ist als die Version, in der der Package Manager gestartet wurde Für die Package-Version wird ein Upgrade auf die aktuelle Framework Studio Version durchgeführt. Warning Der Upgrade-Vorgang lässt sich nicht rückgängig machen. Das heißt, dass dieses Label mit älteren Framework Studio Versionen nicht mehr verwendet werden kann. Compile Run In diesem Feld kann ein Name eingegeben werden, mit dem über die FSConsole.exe gesteuert werden kann, welche Package-Versionen kompiliert werden sollen. Button Source Ctrl. History … Öffnet die Source Control History für die aktuelle Package Version. Standardmäßig werden hierbei alle Elemente angezeigt. Sowohl eingecheckte als auch ausgecheckte Elemente. Button Compile Wizard Ruft für die Package-Version den Compile Wizard auf. Auf der Registerkarte Using Hierarchy werden die Package Versionen angezeigt, die von dieser Version verwendet werden. Die Versionen werden in der Verwendungsreihenfolge angezeigt. Die Using Hierarchy kann von den Requirements wie folgt abweichen: In der Using Hierarchy können zusätzlich Labels von weiteren Packages aufgeführt werden. Von einem Label in den Requirements kann ein anderes Label des gleichen Packages in der Using Hierarchy aufgeführt werden. Auf der Registerkarte Requirements werden tabellarisch die Abhängigkeiten der Version von anderen Packages bzw. Package Versionen dargestellt, also auf welchen Packages in welcher Version das aktuelle Package aufbaut. Diese Information wird beim Import im Repository abgelegt und ist nicht veränderbar. Die Registerkarte Info stellt interne Informationen zum Kompilierstatus dar. Auf allen Registerkarten befindet sich ein Button Refresh zum Aktualisieren der dargestellten Informationen. Register Languages Auf dieser Registerkarte können die Sprachen für die Package-Version definiert werden. Eine Sprache besteht aus den folgenden Informationen: Iso-Code : Der ISO 639-1 Code der Sprache. Dieser besteht aus 2 kleinen Buchstaben - z.B. de , en . Name : Der Name der Sprache. Dieser wird in der IDE angezeigt. An einer Package-Version können beliebig viele Sprachen definiert werden. Diese werden automatisch in die abhängigen Package-Versionen vererbt. Warning Auf der Application Startseite werden nur Sprachen angeboten, für die im Wörterbuch mindestens ein MLKey übersetzt ist. Languages from Base Diese Liste zeigt die Sprachen aus den Basis-Packages an. Languages from current Package In dieser Liste können die Sprachen für die Package-Version gepflegt werden. Es können zusätzliche Sprachen definiert werden Wird eine Sprache mit einem identischen Iso-Code wie im Basis-Package angelegt, dann überschreibt der Eintrag das Basis-Package. In der IDE wird dann die überschriebene Bezeichnung der Sprache angezeigt. Note Wird eine Sprache gelöscht, dann bleiben die Übersetzungen an den Records und im Wörterbuch trotzdem erhalten."
  },
  "doc/package-manager/package-manager.html": {
    "href": "doc/package-manager/package-manager.html",
    "title": "Package Manager",
    "keywords": "Package Manager Der Package Manager von Framework Studio ist ein eigenständiges Programm. Mit diesem Tool lassen sich die folgenden Aufgaben rund um Packages erledigen: Anlegen, Löschen und Bearbeiten sowie Import und Export von Packages und Package Lizenzen Definition, welche Sprachen eine Anwendung grundsätzlich unterstützen soll Fixierung eines Entwicklungsstandes (Versionierung / Labeling) Verzweigung von Entwicklungspfaden (Branching) Folgende Funktionen stehen sowohl im Package Manager als auch in Framework Studio zur Verfügung: Runtime License Manager ([ Laufzeitlizenzen ](!TODO LINK)) Publish Wizard ([ Publish-Wizard ](!TODO LINK)) Publish2Go Wizard ([ Publish2Go Export-Wizard ](!TODO LINK)) Start des Package Managers Starten Sie den Package Manager, indem Sie im Programmverzeichnis von Framework Studio die Datei FrameworkStudioPackageManager.exe ausführen. Es erscheint der Dialog zur Auswahl eines Repositories (analog zum Start von Framework Studio [ Framework Studio start ](!TODO LINK)). Nach der Repository-Auswahl werden Sie aufgefordert, sich als FrameworkAdministrator anzumelden. Bedienung des Package Managers Nach dem Start des Package Managers erscheint das Hauptfenster. Im Hauptfenster werden über die Toolbar folgende Funktionen angeboten: New Sie erkennen New an einem -Icon. Anlegen eines neuen Packages, einer neuen Lizenz oder einer neuen Sprache. Um eine neue Sprache anlegen zu können, muss in der Baumstruktur ein Default-Package (also das unterste Package in der Package-Hierarchie einer Anwendung) ausgewählt sein, da Sprachen nur am Default-Package definiert werden. Um neue Lizenzen anlegen zu können, muss man Eigentümer eines Packages sein ( Package ). Delete Sie erkennen Delete an einem -Icon. Löschen der in der Baumstruktur ausgewählten Lizenz ( Lizenzen ), Version ( Package-Versionen ) oder Sprache ( Sprachen ). Versionen dürfen nur mit dem Package Manager der aktuellsten Framework Studio Version gelöscht werden, die im Repository zum Einsatz kommt! Save Sie erkennen Save an einem -Icon. Speichern der Änderungen am ausgewählten Element. Save All Sie erkennen Save All an einem -Icon. Speichern aller Änderungen. Label Sie erkennen Label an einem -Icon. Erzeugt eine neue Package-Version auf gleicher Ebene und versiegelt dabei die Ursprungsversion (Status= sealed ). Ausgecheckte Elemente werden dabei in die neue Version übertragen. Beispiel : Label 3.0 => 3.1 Der Status der Ursprungsversion kann anschließend bei Bedarf auf Service-Release oder wieder zurück auf Open gesetzt werden. Branch Sie erkennen Branch an einem -Icon. Erzeugt eine neue Package-Version eine Ebene tiefer und verändert den Zustand der Ursprungsversion dabei nicht. Ausgecheckte Elemente verbleiben in der Ursprungsversion. Beispiel Branch 3.0 => 3.0.2 Import Package Sie erkennen Import Package an einem -Icon. Importieren einer Package-Version. Nach dem Import ist es in der Regel notwendig, abhängige Package-Versionen zu compilieren bzw. passende Stände von abhängigen Package-Versionen zu importieren. Export Package Sie erkennen Export Package an einem -Icon. Exportieren der ausgewählten Package-Version. Import License Sie erkennen Import License an einem -Icon. Importieren einer Package Lizenz (PKL) Export License Sie erkennen Export License an einem -Icon. Exportieren der ausgewählten Lizenz Export Service Release Sie erkennen Export Service Release an einem -Icon. Exportiert den Service Release Stand der ausgewählten Package-Version. Dabei werden nur die Änderungen seit dem Eröffnen des Service Release Modus übernommen. Dadurch entstehen deutlich kleinere Dateien als beim normalen Package-Export. Import Service Release Sie erkennen Import Service Release an einem -Icon. Importiert einen Service Release Stand, welcher zuvor mit Export Service Release exportiert wurde. Durch den Import ändert sich der Compile-Stamp nicht, deshalb müssen die abhängigen Package-Version nicht neu compiliert werden. Über das Menü Tools / Publish / Wizard bzw. Tools / Publish / 2Go kann der Publish- bzw. der Publish2Go-Wizard für die ausgewählte Package-Version aufgerufen werden. Über das Menü Tools / Check Using Hierarchies des Hauptmenüs können die Abhängigkeiten der Packages überprüft werden. Über das Menü Tools / Runtime Licenses Manager kann der Runtime License Manager ([ Laufzeitlizenzen ](!TODO LINK)) für die ausgewählte Package-Version gestartet werden. In der Baumstruktur des Package Managers werden Packages , Package-Versionen , Lizenzen und Sprachen hierarchisch dargestellt. Die einzelnen Elemente werden im Folgenden genauer beschrieben."
  },
  "doc/package-manager/package-lizenz.html": {
    "href": "doc/package-manager/package-lizenz.html",
    "title": "Lizenzen",
    "keywords": "Lizenzen In der Baumstruktur des Package Managers wird unterhalb eines Packages ein Ordner Licenses angezeigt. In diesem Ordner werden alle Lizenzen des Packages mit dem Symbol dargestellt. Diese Lizenzen legen fest, wie das Package zur Entwicklung verwendet werden darf. Durch einen Doppelklick auf eine Lizenz wird ein Fenster geöffnet, in dem alle Eigenschaften der Lizenz angezeigt werden. Warning Die Eigenschaften können nach dem ersten Speichern der Lizenz nicht mehr geändert werden. Eine neue Lizenz kann über den Menüpunkt New / License angelegt werden. Anschließend können die folgenden Angaben gemacht werden: Name Name der Lizenz Customer Lizenznehmer Serial Number Frei definierbare Seriennummer Generation Date Datum, an dem die Lizenz erzeugt wurde. (nicht editierbar ) Package Package, für das die Lizenz gültig ist. (nicht editierbar ) Edit Permission Recht, wie das Package bearbeitet werden darf. Zur Auswahl stehen: ReadWithoutCode: Leserechte ohne Sourcecode. Das bedeutet, dass beispielsweise nur Methodendefinitionen, nicht der Inhalt der Methoden zur Verfügung steht. ReadWithCode: Leserechte auch auf den Sourcecode. Write: Volle Lese- und Schreibrechte. Use Permission Customizing-Recht. Zur Auswahl stehen: ReadOnly: Customizing ist nicht erlaubt CustomizeFormsAndWorkflows: Customizing für Forms und Workflows CustomizeAll: Volle Customizing-Rechte Note Lizenzen können außerdem mit dem Package Manager importiert und exportiert. Siehe dazu Bedienung des Package Managers ."
  },
  "doc/mdt/validierung.html": {
    "href": "doc/mdt/validierung.html",
    "title": "Metadatentyp-Validierung",
    "keywords": "Metadatentyp-Validierung Die Einstellungen, die am Metadatentyp zu sehen sind (z.B. Größe, Formatierung, Wertebereich, …), werden bei der Arbeit mit Properties herangezogen, um die Werte zu validieren und ggf. zu korrigieren. Auch der Client nutzt diese Informationen, um falsche Eingaben so früh wie möglich zu unterbinden. Die Zusammenhänge werden durch folgendes Schaubild erläutert: Die folgende Tabelle stellt dar, was passiert, wenn mit einem Wert gearbeitet wird, der denen am Metadatentyp definierten Kriterien nicht entspricht. Einstellung Lesen von Properties aus der Datenbank, die falsche Werte beinhalten Setzen von Properties Client Allgemein Values Value Ranges Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Strings Size Bei zu langen Strings wird auf dieser auf die Size gekürzt. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Uppercase, Lowercase Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Die Eingabe lässt nur Groß- bzw. Kleinbuchstaben zu. Format-Pattern (Regulärer Ausdruck) Es wird FSstring.Null zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Es wird zuvor noch versucht, den String mit Uppercase oder Lowercase zu korrigieren, wenn der reguläre Ausdruck selber Uppercase bzw. Lowercase ist. Wenn das funktioniert, dann wird der Wert in Uppercase bzw. Lowercase konvertiert. Numerische Werte Precision Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Scale (bei Dezimal-Zahlen) Der Wert wird „kaufmännisch“ gerundet. Der Wert wird „kaufmännisch“ gerundet. Die Eingabe wird begrenzt. Positive Integer, Negative Integer (bei Ganzzahlen) Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Das Minus-Zeichen wird bei der Eingabe unterdrückt bzw. automatisch hinzugefügt. Der Java-Client gibt bei der Eingabe eines falschen Wertes die folgenden Fehlermeldungen aus: Wenn das Format-Pattern (der reguläre Ausdruck) verletzt wird: Wenn ein Wertebereich verletzt wird:"
  },
  "doc/mdt/metadatentypen.html": {
    "href": "doc/mdt/metadatentypen.html",
    "title": "Metadatentypen",
    "keywords": "Metadatentypen Die Idee der Metadatentypen kommt daher, dass bestimmte Felder innerhalb einer Anwendung immer wieder auftauchen (z.B. Artikelnummer, Kundennummer, ...). Deshalb können solche Felder an einer zentralen Stelle definiert werden, was Fehler in der Felddefinition verhindert und Redundanzen minimiert. Dabei werden Informationen wie das Label, das Datenformat, das zugehörige Control, die mehrsprachige Bezeichnung usw. hinterlegt, so dass sich der Arbeitsaufwand bei der späteren Arbeit mit dem Metadatentypen minimiert. Sie erkennen Metadatentypen an einem - Icon vor der Bezeichnung. Metadatentypen bearbeiten Um einen Metadatatypen zu bearbeiten, doppelklicken Sie den entsprechenden Eintrag auf der Registerkarte Namespaces . Der Metadatentyp wird im Hauptfenster des Framework Designers angezeigt. Der Metadatentyp kann in verschiedenen Teilen der Anwendung zum Einsatz kommen: Er kann auf unterster Ebene der Spalte einer DBTable zugeordnet werden. Er kann in Components oder Forms als Datentyp für Properties verwendet werden. Deshalb nehmen Sie an einem Metadatentyp verschiedene Einstellungen vor: Name : Geben Sie die Bezeichnung des Metadatentyps an. Datatype Database : Benennen Sie den Datentyp der Spalte in der Datenbank. Datatype Application : Gibt den FS-Datentyp des Metadatentyps an. Dieser Datentyp wird später in den Components und Forms gezogen. Die folgende Tabelle zeigt, welche Database-Datentypen mit welchem Application-Datatype kombiniert werden können: FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring Binary X Boolean X Byte X Date X DateTime X Time X Double X Currency X X X Single X X X Decimal X X Big Int X Integer X X Smallint X X X Tiny Int X X X Ansi String X Long Varchar X String X null X X X X X X X X X X X Warning Wenn Sie die Datentypen nachträglich ändern, kann das evtl. Auswirkungen auf Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren. Die Einstellungen für Size, Precision und Scale hängen von der Auswahl des Datatype Database ab. Je nachdem, ob der Datenbank-Datentyp Zeichen, Ganzzahlen oder Gleitkommazahlen unterstützt, sind die Felder für Eingaben zugänglich. Size : Definiert die Feldlänge bei Zeichenfeldern. Precision : Anzahl der Stellen inkl. eventueller Nachkommastellen bei numerischen Feldern. Scale : Anzahl der Nachkommastellen bei Dezimal -Feldern. Format : Gibt das Anzeige-Format des Felds an. Das Format wirkt sich in der Darstellung des Felds auf einem Form aus. Format Pattern : Wird im Feld Format User Defined gewählt, ist es möglich hier selbst ein Format anzugeben. Es können Formate für Zahlen, Daten und Zeichenketten entsprechend der Standard-Definition für reguläre Ausdrücke eingegeben werden. Siehe auch Format-Pattern Registerkarte Description Hier kann eine Beschreibung des Metadatentyps eingegeben werden. Registerkarte Values Für einen Metadatentypen kann definiert werden, welche Werte er annehmen darf. Wird hier nichts angegeben, sind alle Werte möglich, die der entsprechend hinterlegte Datentyp zulässt. Es können mehrere Werte oder Wertebereiche angegeben werden. From : Gibt die untere Grenze eines Wertebereichs an. Warning Ist nur dieses Feld gefüllt (und To nicht), wird dies als Wert und nicht als Wertebereich angesehen. To : Gibt die obere Grenze eines Wertebereichs an. Button Add New Range : Mit dem Button Add New Range kann ein neuer Bereich hinzugefügt werden. Button Remove Range : Mit dem Button Remove Range kann ein Bereich gelöscht werden. Registerkarte Default Label Einem Metadatentypen kann ein Label zugewiesen werden. Dieses Label wird im Form links neben dem Control des Metadatentyps angezeigt. Das Label kann mehrsprachig hinterlegt werden. Tip Es ist möglich, dieses Label in den Components und im Form zu überschreiben. Registerkarte Control Types Die Registerkarte ControlTypes zeigt an, welche Controls später im Form zur Verfügung stehen sollen. Es ist möglich, einem Metadatentypen mehrere Controls zuzuordnen. Es kann aber maximal ein Control als Default gekennzeichnet sein. Das als Default gekennzeichnete Control wird zunächst angezeigt, wenn ein Property (welches diesen Metadatentypen verwendet) in ein Form gezogen wird. Das Default-Control kann dann auf weitere, hier hinterlegte Controls geändert werden. Diese Liste von Controls kann auch im DBTable oder in der einer Component ergänzt werden. Ist kein Control als Standard-Control hinterlegt, wird ein Editfeld angenommen. Mit dem Button Add wird ein neuer Control-Type hinzugefügt. Es öffnet sich das Fenster Assign Controls. In diesem Fenster sind alle Controls aufgelistet, einschließlich der Controls, die Sie in den Control Default Styles definieren können (siehe Kapitel Control Default Styles). Wählen Sie hier ein Control aus und setzen Sie ggf. die Checkbox is Default . Mit dem Button OK wird das Control der Liste hinzugefügt. Mit dem Button Change können Sie das Control ändern. Es öffnet sich wieder wie bei Add das Fenster Assign Controls . Sie können hier ein anderes Control auswählen und dann mit OK bestätigen. Mit dem Button Delete wird das markierte Control gelöscht."
  },
  "doc/mdt/format-pattern.html": {
    "href": "doc/mdt/format-pattern.html",
    "title": "Format-Pattern im Metadatentyp",
    "keywords": "Format-Pattern im Metadatentyp Je nachdem, welcher Datentyp ausgewählt wurde, ändern sich die Einstellungen für das Format-Pattern. Format Pattern für Zeichenketten Bei Zeichenketten können im Format reguläre Ausdrücke eingegeben werden. Die Zeichenketten müssen dann dem definierten regulären Ausdruck entsprechen. Im Java-Client wird bereits bei der Eingabe überprüft, ob die Zeichenkette dem Ausdruck genügt. Format-Pattern für Zahlen Bei Zahlen können gewöhnliche Zahlenformate eingegeben werden. Neben dem Feld Format-Pattern wird eine Beispiel-Zahl für das eingegebene Format dargestellt. Warning Es ist aber zu beachten, dass als Tausender-Trennzeichen das Komma und als Dezimal-Trennzeichen der Punkt dient. Gültige Formate wären z.B. #,##0.00 ergibt 1.234,56 0.00 ergibt 1.234,56 #,##0.00 ’EUR’ ergibt 1.234,56 EUR Format-Pattern für Datum Bei Datum können gewöhnliche Datum-Formate eingegeben werden. Neben dem Feld Format-Pattern wird als Beispiel das aktuelle Systemdatum entsprechend formatiert dargestellt. Der Button Default Values setzt die Werte auf die vom Framework Studio vorgegebenen Standardwerte zurück."
  },
  "doc/konzepte/fs-types.html": {
    "href": "doc/konzepte/fs-types.html",
    "title": "FS-Datentypen",
    "keywords": "FS-Datentypen FS-Datentypen verhalten sich fast genauso wie die .NET-Datentypen mit ähnlich lautenden Namen. Der Unterschied zu den .NET-Datentypen besteht darin, dass sie einen Null-Wert verstehen. Die FS-Datentypen sind die Basis für die Metadatentypen. Sie können aber auch als Datentyp für Properties oder einfach frei im Code verwendet werden. Sie sollten immer dann verwendet werden, wenn die Null-Information nicht verloren gehen darf. Mit diesen Datentypen ist es möglich, Null-Werte aus einer Datenbank auszuwerten und auch wieder in die Datenbank zurückzuschreiben. Außerdem können z.B. Datenfelder in Forms, die eine Zahl oder ein Datum enthalten, komplett leer sein, was z.B. bei Suchfeldern wichtig ist. Bei den FS-Datentypen handelt es sich ebenfalls um Structs. Die Wertzuweisungen zwischen verschiedenen FS-Datentypen erfolgen also ByValue – wie bei den .NET-Datentypen auch. Variablen und Properties von einem FS-Datentyp können genauso verwendet werden wie Variablen und Properties von .NET-Datentypen. Es können auch Zuweisungen zwischen den verschiedenen Datentypen erfolgen. Es erfolgt in den meisten Fällen eine implizite Konvertierung der Datentypen. Die Null-Information geht dabei aber verloren. Properties der FS-Datentypen Value: (Property) Wert des FS-Datentyps als .NET-Datentyp. D.h.: FSdecimal.Value liefert einen Wert vom Typ dezimal. Dieser Wert kann sowohl gelesen als auch geschrieben werden. Ist der Wert der Variable Null, liefert Value den in der folgenden Tabelle angegebenen Wert aus der Spalte Null-Value zurück. Das Setzen des Wertes der Variable auf einen Null-Value hat aber nicht zur Folge, dass die Variable Null wird. Einzige Ausnahme ist FSstring: IsNull bedeutet Value=““ und Value=““ bedeutet IsNull. Beispiel: FSdecimal decVar1 = 0; // Wert auf 0 oder Null prüfen if (decVar1.Value == 0) { … } // Variante ohne Value if (decVar1.IsNull || decVar1 == 0 ) { … } // Wert zuweisen: decVar1 = 5; //oder decVar1.Value = 5; IsNull (Property) Ist vom Typ bool . Gibt an, ob der Wert der Variable Null ist. Um einem FS-Datentypen explizit ein Null zuzuweisen, gibt es zwei Möglichkeiten: Sie weisen dem Property IsNull true zu, oder Sie weisen der Variable FSxxx.Null zu FSdecimal decVar1 = 0; // Wert nur auf Null prüfen if (decVar1.IsNull) { … } // Wert auf Null setzen decVar1.IsNull = true; // oder decVar1 = FSdecimal.Null; Null (Statisches Property) Liefert eine Variable mit einem Null-Wert. // Variable mit Null initialisieren FSdecimal decVar2 = FSdecimal.Null; Es folgt eine Tabelle mit allen FS-Datentypen und deren Null-Value. .NET-Datentyp FS-Datentyp Null-Value bool FSBool false byte FSbyte 0 DateTime FSDateTime DateTime.MinValue decimal FSdecimal 0 double FSdouble 0 float FSfloat 0 int FSint 0 long FSlong 0 short FSshort 0 string FSstring String.Empty HasValue (Property) Ist vom Typ bool . Man kann mit IsNull prüfen, ob ein FSType ( FSstring , FSdecimal , …) null ist. Wenn das Gegenteil geprüft werden soll, kann das Property HasValue verwendet werden. So wird der Code deutlich lesbarer, vor allem dann, wenn das zu prüfende Property tief verschachtelt ist. Beispiel: // herkömmlicher Weg (Das Ausrufezeichen wird schnell überlesen): if (!this.oOrder.oCustomer.sCompany1.IsNull) // neuer Weg: if (this.oOrder.oCustomer.sCompany1.HasValue) FSDateTime.Now Statisches Property am Typ FSDateTime , welches das aktuelle System-Datum sekundengenau zurückgibt. Wenn man mit der Datenbank oder auch mit Benutzer-Eingaben arbeitet, werden in der Regel sekundengenaue Werte verarbeitet. Wenn man mit dem System.DateTime.Now arbeitet, erhält man einen um mehrere Zehnerpotenzen genaueren Wert. Bei Vergleichen mit Benutzereingaben weichen diese dann von System.DateTime.Now ab. Es wird daher empfohlen, alle Daten, die mit dem aktuellen Datum initialisiert werden sollen, mit FSDateTime.Now zu initialisieren. Beispiel: // Variable mit sekundengenauem Wert der aktuellen Zeit initialisieren FSDateTime dtMyDate = FSDateTime.Now; Wenn mit genaueren Werten gearbeitet werden soll, ist die folgende Initialisierung ebenfalls möglich: // Variable möglichst genau mit der aktuellen Zeit initialisieren FSDateTime dtMyAccurateDate = DateTime.Now;"
  },
  "doc/database/dbtable.html": {
    "href": "doc/database/dbtable.html",
    "title": "DBTable",
    "keywords": "DBTable Ein DBTable ermöglicht Komponenten den Zugriff auf eine Datenbanktabelle, die über einen Datasource angesprochen werden kann. Alle DBTables werden im Objekt-Baum ( Registerkarte Namespaces ) im Namespace FSGeneral / DBTables unterhalb des Datasources angezeigt, den der DBTable zur Verbindung mit der Datenbank verwendet. Das Erstellen und Löschen von DBTables funktioniert wie bei allen anderen Elementen ( Elemente erstellen , Elemente löschen ). Zuvor muss allerdings im Objekt-Baum der zu verwendende Datasource markiert werden! Durch einen Doppelklick auf ein DBTable wird das Designer-Fenster geöffnet. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für DBTables angeboten werden, finden Sie unter Allgemeine Funktionalitäten . Über den Menüpunkt Database / Import kann die auf der Datenbank existierende Datenstruktur ausgelesen werden und der DBTable automatisch konfiguriert werden ( Automatisiertes Importieren von Datenbankstrukturen ). Über den Menüpunkt Component / Create Component... kann aus dem DBTable eine Komponente generiert werden ( Erzeugen einer Komponente ). Die Checkbox View legt fest, ob es sich bei dieser Tabelle um einen View handelt. Wenn dies der Fall ist, muss auf der Registerkarte View eine entsprechende View-Definition angegeben werden. Diese Einstellung kann im Customizing nicht verändert werden. Die Checkbox Use History legt fest, ob historische Daten in einer separaten Tabelle ausgelagert sind ( Auslagerung historischer Daten ). Die Checkbox Imported gibt an, ob es sich bei dieser Tabelle um eine importierte Datenstruktur handelt. Importierte Strukturen werden beim automatischen Datenbank-Update nicht berücksichtigt. Wenn an der, der DBTable zugehörigen, Connection die Eigenschaft Imported gesetzt ist, dann ist auch die Checkbox an der DBTable automatisch gesetzt und kann nicht deaktiviert werden. Diese Einstellung kann im Customizing nicht verändert werden. Die einzelnen Registerkarten werden im Folgenden beschrieben. Registerkarte Columns Auf der Registerkarte Columns werden die einzelnen Spalten der Tabelle angezeigt. Die Eigenschaften der Spalten sind editierbar und müssen mit der Definition des Datenmodells auf der Datenbank vereinbar sein. Außerdem kann ein Metadatentyp zugeordnet werden. Link Preview DBTable Öffnet die Sql Statement Preview Tabelle In der Tabelle werden Informationen zu allen Spalten angezeigt. Die Tabelle ist readonly - die Details der ausgewählten Tabellen-Spalte können im Bereich unter der Tabelle angezeigt werden. Spalte Name : Der Name der Spalte Spalte Default Label : Zeigt den Text des Default-Labels an. Dieser kann auf der Registerkarte Texts bearbeitet werden. Spalte Metadatatype : Der Name des Metadatentyp Spalten Size , Precision , Scale : Die Größe des Feldes. Spalte Column Kind : Die Art der Spalte. RowID, RowVersion oder PK (Primary Key). Spalte MLColumn : Zeigt an, ob es sich um eine MLColumn handelt. Spalte Not Null : Zeigt an, ob die Spalte als Not Null gekennzeichnet ist. Feld Name Feldname in der Datenbank. Dabei muss es sich um einen gültigen \"Identifier\" handeln. Feld Metadatatype Art des Feld-Typs. Hier stehen alle Metadatentypen und Datenbank-Datentypen zur Verfügung. Der Link Open Öffnet den Metadatentyp der momentan ausgewählten Spalte. Checkbox Primary Key Gibt an, ob es sich bei der Spalte um einen Primär-Schlüssel handeln soll. Auf ein so gekennzeichnete Tabellen-Spalte kann kein Update erfolgen. Checkbox RowID , RowVersion Auf jeder Tabelle können die beiden Spalten FSROWID und FSROWVERSION definiert werden. Diese beiden Spalten werden dann jeweils mit der entsprechenden Checkbox gekennzeichnet. Diese Spalten sind fürs Update der Daten notwendig, damit konkurrierende Transaktionen erkannt und verhindert werden können. (Siehe auch FSROWID / FSROWVERSION (TODO LINK!)) Checkbox MLColumn Ist die Checkbox aktiviert, kann in der Anwendung der Dateninhalt der Spalte mehrsprachig gepflegt werden (siehe MLColumn ). Checkbox Not Null Wenn gesetzt, dann darf diese Spalte keine Null-Werte beinhalten. Diese Information wird bei automatischen Datenbank-Update abgeglichen. Feld Size Größe des Felds bei alphanumerischen Datentyp. Wird eine Größe von 0 angegeben, handelt es sich um ein Langtext-Feld ohne Größen-Beschränkung. Feld Precision Anzahl der Stellen eines numerischen Feldes (inkl. Nachkommastellen). Feld Scale Anzahl der Nachkommastellen. Checkbox Override Wird diese Checkbox gesetzt, dann können die aus dem Metadatentyp geerbten Größen-Angaben Size , Precision und Scale , überschrieben werden. Warning Davon sollte nur in Ausnahmefällen gebrauch gemacht werden. Zuerst sollte versucht werden, einen passenden Metadatypen zu verwenden. Ist keiner vorhanden, dann muss ggf. ein passender Metadatentyp erzeugt werden - insbesondere dann, wenn das mehrere Tabellen-Spalten betrifft. Auch im Customizing-Package sollte man zuerst darüber nachdenken, den zugeordneten Metadatentyp anzupassen. Das beugt Probleme beim Übertragen von Werten in andere Spalten mit demselben Metadatentyp vor. Felder Display Length / Lines In den Feldern Display MinLength , Display MaxLength , Display MinLines und Display MaxLines können die Größen-Angaben für die Form-Controls gesteuert bzw. überschrieben werden. Siehe auch Größe von Controls . Registerkarte Texts Hier können Sie das zu verwendende Default-Label , die Column-Caption , der Tooltip und die Description für eine Datenbankspalte festlegen bzw. überschreiben. Wenn der Spalte ein Metadatentyp zugeordnet wurde, wird das Default-Label vom Metadatentyp verwendet, solange es nicht an dieser Stelle überschrieben wird. Registerkarte ControlTypes Auf der Registerkarte ControlTypes wird angezeigt, welche Controls der Spalte zugeordnet sind. Ist der Spalte ein Metadatentyp zugewiesen, werden die dem Metadatentyp bereits zugewiesenen Controls hier angezeigt. Die Liste kann ggf. ergänzt werden. Ist kein Metadatentyp zugewiesen, können Sie die ControlTypes hier hinterlegen. Mit den Buttons Add und Change öffnet sich das Fenster Assign Controls . Siehe auch Metadatentyp Registerkarte Control Types Registerkarte Documentation Auf der Registerkarte Documentation kann die Benutzer-Dokumentation für die Tabelle hinterlegt bzw. die Dokumentation aus dem verwendeten Metadatentypen überschrieben oder ergänzt werden. Siehe auch Dokumentations-System . Registerkarte Indices Die Indizes einer Tabelle lassen sich auf der Registerkarte Indices festlegen. Ein neuer Index lässt sich wie gewohnt durch das Kontextmenü, die Toolbar oder durch das Menü File / New anlegen. Diesem können nun Spalten zugeordnet werden, die entweder absteigend (DESC) oder aufsteigend (ASC) indiziert sein können. Des Weiteren kann ein Index als Unique (eindeutig) deklariert werden und er kann aktiviert oder deaktiviert werden, wodurch der automatische Abgleich mit der Datenbank beeinflusst wird. Indizes lassen sich nur dann verwalten, wenn es sich bei der Tabelle nicht um einen View handelt. Registerkarte View Wird eine DBTable mit der Checkbox View gekennzeichnet, dann muss auf der Registerkarte View ein SQL-Statement für die View-Definition angegeben werden. Die View-Definition wird beim automatischen Datenbank-Update abgegelichen und der View ggf. angepasst. Das Statement wird in Framework-Studio-Syntax formuliert ( SQL-Syntax ). Die Bezeichnungen der Ergebnis-Spalten werden aus dem Select-Statement ermittelt. Aus diesem Grund muss ggf. ein Spalten-Alias angegeben werden - z.B. bei berechneten Spalten und wenn die Bezeichnung von der Tabellen-Spalte abweichen soll. Es ist zwingend zu beachten, dass alle in der Registerkarte Columns definierten Spalten in der View-Definition enthalten sind. Die View-Definition kann im Customzing-Package überschrieben werden. Mit dem Link Preview Select öffnet sich die Sql Statement Preview . Damit kann das Statement gestestet werden. Registerkarte Relations Auf der Registerkarte Relations hinterlegen Sie die Beziehungen, die 2 Tabellen miteinander verbinden sollen. Mit dem Button New können neue Verbindungen definiert werden. Unter Relation Detail benennen Sie zunächst die Relation, um anschließend auszuwählen, ob es sich um eine Fremdschlüssel-Relation (Foreign Key) oder um eine Meta-Relation handelt. Die Combobox PK-Table zeigt Ihnen alle Tabellen, auf welche Sie mit Ihrer Verknüpfung verzweigen können. Dann verbinden Sie noch alle Felder miteinander, die zu der Schlüssel-Kombination gehören. Klicken Sie dazu auf den Button New Join und ordnen Sie anschließend in den Comboboxen die beiden korrespondierenden Spalten zu, welche die Schlüsselkombination darstellen. Registerkarte Description In dem Textfeld der Registerkarte können allgemeine Informationen zu dieser Tabelle hinterlegt werden. Sql Statement Preview Mit der Sql Statement Preview können SQL-Befehle getestet werden. Sie steht in verschiedenen Programmteilen zur Verfügung um z.B. eine DBTable, die View-Definition oder eine Component-Query zu testen. Registerkarte Select Statement Hier wird der SQL-Befehl angezeigt, der von der Aufruf-Stelle übergeben wurde. Dieser kann hier temporär bearbeitet werden, die vorgenommenen Änderungen werden jedoch nicht übernommen. Im Feld Additional where clause kann optional eine zusätzliche Suchbedingung angegeben werden. Wenn das Statement selber schon eine Bedingung besetzt, dann wird diese ergänzt. Bei Connection wird die aktuell ausgewählte Datenbank angezeigt. An diese wird das SQL-Statement geschickt. Mit dem Button View Result wird auf die Registerkarte View top 50 Results gewechselt. Registerkarte Converted Statement Zeigt den in die Syntax der Zieldatenbank konvertierten SQL-Befehl an. Standardmäßig wird der Typ der aktuell ausgewählten Datenbank vorbelegt. Mit den Buttons kann der Typ gewechselt werden. Falls bei der Konvertierung ein Fehler auftritt, wird dieser statt dem Statement angezeigt. Registerkarte View top 50 Results Beim Wechsel auf diese Registerkarte wird das Statement an die aktuell ausgewählte Datenbank gesendet und die ersten 50 Ergebnisse in einer Tabelle angezeigt. Automatisiertes Importieren von Datenbankstrukturen Framework Studio bietet Ihnen einen Automatismus, der es erlaubt, alle nötigen Angaben über die Struktur der Daten auf der Datenbank auszulesen und daraus die Spaltendefinitionen generieren zu lassen. Benutzen Sie dazu den Menüpunkt Database / Import , der Ihnen sowohl im Designer-Fenster eines Datasources als auch im Designer-Fenster eines DBTables zur Verfügung steht. Zunächst werden Ihnen alle Tabellen, die über die Datenquelle (des DBTables) erreichbar sind, zur Auswahl gestellt. Wenn Sie eine Tabelle ausgewählt haben, die in Framework Studio bisher noch nicht bekannt ist, wird diese automatisch als neuer Table in Framework Studio eingebunden. Danach sehen Sie im Fenster Update Table eine Tabelle, in der alle Columns (Spalten der Datenbanktabelle) aufgelistet werden. Update Table (Spalten): In der Tabellenspalte mit der Überschrift Column Name wird der Name der Datenbankspalte aufgeführt. In der Tabellenspalte Action wird ein Symbol dargestellt, an welchem Sie erkennen können, welche Art von Änderung bei einer Aktualisierung durchgeführt wird. Die Symbole haben folgende Bedeutung: New: Die Spalte ist in Framework Studio bisher unbekannt und wird neu eingefügt. Modified: Einige Eigenschaften der Spalte (z.B. Genauigkeit, Größe oder Metadatentyp) unterscheiden sich von den Vorgaben durch die Datenbank. Diese Eigenschaften werden geändert. OK: Die Konfiguration in Framework Studio stimmt mit der Datenstruktur in der Datenbank überein. Sie haben trotzdem die Möglichkeit, den Metadatentypen zu ändern. Delete: Diese Spalte ist in Framework Studio angelegt worden, existiert aber nicht in der Datenbank. Deshalb wird Sie aus der Konfiguration entfernt. In der Tabellenspalte Metadatatype wird der Metadatentyp, welcher der Spalte zugewiesen wird, festgelegt. In der Combobox stehen alle Metadatentypen zur Auswahl, deren Datentyp sich mit dem der Datenbankspalte vertragen. Außerdem haben Sie die Möglichkeit, über den Eintrag Create ’mdtBeispieldatentyp’ für diese Datenbankspalte einen neuen Metadatentypen generieren zu lassen. In der Tabellenspalte Action Description werden die einzelnen Änderungen aufgeführt, die bei einem Update der Spalte durchgeführt werden. Die alten Werte werden in runden Klammern hinter den neuen Werten aufgeführt. Mit der Checkbox in der Tabellenspalte Update legen Sie für jede einzelne Datenbankspalte fest, ob die vorgeschlagenen Änderungen tatsächlich durchgeführt werden sollen. Mit den Buttons und legen Sie fest, dass alle Datenbankspalten bzw. keine Datenbankspalte aktualisiert werden soll. Durch einen Klick auf gelangen Sie zur Zusammenfassung der vorzunehmenden Änderungen. Sie können den Aktualisierungsvorgang nun mit dem Button starten. Update Table (Zusammenfassung): Wenn Sie automatisch neue Metadatentypen generieren lassen, haben Sie die Möglichkeit, den Namespace auszuwählen, in dem der Metadatentyp angelegt werden soll. Select Namespace: Sie können für jeden neu zu erstellenden Metadatentypen einzeln einen Namespace auswählen oder durch Setzen der Checkbox Create all Metadatatypes in this Namespace alle Metadatentypen im gleichen Namespace erzeugen lassen. Mit dem Button New Namespace können Sie im ausgewählten Namespace einen neuen Namespace anlegen. Auslagerung historischer Daten Sehr große Datenvolumen in Tabellen mit aktuellen und historischen, viele Jahre alten Daten, können die Geschwindigkeit der Anwendung bremsen. Werden die historischen Daten in eine spezielle Tabelle ausgelagert, so kann Framework Studio abhängig von einem Laufzeitschalter beim Laden von Components entweder die aktuellen Daten oder alle Daten berücksichtigen. Der Geschwindigkeitsvorteil entsteht im Wesentlichen dadurch, dass im täglichen Betrieb nur mit den aktuellen Daten, also einer geringeren Datenmenge gearbeitet werden muss. Dem Datenbankadministrator wird außerdem die Möglichkeit gegeben, die historischen Daten auf einer langsameren Hardware zu speichern. Der Mechanismus ist für sehr große Datenmengen interessant. Typische Anwendungsfälle sind Journaltabellen, in denen viele Millionen Datensätze abgelegt sind. Details An DBTables kann über die Checkbox Use History festgelegt werden, ob historische Daten in eine separate Tabelle ausgelagert sind. Diese Eigenschaft kann auch in Customizing Packages nachträglich gesetzt werden. Ist der Schalter für eine Tabelle Xyz gesetzt, geht Framework Studio davon aus, dass eine Tabelle Xyz_H (für die historischen Daten) und ein View Xyz_A , welcher mit Union All die Daten aus Xyz und Xyz_H vereint, vorhanden ist. Tabelle und View können von der Endanwendung (z.B. beim Update) automatisch generiert werden. Note Für das Übertragen von Daten aus der Tabelle Xyz in die Historientabelle Xyz_H ist manuelle Programmierung nötig. Wird versucht, einen historischen Datensatz zu speichern, so wird eine Exception ausgelöst. Am Global Object (this.Global) gibt es einen Schalter Use History , mit dem global entschieden wird, ob beim Laden historische Daten berücksichtigt werden sollen. Ist der globale Schalter Use History gesetzt und an einer Tabelle ist der Schalter Use History ebenfalls gesetzt, so wird beim Laden statt auf die Originaltabelle auf den View zugegriffen. Um temporär den Historienmodus zu aktivieren, kann folgendes Using Konstrukt verwendet werden: // Historienmodus temporär erzwingen: using(this.Global.UseHistoryTemporarily()) { ... } Alle Components , die einen Datenbankbezug haben, bieten die Funktion GetTableName an. Diese Funktion gibt den Tabellennamen inklusive Alias zurück, zum Beispiel „Artikel_A as Artikel“ . Diese Funktion eignet sich für die Formulierung von Sub Selects. Für die manuelle Formulierung von Update-, Insert- oder Delete Statements kann an der Component Instanz auf QueryInfo.GetJoinInfo().FirstOrDefault().Table.TableName zugegriffen werden. Erzeugen einer Komponente Über den Menüpunkt Component / Create Component öffnet sich das gleichnamige Fenster. Hier wird eine Abfrage erzeugt, die genau die Daten aus der Datenbank holt, welche Sie über Ihren DBTable definiert haben. New Component Wizard / Create Component: Aktivieren Sie die Checkbox Create a Collection for the Component , um gleichzeitig eine Collection zu der Komponente zu erzeugen. Die Collection wird in dem gleichen Namespace erzeugt und trägt das Suffix Coll (also cdXxxColl). Der Button Next auf der Maske Create Component öffnet das Fenster Choose Namespace . New Component Wizard / Choose Namespace: Im Fenster Choose Namespace wählen Sie den Namespace aus, in dem die neue Komponente erzeugt werden soll. Über den Button Next öffnet sich das Fenster Summary . Es zeigt Ihnen eine Zusammenfassung Ihrer Einstellungen . Summary: Mit Finish wird die Komponente erzeugt. Alle angezeigten Tabellen werden ebenfalls über Source Control gesteuert. Das bedeutet, dass Elemente, die editiert werden sollen, ausgecheckt und zum Übernehmen der Änderungen wieder eingecheckt werden müssen. In dieser Ansicht ist nicht direkt erkennbar, welche Elemente ausgecheckt sind und welche nicht. Sie sollten es sich deshalb zur Gewohnheit machen, Ihre Database-Elemente so schnell wie möglich wieder einzuchecken und so für andere Entwickler verfügbar zu machen. Tabellen können eingecheckt werden, indem Sie sie in der Tabelle auswählen und dann über das Hauptmenü Source Control / Check In wählen."
  },
  "doc/database/datasource.html": {
    "href": "doc/database/datasource.html",
    "title": "Datasource",
    "keywords": "Datasource Ein Datasource (Datenquelle) definiert eine Datenbankverbindung, die von der Anwendung zum Lesen und Schreiben der Anwendungsdaten verwendet werden kann. Alle Datenquellen werden im Objekt-Baum ( Registerkarte Namespaces ) im Namespace FSGeneral / DBTables verwaltet. Das Erstellen und Löschen von Datenquellen funktioniert in diesem Namespace wie bei allen anderen Elementen ( Elemente erstellen , Elemente löschen ). Durch einen Doppelklick auf eine Datenquelle wird das Designer-Fenster geöffnet. Erläuterungen zu den Standardfunktionen, die im Designer-Fenster für Datenquellen angeboten werden, finden Sie unter Allgemeine Funktionalitäten . Alle weiteren Funktionen werden im Folgenden beschrieben: Name: Über das Textfeld können Sie der Datenquelle einen Namen zuweisen. Die Verbindungs-Einstellungen sin dim Kapitel Connection Einstellungen (!TODO LINK) beschrieben. Test Connection: Über diesen Button können Sie testen, ob mit den angegebenen Verbindungsdaten eine Verbindung aufgebaut werden kann."
  },
  "doc/documentation/editor.html": {
    "href": "doc/documentation/editor.html",
    "title": "Editor",
    "keywords": "Editor *Dokumentations-Editor in Framework Studio Zugang zum Editor der verschiedenen Elemente Da an verschiedenen Elementen im Framework Studio dokumentiert werden kann, werden nachfolgend alle Einsprungpunkte zum Editor aufgezeigt. Documentation-Element Da das Documentation-Element keine andere Funktion hat außer Freitexte in Form von DocML zu verfassen, besteht das Hauptformular eines Documentation-Elements aus dem Editor selbst. Das Documentation-Element besteht praktisch nur aus einem Editor: Form Um ein Form zu dokumentierten, muss dieses geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Zugang zum Editor über den Reiter Documentation : Form Control Controls auf einem Form werden über den Form Designer dokumentiert. Dazu muss das gewünschte Control markiert werden. Mit einem Rechtsklick auf das Control öffnet sich das Kontextmenü in dem der Menüpunkt Edit Documentation aufgeführt wird. Alternativ kann über das Property-Fenster von Framework Studio im Bereich Documentation auf den Button mit den drei Punkten geklickt werden. Der Editor öffnet sich für die Controls als modaler Dialog über dem Form Designer. Aufrufen des Editors für ein Control: Component Property Um ein Property zu dokumentieren, muss in der Component das jeweilige Property ausgewählt sein. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation eines Properties: DBColumn Um eine Datenbankspalte zu dokumentieren, muss an der DBTable die gewünschte Spalte ausgewählt werden. Danach kann die Registerkarte Documentation ausgewählt werden. Dokumentation einer DBColumn: Metadatentyp Um einen Metadatentyp zu dokumentierten, muss dieser geöffnet werden und auf die Registerkarte Documentation gewechselt werden. Dokumentation eines Metadatatypen: Arbeiten mit dem Editor Der Dokumentationseditor ist ähnlich intuitiv bedienbar wie z.B. ein normaler Texteditor in Microsoft Word oder anderen Textverarbeitungsprogrammen. Es wird der Text markiert, auf den eine Formatierung angewendet werden soll und das jeweilige Icon in der Werkzeugleiste geklickt, um die Formatierung an- oder auszuschalten. Bei Textbausteinen wie Tabellen oder Listen wird der Cursor an die Stelle gesetzt, an der das gewünschte Element eingefügt werden soll. Info Panel Info Panel und Link zum Chapter Tree im Editor: Über die Radiobuttons im Info Panel kann zwischen verschiedenen Ansichten des Editors umgeschaltet werden. None: Zeigt nur den DocML-Editor für die ausgewählte Sprache. Preview: Zeigt zusätzlich zum DocML-Editor das Vorschaufenster an (wird automatisch aktiviert, wenn in der Werkzeugleiste geklickt wird). Other: Zeigt zusätzlich zum DocML-Editor einen zweiten DocML-Editor im Lesemodus an, um zeitgleich eine andere Sprache oder eine andere Dokumentation aus einem anderen Package bereitzustellen. Über den Link Open Documentation Tree kann aus jedem Editor heraus der Kapitel-Baum aufgerufen werden. Siehe Chapter Tree . Werkzeugleiste Combobox Language Hier kann die Sprache eingestellt werden, für die im Dokumentations-Editor dokumentiert werden soll. Die DocML-Scripte für die jeweiligen Sprachen sind völlig unabhängig voneinander und beeinflussen sich somit nicht gegenseitig. Textbox Caption Dieses Textfeld ist nur an Form-Dokumentationen und Documentation-Elementen verfügbar. Hier wird die Kapitelüberschrift für das fertige Dokument eingegeben. Die Kapitel werden im Chapter Tree verwaltet. Neue Section Sie erkennen Neue Section an einem -Icon. Fügt an der Stelle des Cursers im Dokumentations-Editor eine neues Section-Tag ein. Dabei wird automatisch eine neue 32-stellige GUID generiert und in das id-Attribut des Tags eingefügt. Von da an steht die Section für Customizing-Zwecke bereit. Siehe Customizing . Preview anzeigen Sie erkennen Preview anzeigen an einem -Icon. Über diesen Button wird das sich im Editor befindliche DocML in HTML konvertiert und im Preview-Panel angezeigt. Kann das DocML aufgrund von Fehlern nicht korrekt umgewandelt werden, werden die entsprechenden Fehler im Common Errors -Panel von Framework Studio aufgelistet. Syntax-Check Sie erkennen Syntax-Check an -Icons. Über diese Buttons kann das DocML auf Validität geprüft werden. Der erste Button überprüft das sich im Editor befindliche DocML für die ausgewählte Sprache. Der Button mit dem Zusatz All überprüft das DocML für alle verfügbaren Sprachen, die über die Combobox Language auswählbar sind. Bei einem Klick auf den Preview-Button wird automatisch erst eine Validierung des DocML’s für die aktuelle Sprache durchgeführt. Schriftart Sie erkennen Schriftart an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftart. Um die finale Dokumentation der Anwendung möglichst homogen zu halten, stehen nur zwei Schriftarten zur Auswahl Normal: Wird in HTML und Word in Arial konvertiert Code: Wird in HTML in ein <code>-Tag geschrieben, im Word wird Courier New verwendet. Schriftgröße Sie erkennen Schriftgröße an einem -Icon. Formatiert den im Editor markierten Text in der ausgewählten Schriftgröße. Die Einstellung Normal spiegelt die gängige Standardgröße 11pt in Word wider. Die Schriftgrößenangaben sind relativ gehalten, da aus DocML unterschiedliche Ausgabeformen generiert werden können (HTML, Word). Schriftfarbe Sie erkennen Schriftfarbe an -Icons. Formatiert den im Editor markierten Text in der ausgewählten Schriftfarbe. Es können die Schriftfarbe sowie die Hintergrundfarbe für den Text ausgewählt werden. Textformatierungen Sie erkennen Textformatierungen an -Icons. Umgibt den im Editor ausgewählten Text mit dem entsprechenden Formatierungstag. Zur Auswahl stehen: Fett Kursiv Unterstrichen Durchgestrichen Tiefgestellt Hochgestellt Ausrichtung Sie erkennen Ausrichtung an -Icons. Richtet den im Editor markierten Text nach Wunsch links, mittig, rechts oder als Blocksatz aus. Die Standardeinstellung ist linksbündig. Liste Sie erkennen Liste an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Auflistung: List Type Mit List Type wird die Art der Liste definiert. Unordered stellt eine Liste mit Symbolen dar, während Ordered die Listeneinträge aufsteigend nummeriert. List Symbol Nur verfügbar, wenn als Listentyp “Unordered” ausgewählt wurde. Es kann zwischen Disk, Circle und Square gewählt werden. List Item Count Legt die Anzahl der in der Liste befindlichen li-Tags fest. Diese können anschließend im DocML beliebig erweitert werden. Tabelle Sie erkennen Tabelle an einem -Icon. Öffnet einen Dialog zum Erstellen einer neuen Tabelle. Nach dem Klick auf das Symbol wird zunächst ein Panel angezeigt, in dem die Größe der zu konfigurierenden Tabelle ausgewählt werden muss: Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat unten rechts gezeigt, vergrößert sich die Auswahl. Wird mit dem Mauszeiger länger als eine Sekunde auf das Quadrat oben links gezeigt, verkleinert sich die Auswahl. Nach der Auswahl der Tabellengröße wird der Dialog zum Konfigurieren der Tabelle angezeigt: Es können alle Parameter der Tabelle eingestellt werden. Dazu gehören Breite, Ausrichtung und Farbe der Tabelle, Spalten, Zeilen und Zellen. Die Werte der Tabelle können durch Spalten, Zeilen und Zellen überschrieben werden. Die Hierarchie der Überschreibungen sieht wie folgt aus: Tabelle -> Spalte -> Zeile -> Zelle Mit einem Klick auf den Button Ok werden für die konfigurierte Tabelle die entsprechenden Tags in den Editor generiert und können anschließend mit Werten befüllt werden. Bild einbinden Sie erkennen Bild einbinden an einem -Icon. Öffnet einen Dialog zum Einbinden eines Bildes in die Dokumentation. Es können nur Bildressourcen aus Framework Studio in die Dokumentation eingebunden werden. Für Bilder von der Festplatte oder aus dem Internet wird eine entsprechende Bildressource angelegt. Einfügen eines Bildes in die Dokumentation: Im Bereich Image Source muss zuerst ausgewählt werden, woher das einzubindende Bild stammt. Wenn das Bild schon als Ressource im Framework Studio verfügbar ist, kann diese aus der Baumansicht ( Existing Resource ) ausgewählt werden. Eine Vorschau des Bildes erscheint auf der rechten Seite. Es kann auch direkt ein Bild aus dem Internet eingebunden werden ( From Url ). Damit das Bild in der Dokumentation angezeigt wird, wenn beim Betrachten keine Internetverbindung besteht, muss dieses mit dem Button Load geladen werden. Danach erscheint das Bild in der Vorschau. Die Url des Bildes muss mit Fehler! Linkreferenz ungültig beginnen. Soll ein Bild von der Festplatte eingebunden werden, muss zuerst der Radiobutton From File aktiviert werden. Danach kann über den Button […] ein Bild von der Festplatte gewählt werden. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Bildes verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Bildes in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Bildes. Height Höhe des Bildes (nur aktiv, wenn Keep aspect ratio deaktiviert ist). Keep aspect ratio Wenn aktiviert (Standard), wird anhand der eingegebenen Breite des Bildes, die zugehörige Höhe anhand des originalen Seitenverhältnisses berechnet. Das Bild wird somit nicht verzerrt. Inline Image Wenn aktiviert, verhält sich das Bild wie ein Schriftzeichen und folgt dem normalen Textfluss. Andernfalls wird vor und nach dem eingefügten Bild ein Zeilenumbruch generiert. Caption Nur verfügbar, wenn die Option Inline Image deaktiviert ist. Es kann eine Bildunterschrift angegeben werden. Warning Wenn das Bild aus dem Internet oder von der Festplatte eingebunden werden soll, wird nach dem Klick auf den Button Ok ein Dialog angezeigt, der darauf hinweist, dass automatisch eine Framework Studio Resource für das Bild angelegt wird. Screenshot Sie erkennen Screenshot an einem -Icon. Öffnet einen Dialog zum Einbinden eines automatisch generierten Screenshots des Formulars in die Dokumentation. Diese Funktion ist nur in der Form-Dokumentation verfügbar. Anhand der Designer-Daten wird ein Screenshot des Formulars generiert. Sollten Tabellen mehr Spalten haben, als in der Breite angezeigt werden können, werden die Spaltenköpfe umgebrochen und mehrzeilig fortgeführt. Im Bereich Attributes können die Anzeigeeigenschaften des einzubindenden Screenshots verändert werden: Original Size Verwendet in der Dokumentation die ursprüngliche Größe des Formulars in cm. Unit Gibt an, welche Maßeinheit in der Dokumentation verwendet werden soll. Zur Auswahl stehen Zentimeter (cm) und Inch (in). Width Breite des Screenshots. Height Die Höhe des Bildes wird automatisch anhand des Seitenverhältnisses des Formulars berechnet. Link Sie erkennen Link an einem -Icon. Öffnet einen Dialog zum Einfügen eines Querverweises oder eines Hyperlinks. Es kann im DocML sehr einfach auf ein anderes Kapitel (Formular oder Documentation-Element) verwiesen werden oder ein Hyperlink ins Internet bereitgestellt werden. Bei einem Querverweis auf ein Kapitel muss das entsprechende Form oder Documentation-Element aus der Baumansicht ausgewählt werden. Für einen Hyperlink ins Internet kann eine beliebige URL beginnend mit Fehler! Linkreferenz ungültig eingegeben werden. In der Textbox Text wird festgelegt, wie der Link in der Dokumentation angezeigt werden soll. Indexeintrag Sie erkennen Indexeintrag an einem -Icon. Öffnet einen Dialog zum Einfügen eines Indexeintrages in die Dokumentation. Im Export Wizard kann definiert werden, ob in der gerenderten Dokumentation ein Index erstellt werden soll. Kapitelüberschriften (von Forms und Documentation-Elementen) werden dem Index automatisch hinzugefügt. Über den Dialog ist es möglich, manuell einen Indexeintrag zu generieren. Dabei muss der Haupteintrag definiert werden. Optional kann ein Untereintrag angegeben werden. Basisaufruf Sie erkennen Basisaufruf an einem -Icon. Nur verfügbar in den Dokumentationen von Controls, Component Properties, DBColumns und Metadatentypen. Erstellt ein base-Tag, welches die Basisdokumentation des aktuellen Elements (Controls, Component Properties, DBColumn oder Metadatentyps) in die Dokumentation mit einbindet. Mehr Information hierzu finden Sie im Kapitel Vererbung Linie Sie erkennen Linie an einem -Icon. Erstellt an der Curser-Position im Editor ein line-Tag. Dieses generiert in der Dokumentation eine schwarze Linie über die gesamte Seitenbreite mit anschließendem Zeilenumbruch. Zeilenumbruch Das br-Tag ist sicherlich das am häufigsten verwendete Tag in einer Dokumentation in DocML. Es wäre sehr umständlich, wenn jedes Mal, wenn ein Zeilenumbruch in der Dokumentation eingefügt werden soll, ein Button in der Werkzeugleiste geklickt werden müsste. Dies würde den Schreibfluss mit der Tastatur erheblich behindern. Um ein br-Tag ( [br/] ) an der Cursorposition einzufügen, muss im Editor nur <STRG + Enter> gedrückt werden. Es wird ein br-Tag eingefügt und automatisch in die nächste Zeile gesprungen. Text markieren Alle Formatierungsfunktionen des Editors wie z.B. Fettschrift oder Ausrichtung des Textes funktionieren ähnlich wie in einem WYSIWYG-Editor. Es wird Text markiert und dann die gewünschte Formatierungsoption aufgerufen. Der Unterschied des DocML-Editors ist allerdings, dass sich im markierten Text auch DocML-Tags befinden können, wie folgendes Beispiel zeigt: Dies ist allerdings absolut kein Problem. Soll z.B. der oben markierte Text kursiv geschrieben werden, kann einfach in der Werkzeugleiste der entsprechende Button geklickt werden. Der Editor erkennt die Markierung und alle Tags darin und wendet die neue Formatierung entsprechend an: Es muss also nicht auf Tags geachtet werden, wenn zusätzliche Formatierungen auf schon zuvor formatierte Textstellen angewendet werden. Auch bei Block-Tags wie Listen kann dieses Verhalten auftreten. Nachfolgend soll z.B. eine gesamte Liste fett gedruckt werden. Da Block-Tags (lst-Tags) nicht in Inline-Tags (b-Tags) auftreten dürfen, kümmert sich der Editor selbst darum und ergänzt die Texte in der Liste automatisch mit den entsprechenden Tags. Folgende Liste soll komplett fett gedruckt dargestellt werden: Nach einem Klick auf den Button für Fettschrift in der Werkzeugleiste werden die Listeneinträge automatisch um die jeweiligen b-Tags ergänzt und die Validität des DocML wird erhalten: Beim Markieren von Texten für Formatierungen muss also nicht explizit an schon vorhandene Tags gedacht werden, der Editor erledigt dies alles automatisch. Kommentare DocML bietet die Möglichkeit, in Dokumentationen Kommentare einzufügen, die nicht in die Ausgabe gerendert werden. So können z.B. kleine Notizen oder Erinnerungen in die Dokumentation eingefügt werden. Ein Kommentar-Tag startet mit der Zeichenfolge [-- und endet mit --] . Kommentare sind im DocML an ihrer grünen Farbe zu erkennen und beeinflussen die Ausgabe in keinster Weise. Kommentare können an beliebiger Stelle im DocML platziert werden. Escape-Zeichen Die Sprache DocML beinhaltet einige Steuerzeichen wie z.B. eckige Klammern ( [ und ] ), mit denen die Tags abgebildet werden. Allerdings werden diese Zeichen natürlich auch im Fließtext der Ausgabe benötigt. Dass Framework Studio den Unterschied zwischen einer eckigen Klammer eines Tags und einer normalen eckigen Klammer im Fließtext unterscheiden kann, müssen diese Zeichen mit einem Blackslash ( \\ ) escaped werden. Wie zu sehen ist, werden die Backslashes in der Ausgabe eliminiert. Um einen Backslash als Zeichen in die Dokumentation einzufügen, muss dieser ebenso mit einem weiteren Backslash escaped werden. Panel Other Der Editor bietet die Möglichkeit, ein zusätzliches Fenster einzublenden, welches eine Dokumentation aus einem anderen Package oder in einer anderen Sprache anzeigt. So kann z.B. während die englische Dokumentation für ein Formular erstellt wird, parallel die deutsche Dokumentation angezeigt werden, um besser übersetzen zu können. Language Mit dieser Combobox wird die Sprache der anzuzeigenden Dokumentation gewählt. Package Mit dieser Combobox kann zwischen den Dokumentationen des Elementes in unterschiedlichen Packages gewählt werden. Mehr Informationen über Package-übergreifende Dokumentation und das Customizing befindet sich in den Kapiteln Vererbung und Customizing ."
  },
  "doc/themes/aufraeum-routine.html": {
    "href": "doc/themes/aufraeum-routine.html",
    "title": "Aufräum-Routine",
    "keywords": "Aufräum-Routine Diese Routine ist verantwortlich dafür, Themes korrekt aus einem Package zu entfernen. Da nicht nur die Themes alleine von Framework Studio gespeichert werden, sondern auch Referenzen von den Applications, Default Control Styles und Ressourcen auf die Themes verweisen, müssen vor dem endgültigen Löschen der Themes erst alle Referenzen in diesen Elementen eliminiert werden. Gelöscht werden grundsätzlich alle Themes im aktuellen Package, die im Theme Manager auf „Deprecated“ gesetzt wurden. Es werden erst alle Applications, Default Control Styles und Ressourcen durchlaufen und jegliche Referenzen auf nicht vorhandene oder auf Deprecated gesetzte Themes eliminiert und danach die Themes an sich gelöscht. Mit dem Button im Theme Manager kann die Routine gestartet werden. Es erfolgt zur Sicherheit noch eine Abfrage, ob fortgefahren werden soll: Sicherheitsabfrage der Aufräum-Routine Bevor die Routine startet, wird von Framework Studio auf das Default-Theme gewechselt. Um Änderungen an den Applications, Default Control Styles und Ressourcen vornehmen zu können, müssen diese Elemente ausgecheckt sein. Dies wird von der Routine selbst übernommen. Ist ein zu bearbeitendes Element nicht ausgecheckt, wird es automatisch ausgecheckt und nach erfolgreichem Ablauf der Routine wieder eingecheckt. Sollte ein zu änderndes Element schon vom Benutzer ausgecheckt worden sein, wird die Routine die Änderungen am Element durchführen, es aber nach erfolgreichem Ablauf NICHT einchecken (Der Benutzer könnte schon andere Änderungen am Element vorgenommen haben, die er vielleicht noch gar nicht einchecken will). Der Ablauf der Routine selbst ist im Output-Fenster von Framework Studio einsehbar: Ablauf der Routine im Output-Fenster: Nun muss noch folgender Fall betrachtet werden: Was ist, wenn ein Package Theme-Informationen beinhaltet, die auf Themes verweisen, die im Basis-Package definiert wurden und dort gelöscht werden? Dafür wird noch einmal die Konstellation von 3 Packages und 2 Themes betrachtet: Theme-Definition für die FocusHighlightColor: Beide Themes sind im Package „BasePackage“ über den Theme-Manager angelegt worden. Nun gibt es 2 Szenarien, in denen „unnötige Theme-Daten“ in den aufgesetzten Packages (CustomPackage und AdditionalPackage) entstehen. Szenario 1 Im BasePackage werden z.B. beide Themes auf Deprecated gesetzt und die Aufräum-Routine ausgeführt. Danach ist im BasePackage nur noch das Default-Theme vorhanden und jegliche Informationen zu den Themes in den Applications, Default Control Styles und Ressourcen gelöscht. Da die Themes im BasePackage gelöscht wurden, sind diese nun auch nicht mehr in den aufsetzenden Packages auswählbar. Die Property-Informationen zu den Themes in den aufsetzenden Packages sind jedoch noch im Repository gespeichert. So ist die Information Yellow für die FHC für Theme1 im AdditionalPackage immer noch im Repository vorhanden, obwohl das Theme längst aus dem BasePackage gelöscht wurde. Dies hat zur Folge, dass bei jedem CheckIn/CheckOut der Application diese nunmehr sinnlose Information mitgeschleift wird. Es empfiehlt sich also, die Aufräum-Routine auch in den aufsetzenden Packages durchzuführen. Die Routine erkennt nicht nur auf Deprecated gesetzte Themes, sondern eliminiert auch jegliche Informationen zu Themes, die in der Package-Hierarchie nicht mehr auffindbar sind. Im konkreten Fall würde die Routine im AdditionalPackage die Application durchgehen, in der für Theme1 für die FHC Yellow definiert wurde. Sie erkennt dann, dass die das Theme Theme1 gar nicht mehr in der Package-Hierarchie auffinden kann (da es ja im BasePackage gelöscht wurde). Somit wird diese Property-Information aus dem AdditionalPackage gelöscht und die Application hat, bezogen auf die Themes, wieder einen sauberen Stand. Szenario 2 Da Framework Studio die Möglichkeit bietet, Packages beliebig in der Hierarchie anzuordnen, kann folgender Fall eintreten: Das BasePackage mit den 2 definierten Themes wird aus der Hierarchie entfernt und ein neues BasePackage wird an dessen Stelle gesetzt. In diesem neuen BasePackage sind jedoch die Themes überhaupt nicht definiert. Ab diesem Zeitpunkt ist die Situation wieder wie in Szenario 1. Die aufsetzenden Packages CustomPackage und AdditionalPackage haben in ihren Elementen Theme-Informationen für Themes, die gar nicht mehr in der Package-Hierarchie existieren. Das Starten der Aufräum-Routine in den Packages CustomPackage und AdditionalPackage würde diese Unsauberkeiten bereinigen. Note Wenn Themes gelöscht werden und die Aufräum-Routine in aufsetzenden Packages NICHT ausgeführt wird, hat dies funktional KEINEN Einfluss auf die Anwendungen. Es werden lediglich unnütze Daten im Repository von Version zu Version mitgeschleift ."
  },
  "doc/tables/tblrep_reportinstance.html": {
    "href": "doc/tables/tblrep_reportinstance.html",
    "title": "tblRep_ReportInstance (Runtime-Repository)",
    "keywords": "tblRep_ReportInstance (Runtime-Repository) Diese Tabelle beinhaltet die Druck-Jobs die per Anzeige / Vorschau direkt am Client angezeigt werden. Spalte Beschreibung RPTI_ID Eindeutige ID des Print-Jobs (Guid) RowRPTI_CreateDateTime Zeitpunkt, an dem der Print-Job erzeugt wurde RPTI_RPTExpF_ID Das Format in dem der Druck ausgegeben werden soll. 1 = CrystalReport 2 = RichText 3 = Word 4 = Excel 5 = PDF 6/7 = HTML RPTI_Reportname Der Name der Report-Datei RPTI_ReportFile Der Inhalt der Datei im Binär-Format. Normalerweise werden die Datensätze in dieser Tabelle nach 10 Minuten automatisch gelöscht. Sollten dennoch Einträge stehen bleiben, dann können veraltete Einträge auch manuell gelöscht werden. -- SQL-Server: DELETE FROM [tblRep_ReportInstance] WHERE DATEADD(minute, 10, [RPTI_CreateDateTime]) < GetDate (); -- Oracle: DELETE FROM tblRep_ReportInstance WHERE (RPTI_CreateDateTime + (10 / 1440)) < sysdate;"
  },
  "doc/package-manager/compile-wizard.html": {
    "href": "doc/package-manager/compile-wizard.html",
    "title": "Compile Wizard",
    "keywords": "Compile Wizard Der Compile Wizard ermöglicht das automatische Kompilieren eines Labels mit den davon abhängigen Labels. Alle Einstellungen für einen solchen Vorgang können gespeichert und wieder geladen werden. Außerdem lässt sich der Compile Wizard per Kommandozeilenparameter mit einer zuvor gespeicherten Konfiguration automatisch starten. Warning Es wird immer ohne Use saved code kompiliert. Starten des Wizards Der Compile Wizard wird über den Eintrag Compile Wizard im Kontextmenü eines Labels gestartet. Im Compile Wizard werden auf der linken Seite in einem Treeview das ausgewählte Label und alle davon abhängigen Labels angezeigt. Wurzelknoten ist das ausgewählte Label. Alle davon abhängigen Labels werden auf der ersten Ebene dargestellt. Sind von diesen Labels wiederrum weitere Labels abhängig, werden diese auf einer weiteren Ebene dargestellt. Im folgenden Screenshot ist zum Beispiel das Label CustomizingTestLevel2 1.0 abhängig vom Label CustomizingTest 1.0 . Deshalb wird es (auch) als Unterknoten von CustomizingTest 1.0 angezeigt. Im Treeview kann für jedes Label über die dazugehörige Checkbox festgelegt werden, ob dieses Label kompiliert werden soll. Auf der rechten Seite werden daraus resultierend alle Labels in der Reihenfolge angezeigt, in der sie kompiliert werden. Tip Wenn man mehrere Labels (Versionen) desselben Packages hintereinander kompilieren möchte, kann man den Compile Wizard über das Kontextmenü des Labels SystemVersion vom SystemPackage öffnen. Es werden dann alle Labels angezeigt, da alle Labels von diesem Label abhängig sind. Checkbox Refresh workspace of FrameworkCompiler before each compile Wenn diese Checkbox gesetzt ist, wird der Workspace des FrameworkCompilers vor dem Kompilieren eines Labels für dieses Label aktualisiert. Button Start Compile Mit diesem Button wird der gesamte Kompiliervorgang gestartet. Tritt beim Kompilieren ein Fehler auf, wird der gesamte Kompiliervorgang unterbrochen. Es wird Framework Studio geöffnet und der aufgetretene Fehler angezeigt. Button Stop after this Label Mit diesem Button kann der Kompiliervorgang zwischen den einzelnen Labels abgebrochen werden. Einstellungen exportieren Im Compile Wizard kann über den Menüpunkt File / Export Settings die aktuelle Konfiguration in eine XML-Datei exportiert werden. In dieser Datei sind die folgenden Informationen enthalten: ConnectionString für den Zugriff auf das Repository (verschlüsselt) Zu kompilierende Labels Soll der Workspace vor dem Kompilieren aktualisiert werden? Mit dieser XML-Datei ist es möglich, ein Kompiliervorgang für mehrere Packages / Labels per Kommandozeile anzustoßen Einstellungen importieren Im Compile Wizard können Sie eine gespeicherte Konfiguration über den Menüpunkt File / Import Settings importieren. Start per Kommandozeilenparameter Der folgende Aufruf startet den Package-Manager, öffnet den Compile Wizard mit den Einstellungen, die in der Datei Settings1.XML abgelegt sind und startet den Kompiliervorgang. FrameworkStudioPackageManager.exe \\compileXML \"C:\\Settings1.XML\" So ist es z.B. möglich den Package-Manager über einen geplanten Task zu starten und so das regelmäßige Kompilieren mit dem FrameworkCompiler automatisch durchzuführen. Idealerweise sollte dieser Vorgang am Abend gestartet werden, nachdem die Entwickler ihre Elemente in einem kompilierfähigen Zustand eingecheckt haben."
  },
  "doc/package-manager/administrative-mode.html": {
    "href": "doc/package-manager/administrative-mode.html",
    "title": "Administrative Mode",
    "keywords": "Administrative Mode Für einige Aktionen auf dem Repository ist es notwendig, dass alle Entwickler das Repository verlassen: Labeln einer Version und öffnen einer neuen Importieren von Packages Update des Repositories Einige Daten werden im Repository mit Triggern bearbeitet. Zudem gibt es Absicherungen durch Constraints. Bei den oben aufgeführten Aktionen werden die Trigger und Constraints zum Teil deaktiviert. Das ist aus Performance-Gründen notwendig. Dieses Deaktivieren hätte ggf. zur Folge, dass im Repository falsche Daten entstehen können. Ist der Admin-Mode aktiviert, wird der Menüeintrag rot hervorgehoben. Der Modus kann nur aktiviert werden, wenn kein Entwickler am Repository angemeldet ist. Ist dies der Fall, wird ein Dialog angezeigt mit der Information, welche Benutzer derzeit noch angemeldet sind und der Option diese Sitzungen zu beenden. Falls noch Benutzer angemeldet sind, wird dieser Dialog angezeigt. Hier gibt es die folgenden Möglichkeiten: Cancel – den Vorgang abbrechen Retry – es erneut versuchen, nachdem z.B. dem Benutzer Bescheid gegeben wurde Kill User Sessions – die Sitzungen der Benutzer zu beenden. Bei dieser Aktion wird 130 Sekunden gewartet. Das ist die Zeit, die im Extremfall benötigt wird, bis ein Benutzer zum Beenden seiner Sitzung gezwungen wurde. (60 Sekunden bis zur Hinweismeldung + 60 Sekunden bis zum endgültigen Abbruch + 10 Sekunden Reserve) Während dieser Dialog angezeigt wird, können sich keine neuen Benutzer mehr anmelden. Befindet sich ein Repository im Admin-Mode, können sich keine Benutzer mehr darauf anmelden. Diese erhalten dann folgende Meldung. Sollte man vergessen, dass der Admin-Mode aktiv ist, wird man beim Schließen des Package-Managers darauf aufmerksam gemacht."
  },
  "doc/package/packages.html": {
    "href": "doc/package/packages.html",
    "title": "Packages",
    "keywords": "Packages Ein Package kapselt funktionale Erweiterungen und Veränderungen der Anwendung. Eine mit Framework Studio erstellte Anwendung setzt sich immer aus mehreren Packages zusammen. Aus welchen Packages letztendlich eine Anwendung zusammengesetzt ist, steht zur Entwicklungszeit eines Packages nicht fest. Klar definiert ist nur, welche Packages vorausgesetzt werden. Einzelne Packages einer Anwendung können von unterschiedlichen Herstellern entwickelt werden und mit Packages anderer Hersteller kombiniert werden. Hauptvorteil des Package-Konzepts von Framework Studio sind die Customizing Möglichkeiten. Kunden und Partnerunternehmen können durch das Hinzufügen eines zusätzlichen Packages die Anwendung nahezu ohne Einschränkungen funktional erweitern und verändern. Dabei sind sogar Erweiterungen an zentralen Datenstrukturen, Datenbanktabellen und Prozessabläufen möglich. SystemPackage Wenn Sie ein leeres Repository anlegen, enthält dieses Repository immer automatisch ein Package mit dem Namen SystemPackage . An diesem Package können Sie sich beim Start von Framework Studio nicht anmelden, da am SystemPackage keine Veränderungen vorgenommen werden können. Das SystemPackage enthält einige grundlegende Namespaces und Elemente, die von jeder Anwendung benötigt werden. Default Package Mit Default Package wird das Package bezeichnet, welches in der Verwendungsreihenfolge der Packages direkt oberhalb des SystemPackages angeordnet ist. Dieses Package hat einige Besonderheiten: Am Default Package werden die Sprachen definiert, die grundsätzlich von der Anwendung unterstützt werden sollen. Verschiedene Default Packages lassen sich mit der aktuellen Framework Studio Version nicht zusammen führen. Im Default Package werden alle Standard Controls (Default Control Styles( !TODO LINK ) ) angezeigt. Ein Default Package muss mit dem Package Manager (Package Manager( !TODO LINK )) angelegt werden, bevor es genutzt werden kann. Weitere Packages Mit Hilfe des Package Managers (Package Manager( !TODO LINK )) können weitere Packages zu einem Repository hinzugefügt werden. Dort wird auch definiert, in welcher Reihenfolge die Packages benutzt werden sollen und welche anderen Packages Voraussetzung für die Verwendung eines Packages sind. Aktives Package Mit aktivem Package wird das Package bezeichnet, an dem sich der Benutzer beim Start von Framework Studio angemeldet hat. Nur an diesem Package kann der Benutzer Veränderungen durchführen. Synonym dazu wird auch der Begriff Top Package verwendet. Customizing Mit Customizing wird der Vorgang bezeichnet, bei dem man Änderungen an einem Element aus einem Package vornimmt, das nicht das aktive Package ist. Da Änderungen immer nur im aktiven Package durchgeführt werden können, wird dazu von dem gewünschten Element eine Customization im aktiven Package angelegt. An dieser Customization können die gewünschten Änderungen dann vorgenommen werden. Technisch gesehen ist eine Customization eine Ableitung vom originalen Element. Diese Ableitung wird dann in der gesamten Anwendung statt des Originalen Elements verwendet. Das Anlegen einer Customization erfolgt über den Button Customize ( Buttons ). Warning Wenn ein Element über das Kontextmenü mit der Funktion Change Namespace… in einem anderen Package in einen anderen Namespace verschoben wurde, so muss das Element, wenn eine Customization im aktiven Package existiert, über das Kontextmenü seines Namespaces mit der Funktion Adjust moved customizations … auch im aktiven Package in den neuen Namespace verschoben werden."
  },
  "index.html": {
    "href": "index.html",
    "title": "Framework Studio 4.2",
    "keywords": "Framework Studio 4.2 Andere Versionen können hier aufgerufen werden. Note Diese Dokumentation befindet sich noch im Aufbau. Diese Seite gliedert sich in folgende Teile, die über die Navigation im oberen Bereich aufgerufen werden können: 1.) Framework Studio 4.2 Hier finden sie Neuheiten, Release-Listen, aktuelle Informationen und Systemvorrausetzungen 2.) Technische Dokumentation Alle Dokumentationen und Anleitungen für die Framework Studio IDE, Programmier-Themen und andere Programme. 3.) Api-Dokumentation Umfasst eine generierte Dokumentation der von Framework Studio bereitgestellten Klassen und Schnittstellen."
  },
  "doc/form/control/erzeugen-suchdialogs-property.html": {
    "href": "doc/form/control/erzeugen-suchdialogs-property.html",
    "title": "Erzeugen eines Suchdialogs durch Property-Funktionalität",
    "keywords": "Erzeugen eines Suchdialogs durch Property-Funktionalität Wenn Sie sich die Properties der Controls aufmerksam angesehen haben, ist Ihnen sicher aufgefallen, dass Sie z.B. Buttons als IsSearchButton und Edit-Felder als IsSearchField deklarieren können. Framework Studio bietet die Möglichkeit, relativ einfach Suchbedingungen anhand der vorhandenen Controls zu erzeugen und auch automatisch einen Load an einer Component oder Collection mit dieser Suchbedingung auszuführen. Die Felder, die sich an der Suchbedingung beteiligen sollen, werden entsprechend mit dem Property IsSearchField gekennzeichnet. Damit das funktioniert, muss den Controls als Datasource ein Property der Component zugeordnet sein, aus der die Suchbedingung erstellt werden soll. Wollen Sie z.B. einen Kundensuchdialog erstellen, werden Suchfelder als DataSource Properties der Komponente Kunden haben. Definieren Sie die Felder entsprechend als IsSearchField und stellen unter SearchOperator den Suchoperator ein. Ein weiteres Element der Suche mit Property-Funktionalität sind Buttons. Buttons können als IsSearchButton deklariert werden. In unserem Beispiel würden Sie einen Button oder ImageButton als solchen kennzeichnen. Jetzt müssen Sie dem Button noch sagen, an welcher Collection der Load ausgeführt werden soll. Dies tun Sie mit der Eigenschaft LoadAtComponent . In unserem Beispiel könnte das die KundenCollection sein. Als letztes müssen Sie noch bestimmen, aus welcher Component die Suchbedingung stammt. Das ist immer die Component, aus der die Properties der Suchfelder stammen, also in dem Beispiel Kunden. Tragen Sie die Component entsprechend unter SearchValuesComponent ein. Ihr Suchdialog ist fertig. Bei einem Klick auf den Such-Button wird geprüft, ob in einem als Suchfeld definierten Control ein Wert hinterlegt worden ist. Ist dies der Fall, wird das Feld entsprechend dem Operator in Ihre Suchbedingung aufgenommen. Ist ein Property einer Komponente als SearchField deklariert, steht Ihrem Form eine Methode mit dem Namen GenerateLoadConditionOnXxxXxx zur Verfügung. Diese Methode baut Ihren Select-String zusammen. Die Einstellungen an dem Such-Button bewirken, dass dieser automatisch einen Load in der Form LoadAtComponent.Load( GenerateLoadConditionOnXxxXxx) erzeugt. Wenn Sie die Suche lieber selber ausprogrammieren, können Sie die Suchbedingung auch modifizieren."
  },
  "doc/form/control/editfield.html": {
    "href": "doc/form/control/editfield.html",
    "title": "Editfield",
    "keywords": "Editfield Properties/Events Actions Unterstütztes HTML Wenn die Eigenschaft Editor auf den Wert HTML gesetzt ist, wird am Datasource des Controls HTML Text erwartet. Das Control bietet keine vollständige Unterstützung von Html. Es folgt ein Überblick über die Einschränkungen: Das Control ist zur Darstellung von formatiertem Text gedacht. Daher werden keinerlei Eingabefelder o.ä. unterstützt. Textinhalt müssen (selbstverständlich) HTML-Encodiert dargestellt werden. Das Control kann nur Zeichen darstellen, die im Zeichensatz der eingestellten Schrift enthalten sind. Wenn am Control WordWrap eingeschaltet ist, wird (im Gegensatz zum Plain Text Modus) nur zwischen Worten getrennt. Wenn also ein Wort länger ist als die Control Breite, wird nicht umgebrochen! Dabei ist zu beachten, dass Sonderzeichen wie beispielsweise &nbsp; als Wortteil betrachtet werden. Schriftgrößen, die in Punkten (pt) angegeben sind, werden analog zu allen Schriftgrößenangaben in Framework Studio im Java Client skaliert und in mit Crystal Reports erstellten Dokumenten korrekt angezeigt. Die Definition von Schriftgrößen in einer anderen Einheit als pt wird nicht unterstützt. Ist keine Schriftgröße im Html angegeben, wird am Control die im Form Designer angegebene Größe verwendet, in Reports die dort angegebene Größe. Jeder Textinhalt muss innerhalb eines <p> Tags (Absatz) geklammert sein. Insbesondere werden deshalb die folgenden Tags nicht unterstützt: Überschriften <h1> .. <h6> Horizontale Linie <hr> Tabellen <table> <tr> <td> Aufzählungen <ol> <ul> <li> Scripte <script> Zeilenumbrüche dürfen nicht mit <br> Tags realisiert werden, da mehrere <br> Tags hintereinander vom Crystal Reports nicht korrekt dargestellt werden können. Stattdessen müssen mit den Tags <p style=\"margin-top: 0\"> und </p> Absätze umschlossen werden. <p> Tags können neben der Definition von margin-top im style Attribut weitere Attribute und Stilangaben enthalten sein. Im Html-Modus liefert der Datasource den Inhalt eines Body-Elements. Gesetzt werden darf auch ein vollständiges Html-Dokument. In diesem Fall wird der Body automatisch extrahiert."
  },
  "doc/form/control/events.html": {
    "href": "doc/form/control/events.html",
    "title": "Events",
    "keywords": "Events Events sind Ereignisse, die durch die Interaktion mit einem Formular entstehen. Der Klick auf einen Button ist z.B. ein OnClick-Event. Sie haben in Framework Studio die Möglichkeit, auf solche Ereignisse zu reagieren. Erzeugen Sie dazu ein Event und binden es an Ihr Control. Sie sollten dabei beachten, dass beim Eintreten eines Events jedes Mal eine Interaktion zwischen dem Webserver und dem Client stattfindet. Workflow-Events dienen der Interaktion mit anderen Dialogen, Form-Events der Abarbeitung von Logik aufgrund eines Ereignisses. Der einfachste Weg ein Event zu erzeugen, ist aus dem Kontext-Menü des Controls den Eintrag Event und anschließend das gewünschte Event auszuwählen. Jetzt müssen Sie noch bestimmen, ob Sie ein Form-Event oder ein Workflow-Event wünschen. Es öffnet sich ein kleines Fenster, über das Sie eine vorhandene Event-Handler Methode auswählen oder einfach eine neue erstellen können. MethodAssignerForm: Manche Events verfügen über spezielle EventArgs, über die Sie Kontext-Informationen des aufgetretenen Events ermitteln können. Siehe ControlDesignViewModel"
  },
  "doc/documentation/export-wizards.html": {
    "href": "doc/documentation/export-wizards.html",
    "title": "Export Wizards",
    "keywords": "Export Wizards Die wichtigste Funktion des Dokumentationssystems ist der Export in ein gängiges Format. Framework Studio bietet die Möglichkeit, automatisiert alle Dokumentationen, die an Forms, Controls, Metadatentypen usw. getätigt wurden, anhand der im Chapter Tree definierten Kapitelstruktur zu exportieren. Die Dokumentation kann als HTML Webapplikation (zum Hosten auf einem Webserver) oder als Word-Datei (.docx) exportiert werden. Zusätzlich dazu gibt es einen besonderen Modus, mit dem ausschließlich Dokumentationen von Component-Properties exportiert werden können, um diese mittels des Browser-Controls in der Endanwendung anzeigen zu können. HTML Dieser Export-Modus exportiert die gesamte Dokumentation oder ein ausgewähltes Kapitel als Webapplikation, welche auf einem beliebigen Webserver (z.B. IIS, Apache, Nginx) gehostet werden kann und somit von nahezu allen Endgeräten mit Webbrowser erreichbar ist. Der Modus HTML (Properties) ist in diesem Export-Modus integriert. Es werden alle Component-Properties von Components, die mit dem Marker {ExportDoc} markiert sind, exportiert. Der Wizard für den Export der Dokumentation als HTML Webapplikation befindet sich im Menü Tools > Documentation > Export > HTML . Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe ( orange für Warnungen, rot für Fehler). Webapplikation Nach dem Export-Vorgang befindet sich die Webapplikation im zuvor ausgewählten Ausgabeordner. Die Webapplikation ist eine HTML 5 Anwendung, die ausschließlich auf den Technologien HTML, JavaScript und CSS basiert. Damit ist sie kompatibel zu nahezu allen Endgeräten mit einem Browser ( Webapplikation Vorraussetzungen beachten). Inhalt Nach dem Öffnen der Webapplikation im Browser ist standardmäßig der Bereich Contents selektiert. Hier kann im Baum auf der linken Seite das gewünschte Kapitel ausgewählt werden, welches dann rechts im Viewer angezeigt wird. Bei einem Klick auf einen Link wird der Baum automatisch aktualisiert und zum neuen Kapitel gesprungen. Index Im Bereich Index kann der gesamte Index der Dokumentation durchsucht werden. Ist einem Index-Eintrag nur ein einziges Kapitel zugeordnet, wird dieses sofort nach dem Klick in den Baum ausgewählt. Sind einem Index-Eintrag mehrere Kapitel zugeordnet, kann das gewünschte Kapitel im Bereich Select Chapter links unten im Baum ausgewählt werden. Suche Mit Hilfe der Suchfunktion können alle Kapitel nach Wörtern durchsucht werden. In der Ergebnisliste werden dann alle Kapitel angezeigt, die das eingegebene Wort enthalten. Drucken Um den Inhalt des gerade angezeigten Kapitels zu drucken, steht der Button Print zur Verfügung. Anders als die Druckfunktion des Browsers, welche die gesamte Webapplikation inkl. Baum drucken würde, wir über den Button Print nur der Inhalt des Viewers berücksichtigt. Webapplikation Vorraussetzungen Um die von Framework Studio generierte Webapplikation zu hosten, wird einer der folgenden Webserver vorrausgesetzt: IIS 7 oder höher Apache 2.2.x oder höher Nginx 1.9 oder höher Es wird empfohlen, einen der folgenden Browser zur Anzeige der Webapplikation zu verwenden: Google Chrome Mozilla Firefox Microsoft Edge Microsoft Internet Explorer 11 Warning Internet Explorer 10 und niedriger werden NICHT unterstützt. Export mit FSConsole Neben dem Export-Wizard kann die Webapplikation auch über die FSConsole.exe ( FSConsole ) generiert werden. Hierzu gibt es die neuen Parameter \\DOCUMENTATION, \\ISO und \\OUTPUT. \\DOCUMENTATION Dieser Parameter ist nur ein Marker für die FSConsole, dass die Dokumentation gerendert werden soll. \\ISO Gibt die Sprache an, in der die Dokumentation gerendert werden soll. Der Parameter hat auch Einfluss auf die automatisch generierten Screenshots. \\OUTPUT Gibt das Verzeichnis an, in welches die Webapplikation gerendert werden soll. Zusätzlich zu den neuen Parametern müssen die obligatorischen Connection- und Package-Version Parameter angegeben werden ( \\LABELID , \\SERVER , \\DBUSER usw.) Beispiel: FSConsole.exe \\DOCUMENTATION \\ISO de \\OUTPUT „C:\\Temp\\Dokumentation“ \\PACKAGE MyPackage \\VERSION 3.8 \\CONNECTIONTYPE SqlServer \\SERVER Server01 \\DBUSER demo \\DBPASSWORD demo123 Word Der Wizard für den Export der Dokumentation als Word-Datei (.docx) befindet sich im Menü Tools > Documentation > Export > Word . Wizard-Optionen Die Baumansicht bietet die Struktur des Release-Knotens an. Hier muss ausgewählt werden, welches Kapitel exportiert werden soll. Wird der Release-Knoten selbst angewählt, wird die gesamte Dokumentation, die im Framework Studio hinterlegt ist, exportiert. Title Page Wird diese Option aktiviert, wird in der Word-Datei zusätzlich ein Deckblatt mit dem definierten Titel und Info Text generiert. Language Definiert die Sprache, für die die Dokumentation exportiert werden soll. Dies ändert auch die Sprache der automatisch generierten Screenshots (siehe Screenshot ). Create TOC Erstellt ein Inhaltsverzeichnis für alle in der Dokumentation enthaltenen Kapitel am Anfang der Word-Datei. Create Index Erstellt einen Index für alle Kapitel und manuell in den Dokumentationen definierten Indexeinträgen am Ende der Word-Datei. Die Überschrift jedes Kapitels aus dem Chapter Tree wird automatisch zum Index hinzugefügt. Include Tooltips Ist an einem Steuerelement eines Formulars ein Tooltip hinterlegt, wird dieser mit in die Dokumentation des Steuerelements aufgenommen. Doc2Help Zusätzlich zum Indexeintrag wird jede Kapitelüberschrift mit einer zusätzlichen Formatvorlage versehen, die es Doc2Help erlaubt, einen Verweis über eine Url in der Onlinehilfe auf das jeweilige Kapitel zu generieren. Für mehr Information hierzu siehe Kapitel Doc2Help . Export-Vorgang Für den eigentlichen Export-Vorgang wird ein Dialog mit Statusinformationen bereitgestellt. Über den Button Abort kann der Vorgang jederzeit abgebrochen werden. Treten beim Export-Vorgang Infos, Warnungen oder Fehler auf, werden diese detailliert in das Ausgabefenster protokolliert und der Statustext ändert ggf. seine Farbe ( orange für Warnungen, rot für Fehler). Besonderheit bei TOC und Index Wurde im Export Wizard eine der Optionen Create TOC oder Create Index ausgewählt, muss Microsoft Word (2007 oder höher) auf dem PC installiert sein, um das Inhaltsverzeichnis oder den Index nach einem erfolgreichem Exportvorgang zu aktualisieren. Zu diesem Zweck wird nach dem Speichern der docx-Datei auf der Festplatte diese automatisch von Framework Studio aus mit Word geöffnet (als Prozess - es wird kein Fenster geöffnet) und eine Aktualisierung der jeweiligen Kataloge angestoßen. Anschließend wird die Datei nochmals gespeichert und Word geschlossen. Im Ausgabefenster des Export-Vorgangs ist zu erkennen, dass seitens Framework Studio geprüft wird, ob Word installiert ist. Sollte dies nicht der Fall sein, werden im exportierten Dokument zwar ein Inhaltsverzeichnis und ein Index enthalten sein, die jedoch aufgrund der fehlenden Aktualisierung keine Einträge enthalten. In diesem Fall muss die Aktualisierung der Kataloge manuell mit Word durchgeführt werden. HTML (Properties) Zusätzlich zu den anderen Modi steht ein weiterer Export-Modus zur Verfügung. Dieser ist in der Lage, ausschließlich Dokumentationen von Component-Properties in einzelne HTML-Dateien zu rendern. Er renderd also nicht wie der HTML- oder Word-Exporter die gesamte zur Verfügung stehende Dokumentation, sondern nur ausgewählte Component-Properties. Soll die Dokumentation eines Component-Properties z.B. an der Oberfläche der Endanwendung angezeigt werden, ist dies nun mit Hilfe des Browser-Controls möglich. Der neue Export-Modus befindet sich wie nun auch der bisherige Word-Export-Modus im Menü Tools > Documentation > Export > HTML (Properties) . Markieren der Components Eine Endanwendung besteht im Normalfall aus extrem vielen Components und Component-Properties. Der neue Export-Modus wird aber meist nur für einen gewissen Bereich der Anwendung benötigt. Deshalb muss auf Component-Ebene definiert werden, welche Components beim neuen Export-Modus beachtet werden sollen. Um eine Component für den neuen Modus zu markieren, muss die Zeichenfolge \"{ExportDoc}\" in das Description-Feld der Component eingetragen werden. Nun werden beim Export alle dokumentierten Properties der markierten Component exportiert. Wizard-Optionen Wird der neue Export-Dialog aufgerufen, wird eine Übersicht mit allen markierten Components angezeigt. Language Definiert die Sprache, in der die Component-Properties gerendert werden sollen Include Tooltips Definiert, ob an den Component-Properties definierte Tooltips zuzüglich zur eigentlichen Dokumentation gerendert werden sollen. Output Directory Über den Button […] muss ein Zielverzeichnis für den HTML-Export definiert werden. Dieses Verzeichnis muss leer sein. Export-Vorgang Es kann nachvollzogen werden, welche Properties Dokumentationen beinhalten und gerendert werden. Sollte nach dem Export-Vorgang festgestellt werden, dass keine Bilder gerendert wurden, wird das zuvor erstellte Verzeichnis images wieder gelöscht. Ausgabe Beim Export wird jedes Property einer markierten Component durchlaufen und in eine separate .html-Datei geschrieben. Der Name dieser Dateien setzt sich allein aus dem Namespace-Pfad des Properties zusammen. Wird der Export-Ordner nun an einem im Netzwerk zugänglichen Pfad abgelegt (vorzugsweise auf dem Webserver, auf dem auch schon die bisherige Dokumentation liegt), können die Property-Dokumentationen in der Endanwendung mittels eines Browser-Controls eingebunden werden. Struktur der Ausgabe Der größte Vorteil der Generierung der Anwendungsdokumentation mit Framework Studio ist die strukturierte Ausgabe. Ziel ist es, jedes Kapitel bzw. Formular in genau demselben Schema auszugeben. Dokumentations-Elemente sind hier sehr einfach gehalten, da sie nur eine Dokumentation enthalten. Sie werden als einzelnes Kapitel mit dem zugehörigen Text gerendert. Formulare hingegen bestehen aus vielen Steuerelementen und ggf. Menüeinträgen, die wiederum ihre eigene Dokumentation beinhalten. Hier folgt Framework Studio folgendem Schema: Die Dokumentation eines Formulars beginnt wie ein Documentation-Element mit einem eigenen Kapitel. Danach folgt die Formular-Dokumentation. Die Steuerelemente werden anhand ihrer Position auf dem Form abgearbeitet. Es wird von links nach rechts und von oben nach unten gearbeitet. Wenn ein Steuerelement andere Steuerelemente beinhaltet (z.B. Registerkarten oder Tabellen) werden diese inneren Steuerelemente nach demselben Schema abgearbeitet. Sind alle Steuerelemente gerendert, folgt zum Schluss die Ausgabe der Menüeinträge. Zur Verdeutlichung folgen einige Beispiele in Microsoft Word. Ausgabe einer Dokumentation eines Documentation-Elements: Ausgabe eines Formulars unterhalb eines Documentation-Elements: In diesem Beispiel ist zu sehen, dass im Chapter Tree das Formular Kassenparameter unterhalb des Documentation-Elements Kasse eingefügt wurde. In der Formular-Dokumentation wurde ein automatisch generierter Screenshot eingefügt. Ausgabe der Steuerelemente eines Formulars: In diesem Beispiel ist die Ausgabe der Steuerelemente eines Formulars zu sehen. Ist ein Steuerelement ein Container (d.h. beinhaltet andere Steuerelemente) wird dies mit horizontalen Linien verdeutlicht. Es ist zu erkennen, dass die Buttons Speichern , Schließen , Customizing und Hilfe innerhalb des Panels Haupt-Buttonleiste liegen. Zusätzlich ist erkennbar, dass die Bezeichnungsfelder Gutsch.kürzel und Rechn.kürzel Tooltip-Informationen enthalten, die automatisch mit in die Dokumentation aufgenommen wurden (Checkbox Include Tooltips in den Wizard-Optionen ). Ausgabe der Bilder bei Steuerelementen Es gibt einige Steuerelemente in Framework Studio, die Bilder anzeigen (z.B. ImageButtons). Um das Auffinden eines solchen Steuerelements in der Dokumentation zu vereinfachen, kann in der Ausgabe des Steuerelements das zugehörige Bild mit angezeigt werden. ImageButtons mit Bild in der Dokumentation: Ob das Bild in der Dokumentation des Steuerelements mit angezeigt wird oder nicht, hängt von einem Schalter direkt am Steuerelement ab. Einstellung zur Anzeige des Bildes in der Dokumentation des Steuerelements: Diese Einstellung kann auch global über die DefaultControlStyles für den jeweiligen Control-Typ definiert werden. Einstellung der Bildanzeige am DefaultControlStyle: Registerkarten als separate Kapitel ausgeben Registerkarten beinhalten in Anwendungen oft Funktionalitäten, die in einer Dokumentation als separates Kapitel betrachtet werden sollte. Standardmäßig werden Registerkarte in der Dokumentation genauso wie andere Container-Steuerelemente in der Liste der Steuerelemente des Formulars mit ausgegeben. Dieses Verhalten ist nicht immer gewünscht, vor allem wenn eine Registerkarte sehr viele Steuerelemente und komplexere Vorgänge beinhaltet. Um für jede Registerkarte eines Registerkartes unterhalb eines Formulars ein eigenes Kapitel in der Dokumentation zu eröffnen, gibt es die Option ChaptersForTabs am Registerkarte. Registerkarten als separate Kapitel Ausgeben: Wird diese Option auf True gesetzt, werden beim Exportieren des Formulars für jede Registerkarte des Registerkartes ein eigenes Kapitel mit eigenem Indexeintrag erstellt. Generierung separater Kapitel für Registerkarten: In der Liste der Steuerelemente, in der die Registerkarten normalerweise ausgegeben werden, befindet sich dann nur noch ein Link auf das entsprechende Unterkapitel. Caution Die Option ChapterForTabs kann je Formular nur für ein einziges Registerkarte auf True gesetzt werden. Vorschau eines ganzen Formulars Die Preview-Ansicht des Dokumentations-Editors zeigt immer nur die Ausgabe des im Editor befindlichen DocML . Um eine Vorstellung zu bekommen, wie ein ganzes Formular in der Endfassung aussieht, kann dieses komplett mit der Steuerelementauflistung und den Menüeinträgen in ein Vorschaufenster gerendert werden. Hierzu reicht im Documenation-Editor ein Klick auf den Link View Render Chapter . Es wird die in der Combobox Language angegebene Sprache verwendet. Dieser Link steht auch im Documentation-Editor der TabPage zur Verfügung. Diese bilden in der Regel ein eigenes Chapter und werden nicht in der Preview des Forms angezeigt. Vollständige Voransicht eines Formulars rendern: Unterstützung von Themes Die Einstellung des Themes in Framework Studio hat unmittelbare Auswirkungen auf die Ausgabe der Dokumentation mittels des Export Wizards. Diese Abhängigkeit betrifft in Framework Studio eingebundene Ressourcen sowie auch die automatisch generierten Screenshots über das Screenshot-Tag (siehe Screenshot ) in der Formular-Dokumentation. Im folgenden Beispiel wurde eine Dokumentation eines Formulars mit zwei unterschiedlichen Themes exportiert, was zu anderen automatisch generierten Screenshots in der Dokumentation führt. Dokumentation exportiert mit Theme 1: Dokumentation exportiert mit Theme 2: fsconsole! Warning TODO fsconsole link!"
  },
  "doc/documentation/dokumentations-system.html": {
    "href": "doc/documentation/dokumentations-system.html",
    "title": "Dokumentations-System",
    "keywords": "Dokumentations-System Framework Studio bietet die Möglichkeit, die entwickelten Applikationen mittels eines in die IDE integrierten Dokumentationssystems zu dokumentieren. Im Gegensatz zu herkömmlichen Dokumentationen mittels Microsoft Word oder Latex bietet das System jedoch gravierende Vorteile, da es komplett an die Datenstruktur und –hierarchie von Framework Studio angepasst ist. Features Um den Einstieg in das Dokumentationssystem zu vereinfachen, werden im Folgenden die wichtigsten Features vorgestellt. Automatische Generierung der Dokumentationsstruktur „Wo steht was?“ ist ein großes Problem im Bereich Dokumentation. Ein Mitarbeiter beschreibt erst die Steuerelemente des Formulars und danach dessen Funktionalität, ein anderer macht es genau anders herum. Framework Studio trennt sich vom klassischen Weg der Dokumentationserstellung. Egal, ob die Dokumentation später als Word oder HTML exportiert wird, die Struktur bleibt dieselbe. Jedes Formular folgt dem gleichen Schema, alles hat seinen zugewiesenen Platz durch vordefinierte Formatvorlagen seitens Framework Studio. Vererbung vom Metadatentyp bis zum Steuerelement Hinter fast jedem Steuerelement in Framework Studio verbirgt sich als DataSource ein Component Property, eine DBColumn oder ein Metadatentyp . Hier verhält sich die Dokumentation ähnlich wie die Tooltips. Wird ein Metadatentyp dokumentiert, steht diese Dokumentation auch am Steuerelement zur Verfügung und wird in die endgültige Fassung herausgerendert. Dokumentationen können vererbt, gecustomized und überschrieben werden, sollte sich z.B. der Kontext in einem Formular ändern. Customizing und Package-Struktur Das Herz von Framework Studio bildet das Package-System. Das Dokumentationssystem folgt diesem und bietet voll Customizing-fähige Dokumentationen über Package-Grenzen hinweg. Vererben, überschreiben, anhängen, austauschen… die Dokumentation ist anpassbar bis zum letzten Satz. Mehrsprachigkeit Erfassen Sie die Dokumentation in allen möglichen Sprachen. Der Dokumentationseditor unterstützt das parallele Bearbeiten von mehreren Sprachen. Wenn Sie die englische Dokumentation schreiben, nehmen Sie sich einfach die deutsche Dokumentation als Vorlage für die Übersetzung zur Hand. Screenshot-Generierung Screenshot erstellen, in das Grafikprogramm laden, den Ausschnitt zurechtschneiden, Screenshot in das Dokument einfügen, Größe anpassen… und nach einer Woche ist der Screenshot veraltet, weil drei neue Steuerelemente hinzugekommen sind. Um dieses Problem aus dem Weg zu schaffen, bietet das Dokumentationssystem eine Screenshot-Generierung für Formulare. Bei jedem Herausschreiben der Dokumentation wird von Framework Studio anhand der Steuerelementdaten des Designers ein Screenshot des Formulars erstellt und automatisch in die Dokumentation eingefügt. So sind die Masken in der Dokumentation stets auf dem neuesten Stand und der Benutzer findet jedes Steuerelement wo er es erwartet. Theme Support In Framework Studio 3.5 hielten Themes Einzug in die IDE. Die Dokumentation lässt sich für verschiedene Themes rendern. Sind beispielsweise automatisch generierte Screenshots in die Dokumentation eingebunden, werden diese im jeweiligen Theme gerendert. Auch für eingebundene Bilder können je Theme unterschiedliche Bilder definiert werden. Aufbau des Dokumentationssystems Die beiden Elemente, die das Fundament des Dokumentationssystems bilden, sind das Form- und das Documentation-Element (siehe Documentation-Element ). Diese Elemente werden mittels einer Baumstruktur (siehe Chapter Tree ) in Kapitel unterteilt. Somit bildet jedes Form- oder Documentation-Element ein Kapitel mit eigener Kapitelnummer in der fertigen Dokumentation ab. Form Sie erkennen Form an einem -Icon. Elemente des Forms mit Dokumentation: Ein Form definiert sich grundsätzlich durch dessen Controls. Jedes Control kann eine DataSource zugewiesen haben, die über ein Component Property auf eine DBColumn verweist, die wiederum einen Wert eines Metadatatypes kapseln kann. Diesem Mechanismus folgt das Dokumentationssystem. Es besteht die Möglichkeit, auf jeder einzelnen Ebene in Framework Studio eine Dokumentation zu hinterlegen, die von der nächst höheren Instanz verwendet werden kann (siehe Vererbung ). So können am Metadatentyp z.B. Informationen zum Wertebereich oder zur Genauigkeit angegeben werden. In der Dokumentation des Controls, welches auf diesen Metadatentyp verweist, kann z.B. die Dokumentation des Metadatentyps eingebunden werden und steht dem Leser somit als zusätzliche Information zur Verfügung. Während in der Dokumentation eines Controls ausschließlich auf die Funktion dessen eingegangen werden sollte, dient die Dokumentation des Formulars der generellen Beschreibung, d.h. es können beliebige Texte verfasst werden, die die Funktionalität des Formulars im Gesamten beschreibt. So können Beispiele, Prozesse, Arbeitsanweisungen usw. beschrieben werden. Im Gegensatz zu den Control-Dokumentationen werden Form-Dokumentationen in sogenannte Sections unterteilt. Diese dienen als Text-Trenner für das Customizing (siehe Customizing ). Documentation-Element Sie erkennen Documentation-Element an einem -Icon. Die meisten Dokumentationen einer Anwendung beziehen sich auf ein oder mehrere Formulare. Oft muss aber auch ein Hintergrundprozess wie z.B. eine Preisfindung oder ein Importvorgang dokumentiert werden, für den es keine visuelle Repräsentation gibt. Für diesen Zweck bietet Frameworks Studio die Documentation-Elemente. Sie sind eigenständige Elemente wie Forms, Workflows oder Components und können wie diese ein- und ausgecheckt werden. Documentation-Elemente im Namespace TreeView: Die Documentation-Elemente bestehen nur aus einem einzigen Dokumentationseditor. Wie Forms bildet jedes Documentation-Element in der fertigen Dokumentation ein eigenes Kapitel mit eigener Kapitelnummer ab. Anwendungsfall für ein Documentation-Element: Wenn auf einem Formular ein Button existiert, welcher z.B. den Preis eines Artikels anhand eingegebener Konditionen berechnet, könnte der Kalkulationsprozess dokumentiert werden. Hier bietet sich ein Documentation-Element an. In diesem wird der Kalkulationsablauf im Detail beschrieben, ohne Bezug auf das Formular oder den Button, von dem der Prozess ausgelöst wird. In der Dokumentation des Button-Controls kann nun ein Verweis auf das Documentation-Element eingefügt werden, welcher in der fertigen Dokumentation als Hyperlink verfügbar ist. Der große Vorteil ist: Sollte in einem anderen Programmteil derselbe Kalkulationsprozess aufgerufen werden, müsste dort nur auf das bereits existierende Documentation-Element verwiesen werden, ganz nach dem Motto „write once, read anywhere“ ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MinSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MinSize.html",
    "title": "Property MinSize",
    "keywords": "Property MinSize | Improve this Doc View Source MinSize Gibt die minimale Größe des Controls an.Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin.Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize MinSize { get; set; } Property Value NonableSize Remarks Der spezielle Wert None definiert keine Angabe der Größe.Er muss vom Wert 0 unterschieden werden."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Padding.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Padding.html",
    "title": "Property Padding",
    "keywords": "Property Padding | Improve this Doc View Source Padding Gibt den inneren Rand des Controls – also den Abstand des Control-Inhalts zur Border an.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds Padding { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Margin.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Margin.html",
    "title": "Property Margin",
    "keywords": "Property Margin | Improve this Doc View Source Margin Gibt den äußeren Rand um das Control herum an. Der Margin wird nicht in die Größe des Controls hineingerechnet. Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public Bounds Margin { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BackColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BackColor.html",
    "title": "Property BackColor",
    "keywords": "Property BackColor | Improve this Doc View Source BackColor Gibt die Hintergrund-Farbe des Controls an. Über den Alpha-Kanal (Transparenz-Wert) der Farbe kann die Transparenz des Controls gesteuert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? BackColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ForeColor.html",
    "title": "Property ForeColor",
    "keywords": "Property ForeColor | Improve this Doc View Source ForeColor Schriftfarbe. Über das die Action SetForeColor(Nullable<Color>) kann die Farbe zur Laufzeit geändert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? ForeColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Gibt eine mehrsprachige Beschriftung des Controls an. Je nach Control wird diese entweder selber vom Control angezeigt (z.B. Button, ImageButton, Label) oder es wird durch das [FieldPanel](!TODO LINK) ein Label mit dieser Beschriftung generiert (z.B. Editfield, Combobox). Declaration [Browsable(true)] [ControlStylesBrowsable] public virtual IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Remarks Auch wenn die Beschriftung nicht direkt in der Oberfläche angezeigt wird, kann es dennoch sinnvoll sein, sie anzugeben. Sie wird dann z.B. in der Dokumentation benutzt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CtrlStyleName.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.CtrlStyleName.html",
    "title": "Property CtrlStyleName",
    "keywords": "Property CtrlStyleName | Improve this Doc View Source CtrlStyleName Declaration [Browsable(true)] public string CtrlStyleName { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TooltipText.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TooltipText.html",
    "title": "Property TooltipText",
    "keywords": "Property TooltipText | Improve this Doc View Source TooltipText Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Control, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Declaration [ControlStylesBrowsable(true)] public IMLString TooltipText { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Font.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Font.html",
    "title": "Property Font",
    "keywords": "Property Font | Improve this Doc View Source Font Hier kann die Schrift des Controls eingestellt werden. Die Unter-Properties Family , Size , Bold , Italic und Underline können jeweils getrennt voneinander überschrieben werden. Die Size definiert, wieviel Pixel Platz die Schrift insgesamt bei einer Skalierung von 100% verbraucht.Somit ergibt sich aus Summe der Size und den Properties Padding, BorderThickness und Margin die tatsächliche Höhe des Controls. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ControlFont Font { get; set; } Property Value ControlFont"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Alignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Alignment.html",
    "title": "Property Alignment",
    "keywords": "Property Alignment | Improve this Doc View Source Alignment Gibt an, wie sich das Control in seinem Container ausrichten soll. Standardwerte sind Stretch und Stretch Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(AlignmentObjectConverter<HorizontalAlignment, VerticalAlignment>))] public Alignment<HorizontalAlignment, VerticalAlignment> Alignment { get; set; } Property Value Alignment < HorizontalAlignment , VerticalAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TabStop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.TabStop.html",
    "title": "Property TabStop",
    "keywords": "Property TabStop | Improve this Doc View Source TabStop Wenn dieses Property den Wert true besitzt, wird das Steuerelement bei der Fokustraversierung mittels Tastatur erfasst. Ist es auf false , so wird das Steuerelement bei der Tab-Reihenfolge überspringen. Der Standardwert für die Eigenschaft ist true . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? TabStop { get; set; } Property Value Nullable < Boolean > Remarks Sie ist nicht Theme-fähig und kann an allen Steuerelementen mit Ausnahme der folgenden gesetzt werden: Alle Container-Steuerelemente Grid Columns Labels Pictures Tree View Columns Tree View Nodes Menus Custom Controls"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable | Improve this Doc View Source IsEditable Wenn hier true gesetzt ist, ist das Control editierbar. Ansonsten ist das Control für Eingaben gesperrt. Über die Action SetEnabled(Nullable<Boolean>) kann das Control zur Laufzeit gesperrt werden. Declaration [Browsable(true)] public virtual bool? IsEditable { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditableAU.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsEditableAU.html",
    "title": "Property IsEditableAU",
    "keywords": "Property IsEditableAU | Improve this Doc View Source IsEditableAU Das IsEditable Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) Declaration [Browsable(true)] public virtual AccessUnitList IsEditableAU { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.AUList.AccessUnitList"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Visibility.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Visibility.html",
    "title": "Property Visibility",
    "keywords": "Property Visibility | Improve this Doc View Source Visibility Steuert die Sichtbarkeit des Controls. Über die Control-Action SetVisible(Nullable<FSVisibility>) kann die Eigenschaft zur Laufzeit geändert werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public FSVisibility? Visibility { get; set; } Property Value Nullable < FSVisibility >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsVisibleAU.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsVisibleAU.html",
    "title": "Property IsVisibleAU",
    "keywords": "Property IsVisibleAU | Improve this Doc View Source IsVisibleAU Das IsVisible Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) Declaration [Browsable(true)] public virtual AccessUnitList IsVisibleAU { get; set; } Property Value FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.AUList.AccessUnitList"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsSearchField.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.IsSearchField.html",
    "title": "Property IsSearchField",
    "keywords": "Property IsSearchField | Improve this Doc View Source IsSearchField Soll sich das Control in die automatisch generierte Load-Condition eintragen, muss dieses Property auf True gesetzt werden. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [Browsable(true)] public bool? IsSearchField { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Top.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Top.html",
    "title": "Property Top",
    "keywords": "Property Top | Improve this Doc View Source Top Declaration public int? Top { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Bottom.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Bottom.html",
    "title": "Property Bottom",
    "keywords": "Property Bottom | Improve this Doc View Source Bottom Declaration public int? Bottom { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.html",
    "title": "Class Bounds",
    "keywords": "Class Bounds TODO Inheritance Object Bounds Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(ControlBoundsTypeConverter))] public class Bounds Properties Bottom Left Right Top"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopLeft.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopLeft.html",
    "title": "Property TopLeft",
    "keywords": "Property TopLeft | Improve this Doc View Source TopLeft Declaration public int? TopLeft { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopRight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.TopRight.html",
    "title": "Property TopRight",
    "keywords": "Property TopRight | Improve this Doc View Source TopRight Declaration public int? TopRight { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomRight.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomRight.html",
    "title": "Property BottomRight",
    "keywords": "Property BottomRight | Improve this Doc View Source BottomRight Declaration public int? BottomRight { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomLeft.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.BottomLeft.html",
    "title": "Property BottomLeft",
    "keywords": "Property BottomLeft | Improve this Doc View Source BottomLeft Declaration public int? BottomLeft { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.BorderRadius.html",
    "title": "Class BorderRadius",
    "keywords": "Class BorderRadius Inheritance Object BorderRadius Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax [TypeConverter(typeof(BorderRadiusTypeConverter))] public class BorderRadius Properties BottomLeft BottomRight TopLeft TopRight"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Classes ListDataSource Summary description for DataBinding."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ContainsNullEntry.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry | Improve this Doc View Source ContainsNullEntry Gibt an, ob die Liste einen leeren Eintrag beinhalten soll.Bei True wird die Liste um einen leeren Eintrag ergänzt.Dieser Eintrag wird ausgewählt, wenn der Wert der Combobox auf kein Value aus der Liste zutrifft. Wird dieser Eintrag vom Benutzer ausgewählt, wird dem dahinterliegenden Property Null zugewiesen. Declaration [Browsable(true)] public bool? ContainsNullEntry { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.DisplayMember.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember | Improve this Doc View Source DisplayMember Gibt an, welches Property des Datasources in der Liste angezeigt werden soll. Bei einer Textcollection ist das in der Regel Text . Declaration [Browsable(true)] [TypeConverter(typeof(ListDataSource.CollectionConverter))] public virtual IPropertyRecord DisplayMember { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IPropertyRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ValueMember.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember | Improve this Doc View Source ValueMember Gibt an, welches Property des Datasources den Wert eines Eintrags darstellt. Es ist immer der Eintrag ausgewählt, dessen Value gleich dem Wert der Combobox ist. Bei einer Textcollection ist das in der Regel ID . Declaration [Browsable(true)] [TypeConverter(typeof(ListDataSource.CollectionConverter))] public IPropertyRecord ValueMember { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IPropertyRecord"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.ListDataSource.html",
    "title": "Class ListDataSource",
    "keywords": "Class ListDataSource Summary description for DataBinding. Inheritance Object ListDataSource Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax [Serializable] [TypeConverter(typeof(ExpandableObjectConverter))] public class ListDataSource : INVFrameworkList, ICloneable, ICustomTypeDescriptor Properties ContainsNullEntry Gibt an, ob die Liste einen leeren Eintrag beinhalten soll.Bei True wird die Liste um einen leeren Eintrag ergänzt.Dieser Eintrag wird ausgewählt, wenn der Wert der Combobox auf kein Value aus der Liste zutrifft. Wird dieser Eintrag vom Benutzer ausgewählt, wird dem dahinterliegenden Property Null zugewiesen. DisplayMember Gibt an, welches Property des Datasources in der Liste angezeigt werden soll. Bei einer Textcollection ist das in der Regel Text . ValueMember Gibt an, welches Property des Datasources den Wert eines Eintrags darstellt. Es ist immer der Eintrag ausgewählt, dessen Value gleich dem Wert der Combobox ist. Bei einer Textcollection ist das in der Regel ID ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.Multiselect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.Multiselect.html",
    "title": "Property Multiselect",
    "keywords": "Property Multiselect | Improve this Doc View Source Multiselect Wenn grundsätzlich mehrere Einträge ausgewählt werden können sollen, muss dieses Property auf True gesetzt werden. Ist es auf False gesetzt, kann nur genau ein Eintrag ausgewählt werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? Multiselect { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.SelectedEntries.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.SelectedEntries.html",
    "title": "Property SelectedEntries",
    "keywords": "Property SelectedEntries | Improve this Doc View Source SelectedEntries Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Einträge in der Listbox markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public IDatasource SelectedEntries { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Remarks Eine Collection ist eine Sammlung von mehreren Objekten. Um Objekte in dieser Collection anzusprechen, gibt es verschiedene Möglichkeiten. Sie können einerseits über die ID an ein Objekt herankommen ( Collection[ID] ), andererseits können Sie auch über die guid Objekte ansprechen (Collection[guid]). So können Sie direkt mit den guids aus der SelectedRowsCollection die entsprechenden Objekte aus dem Datasource ansprechen: Beispiel: // SelectedRowsCollection im Form-Event auswerten (oMyColl ist Datasource der Listbox) foreach ( guid guidrow in oSelectedRowsColl ) { oMyColl[guidrow].MyFunction( ); } Es ist auch ganz einfach selbst dafür zu sorgen, welche Einträge ausgewählt werden: Beispiel: // Manuell Einträge in einer Listbox markieren (oMyColl ist Datasource der Listbox) // SelectedRowsCollection leeren (keine Einträge ausgewählt) oSelectedRowsColl.Clear( ); // Wenn eine bestimmte Bedingung erfüllt ist, entsprechende Einträge selektieren foreach (cMyComponent oMyObjectTemp in oMyColl) { if MyObjectTemp.MyProperty > 10 oSelectedRowsColl.Add( MyObjectTemp ); }"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.OnSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.OnSelectionChanged.html",
    "title": "Event OnSelectionChanged",
    "keywords": "Event OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnSelectionChanged Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListboxDesignViewModel.html",
    "title": "Class ListboxDesignViewModel",
    "keywords": "Class ListboxDesignViewModel Diese Klasse repräsentiert das Control Listbox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ListboxDesignViewModel Inherited Members ListBaseDesignViewModel.List ListBaseDesignViewModel.ListSortOrder ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ListboxDesignViewModel : ListBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Multiselect Wenn grundsätzlich mehrere Einträge ausgewählt werden können sollen, muss dieses Property auf True gesetzt werden. Ist es auf False gesetzt, kann nur genau ein Eintrag ausgewählt werden. SelectedEntries Hier kann ein Form Property zugeordnet werden, das sich merkt, welche Einträge in der Listbox markiert sind. Dieses Property muss vom Typ SelectedRowsCollection sein. Diese Collection enthält guids. Events OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. See Also ListBoxControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.List.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.List.html",
    "title": "Property List",
    "keywords": "Property List | Improve this Doc View Source List Gibt den Datasource für die Liste der Einträge der Combobox an. Es können Collections und TextCollections ausgewählt werden. Declaration [Browsable(true)] [TypeConverter(typeof(DataBindingConverter))] public ListDataSource List { get; set; } Property Value ListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder | Improve this Doc View Source ListSortOrder Gibt an, ob und wie die Einträge der Liste sortiert werden sollen.Für die Sortierung ist das DisplayMember ausschlaggebend.Ist Unsorted eingestellt, werden die Einträge in der Reihenfolge angezeigt, wie sie in der Collection stehen.Den Collections kann beim Load() eine SortOrder mitgegeben werden und TextCollections sind immer aufsteigend nach ID sortiert. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ListSortOrder? ListSortOrder { get; set; } Property Value Nullable < ListSortOrder >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ListBaseDesignViewModel.html",
    "title": "Class ListBaseDesignViewModel",
    "keywords": "Class ListBaseDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ComboboxDesignViewModel ListboxDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ListBaseDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties List Gibt den Datasource für die Liste der Einträge der Combobox an. Es können Collections und TextCollections ausgewählt werden. ListSortOrder Gibt an, ob und wie die Einträge der Liste sortiert werden sollen.Für die Sortierung ist das DisplayMember ausschlaggebend.Ist Unsorted eingestellt, werden die Einträge in der Reihenfolge angezeigt, wie sie in der Collection stehen.Den Collections kann beim Load() eine SortOrder mitgegeben werden und TextCollections sind immer aufsteigend nach ID sortiert."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.GenerateDocSection.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.GenerateDocSection.html",
    "title": "Property GenerateDocSection",
    "keywords": "Property GenerateDocSection | Improve this Doc View Source GenerateDocSection Gibt an, ob in der Dokumentation für den Container ein separates Kapitel generiert werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? GenerateDocSection { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContainerDesignViewModel.html",
    "title": "Class ContainerDesignViewModel",
    "keywords": "Class ContainerDesignViewModel TODO Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FieldRowDesignViewModel GridDesignViewModel MainMenuDesignViewModel TabbedWindowDesignViewModel TabPageDesignViewModel TreeNodeDesignViewModel TreeViewDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ContainerDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties GenerateDocSection Gibt an, ob in der Dokumentation für den Container ein separates Kapitel generiert werden soll."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle | Improve this Doc View Source EditStyle TODO Declaration [Browsable(true)] public ComboEditStyle? EditStyle { get; set; } Property Value Nullable < ComboEditStyle >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.MaxDropDownSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.MaxDropDownSize.html",
    "title": "Property MaxDropDownSize",
    "keywords": "Property MaxDropDownSize | Improve this Doc View Source MaxDropDownSize TODO Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public virtual Size MaxDropDownSize { get; set; } Property Value Size"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.OnSelectionChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.OnSelectionChanged.html",
    "title": "Event OnSelectionChanged",
    "keywords": "Event OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkSelectionChangedEventArgs> OnSelectionChanged Returns Type Description EventHandler < FrameworkSelectionChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ComboboxDesignViewModel.html",
    "title": "Class ComboboxDesignViewModel",
    "keywords": "Class ComboboxDesignViewModel Diese Klasse repräsentiert das Control Combobox . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ListBaseDesignViewModel ComboboxDesignViewModel Inherited Members ListBaseDesignViewModel.List ListBaseDesignViewModel.ListSortOrder ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ComboboxDesignViewModel : ListBaseDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties EditStyle TODO MaxDropDownSize TODO Events OnSelectionChanged Tritt ein, wenn der Benutzer den ausgewählten Eintrag ändert. See Also ComboBoxControlAction"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.ExpandTreeView.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.ExpandTreeView.html",
    "title": "Method ExpandTreeView",
    "keywords": "Method ExpandTreeView | Improve this Doc View Source ExpandTreeView() Expandiert den TreeView vollständig. Declaration public virtual void ExpandTreeView() | Improve this Doc View Source ExpandTreeView(Int32) Expandiert den TreeView bis zu der Ebene, die mit dem Parameter level festgelegt wird. Declaration public virtual void ExpandTreeView(int level) Parameters level Int32 | Improve this Doc View Source ExpandTreeView(String) Expandiert den Pfad im TreeView, der durch den Parameter path festgelegt wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll (Unterknoten des zuletzt genannten Knotens werden nicht angezeigt). Jeder Knoten wird durch einen Punkt (.) vom nächsten Knoten getrennt. Jeder Knoten wird durch ObjectRowID Semikolon und Name des TreeNodes angegeben. Declaration public virtual void ExpandTreeView(string path) Parameters path String Examples „3197;tndStructureElement.52f3;tndStructureElementChild.4f04a4;tndPhaseElement“ Die Namen der Nodes können auch durch “NN” ersetzt werden.Z.B: „3197; NN.52f3;NN.4f04a4;NN“ | Improve this Doc View Source ExpandTreeView(IDevFrameworkObject[]) Expandiert den Pfad im TreeView, der durch die Objekte objectPath definiert wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll. Die Unterknoten des im Pfad zuletzt genannten Knotens werden also nicht angezeigt. Declaration public virtual void ExpandTreeView(IDevFrameworkObject[] objectPath) Parameters objectPath IDevFrameworkObject [] Remarks Intern wird ein Pfad aufgebaut. Der Pfad enthält - anstatt des korrekten Knotennamens - den Zusatz NN. Examples ExpandTreeView( new IDevFrameworkObject[ ]{ oObject.oParent.oParent, oObject.oParent, oObject} );"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.SelectTreeNode.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.SelectTreeNode.html",
    "title": "Method SelectTreeNode",
    "keywords": "Method SelectTreeNode | Improve this Doc View Source SelectTreeNode(IDevFrameworkObject[]) Diese Action dient zum Selektieren eines Knotens im TreeView. Sie ist an die ExpandTreeView() Action angelehnt und hat somit auch mehrere Aufrufmöglichkeiten. Entweder mit einem String, welcher einen Pfad zu einem Knoten über die RowID und Knotennamen beschreibt, oder durch eine Liste mit IDevFrameworkObjects. Declaration public virtual void SelectTreeNode(IDevFrameworkObject[] objectPath) Parameters objectPath IDevFrameworkObject [] Remarks Hintergrund zum Objekt-Pfad: Der TreeView arbeitet mit LazyLoading – d.h.der Client liest Einträge bei Bedarf vom Broker nach.Dadurch ist der komplette Baum – der mitunter extrem komplex sein kann – im Client nicht bekannt.Ein einzelner Eintrag müsste sehr aufwendig im Baum gesucht werden, was im extremsten Fall bedeutet, dass der komplette Baum an den Client übertragen werden müsste. Bei einem Baum mit 5 Ebenen und jeweils 10 Knoten wären das 11.111 Requests und 111.110 Datensätze. Durch die Angabe des Pfades kann der Client ganz gezielt die benötigten Baum-Teile nachlesen. In diesem Beispiel wären das 5 Requests und nur 50 Datensätze."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TreeViewControlAction.html",
    "title": "Class TreeViewControlAction",
    "keywords": "Class TreeViewControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TreeViewControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TreeViewControlAction : EditableControlAction, ISerializable, ITreeViewControlAction, IFrameworkControlActionBase Methods ExpandTreeView() Expandiert den TreeView vollständig. ExpandTreeView(IDevFrameworkObject[]) Expandiert den Pfad im TreeView, der durch die Objekte objectPath definiert wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll. Die Unterknoten des im Pfad zuletzt genannten Knotens werden also nicht angezeigt. ExpandTreeView(Int32) Expandiert den TreeView bis zu der Ebene, die mit dem Parameter level festgelegt wird. ExpandTreeView(String) Expandiert den Pfad im TreeView, der durch den Parameter path festgelegt wird. Der Pfad beginnt mit dem Wurzelknoten und endet mit dem Knoten, der angezeigt werden soll (Unterknoten des zuletzt genannten Knotens werden nicht angezeigt). Jeder Knoten wird durch einen Punkt (.) vom nächsten Knoten getrennt. Jeder Knoten wird durch ObjectRowID Semikolon und Name des TreeNodes angegeben. SelectTreeNode(IDevFrameworkObject[]) Diese Action dient zum Selektieren eines Knotens im TreeView. Sie ist an die ExpandTreeView() Action angelehnt und hat somit auch mehrere Aufrufmöglichkeiten. Entweder mit einem String, welcher einen Pfad zu einem Knoten über die RowID und Knotennamen beschreibt, oder durch eine Liste mit IDevFrameworkObjects."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.TemplateControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.TemplateControlAction.html",
    "title": "Class TemplateControlAction",
    "keywords": "Class TemplateControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Template Control angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction TemplateControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class TemplateControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also TemplateControlDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.Shortcut.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.Shortcut.html",
    "title": "Property Shortcut",
    "keywords": "Property Shortcut | Improve this Doc View Source Shortcut Definiert die Tastenkombination, mit der die TabPage ausgewählt werden kann. Der Shortcut wird in der Anwendung als Tooltip angezeigt, wenn sich die Maus über der TabPage befindet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [DevBrowsable(true)] public ExtendedShortcut? Shortcut { get; set; } Property Value Nullable < ExtendedShortcut >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.ActiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.ActiveImage.html",
    "title": "Property ActiveImage",
    "keywords": "Property ActiveImage | Improve this Doc View Source ActiveImage Für die TabPage kann ein Header-Image hinterlegt, bzw. das auf Tabbed Window Ebene hinterlegte überschrieben werden. Das Image wird angezeigt, wenn das Tabbed Window aktiviert wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ActiveImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.ID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.ID.html",
    "title": "Property ID",
    "keywords": "Property ID | Improve this Doc View Source ID ID des TextCollection-Eintrages. Declaration int ID { get; set; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Text.html",
    "title": "Property Text",
    "keywords": "Property Text | Improve this Doc View Source Text Text in der aktuellen Sprache bzw. Sprach-Hierarchie. Declaration string Text { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.Value.html",
    "title": "Property Value",
    "keywords": "Property Value | Improve this Doc View Source Value Der mehrsprachige Text des TextCollection-Eintrages. Declaration DevMLString Value { get; } Property Value DevMLString"
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.GetText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.GetText.html",
    "title": "Method GetText",
    "keywords": "Method GetText | Improve this Doc View Source GetText(String) Liefert den Text in der übergebenen Sprache. Es erfolgt keine Fallback auf eine andere Sprache. Declaration string GetText(string iso) Parameters iso String 2-Zeichen iso-Code Returns String Remarks Wird der Text in der Sprache bzw. der Sprach-Hierarchie der aktuellen Sitzung benötigt, sollte das Property Text verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IDevFrameworkObjectMLString.html",
    "title": "Interface IDevFrameworkObjectMLString",
    "keywords": "Interface IDevFrameworkObjectMLString Repräsentiert den Eintrag einer TextCollection. Inherited Members IDevFrameworkObject.ObjectRowID IDevFrameworkObject.State IDevFrameworkObject.StateBeforeUpdate Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IDevFrameworkObjectMLString : IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource Properties ID ID des TextCollection-Eintrages. Text Text in der aktuellen Sprache bzw. Sprach-Hierarchie. Value Der mehrsprachige Text des TextCollection-Eintrages. Methods GetText(String) Liefert den Text in der übergebenen Sprache. Es erfolgt keine Fallback auf eine andere Sprache."
  },
  "api/FrameworkSystems.FrameworkBase.FSVisibility.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FSVisibility.html",
    "title": "Enum FSVisibility",
    "keywords": "Enum FSVisibility Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FSVisibility Fields Name Description Collapsed Das Control wird komplett ausgeblendet und benötigt keinen Platz. Im Form-Designer ist das Control sichtbar und wird mit einem schwarzen Schleier dargestellt. Hidden Das Control wird nicht angezeigt, es reserviert aber trotzdem Platz. Im Form-Designer ist das Control sichtbar und wird mit einem weißen Schleier dargestellt. Visible Das Control ist sichtbar. ( Standardwert )"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop Classes ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Enums FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html",
    "title": "Enum FileFlavorData.FileType",
    "keywords": "Enum FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FileType Fields Name Description Directory Ordner / Verzeichnis. File Datei."
  },
  "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.guid.html": {
    "href": "api/FrameworkSystems.FrameworkDataProvider.BaseObjects.guid.html",
    "title": "Class guid",
    "keywords": "Class guid GUID als ID für ein BaseObject. Entspricht der .NET-Guid-Klasse, mit dem Unterschied, daß die GUID nicht auf 16 Byte beschränkt ist. Inheritance Object guid Namespace : FrameworkSystems.FrameworkDataProvider.BaseObjects Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax [Serializable] [TypeConverter(typeof(guidConverter))] public sealed class guid : IComparable, Iguid, IIndexEntryID"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.MainMenuControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.MainMenuControlAction.html",
    "title": "Class MainMenuControlAction",
    "keywords": "Class MainMenuControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control Menu-Item angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction MainMenuControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class MainMenuControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable See Also MainMenuDesignViewModel ContextMenuDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewVerticalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewVerticalContentAlignment.html",
    "title": "Enum ListViewVerticalContentAlignment",
    "keywords": "Enum ListViewVerticalContentAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewVerticalContentAlignment Fields Name Description Bottom Fill Middle Top"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.RadioButtonControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.RadioButtonControlAction.html",
    "title": "Class RadioButtonControlAction",
    "keywords": "Class RadioButtonControlAction Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction RadioButtonControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class RadioButtonControlAction : EditableControlAction, IFrameworkControlActionBase, ISerializable"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html",
    "title": "Property Now",
    "keywords": "Property Now | Improve this Doc View Source Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time. Declaration public static FSDateTime Now { get; } Property Value FSDateTime"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html",
    "title": "Struct FSDateTime",
    "keywords": "Struct FSDateTime TODO! Summary description for FSDateTime. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSDateTime : IFSDateTime, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen Properties Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.GetString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.GetString.html",
    "title": "Method GetString",
    "keywords": "Method GetString | Improve this Doc View Source GetString(String) Gibt den Text in der gewünschten Sprache zurück. Declaration public override string GetString(string iso) Parameters iso String Returns String Overrides FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.GetString(System.String) Remarks Note Ein Aufruf mit this.Global.SelectedLanguage ist zu vermeiden. Stattdessen sollte dafür GetString(IGlobalObjects) verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.Item.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.Item.html",
    "title": "Property Item",
    "keywords": "Property Item | Improve this Doc View Source Item[String] Gibt den Text in der gewünschten Sprache zurück. Declaration public override string this[string iso] { get; } Parameters iso String Property Value String Overrides FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.Item[System.String] Remarks Note Ein Aufruf mit this.Global.SelectedLanguage ist zu vermeiden. Stattdessen sollte dafür Item[IGlobalObjects] verwendet werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeHandleRequest.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeHandleRequest.html",
    "title": "Method GlobalOnBeforeHandleRequest",
    "keywords": "Method GlobalOnBeforeHandleRequest | Improve this Doc View Source GlobalOnBeforeHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die übertragenen Daten eingelesen wurden, bevor die eigentliche Brokerlogik (Eventauswertung) ausgeführt wird. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration void GlobalOnBeforeHandleRequest() Remarks Warning Wird die Methode überschrieben, dann muss dafür gesorgt werden, dass der base-Aufruf in jedem Fall erfolgt!"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnAfterHandleRequest.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnAfterHandleRequest.html",
    "title": "Method GlobalOnAfterHandleRequest",
    "keywords": "Method GlobalOnAfterHandleRequest | Improve this Doc View Source GlobalOnAfterHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die eigentliche Brokerlogik (Eventauswertung) durchgeführt wurde, bevor die Daten an den Client übermittelt werden. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration void GlobalOnAfterHandleRequest() Remarks Warning Wird die Methode überschrieben, dann muss dafür gesorgt werden, dass der base-Aufruf in jedem Fall erfolgt!"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandleException.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandleException.html",
    "title": "Method GlobalOnHandleException",
    "keywords": "Method GlobalOnHandleException | Improve this Doc View Source GlobalOnHandleException(Exception) Diese Methode wird vom Broker für alle Exceptions aufgerufen die er selber abfängt (ohne MsgBox-Exceptions!) Declaration void GlobalOnHandleException(Exception ex) Parameters ex Exception Remarks Evtl. auftauchende Fehler werden verschluckt!"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandlingException.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnHandlingException.html",
    "title": "Method GlobalOnHandlingException",
    "keywords": "Method GlobalOnHandlingException | Improve this Doc View Source GlobalOnHandlingException(ref Exception) Declaration void GlobalOnHandlingException(ref Exception ex) Parameters ex Exception"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnIsDatabaseUpdateRequired.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnIsDatabaseUpdateRequired.html",
    "title": "Method GlobalOnIsDatabaseUpdateRequired",
    "keywords": "Method GlobalOnIsDatabaseUpdateRequired | Improve this Doc View Source GlobalOnIsDatabaseUpdateRequired() Declaration int GlobalOnIsDatabaseUpdateRequired() Returns Int32"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnRegisterAuthServiceUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnRegisterAuthServiceUnits.html",
    "title": "Method GlobalOnRegisterAuthServiceUnits",
    "keywords": "Method GlobalOnRegisterAuthServiceUnits | Improve this Doc View Source GlobalOnRegisterAuthServiceUnits() Diese Methode wird vom AUHelper aufgerufen, wenn mit Authentifizierung gearbeitet wird und (statisch einmalig) noch keine Registrierung der Units (Mandanten) am Auth Service erfolgt ist. Wird ein Enumerable zurückgegeben, so werden die angegebenen Units registriert. Wird \"null\" zurückgegeben, so wird keine Registrierung durchgeführt. Die Units werden durch KeyValuesPairs mit Key = ID (Primärschlüssel), Value = Name/Bezeichnung definiert. Declaration IEnumerable<KeyValuePair<string, string>> GlobalOnRegisterAuthServiceUnits() Returns IEnumerable < KeyValuePair < String , String >>"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalIsApplicationQuitAllowed.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalIsApplicationQuitAllowed.html",
    "title": "Method GlobalIsApplicationQuitAllowed",
    "keywords": "Method GlobalIsApplicationQuitAllowed | Improve this Doc View Source GlobalIsApplicationQuitAllowed() Diese Methode wird vom Broker bei einem vom Client gesendeten QuitApplication-Request aufgerufen. Declaration bool GlobalIsApplicationQuitAllowed() Returns Boolean Eine Rückgabe von false verhindert das Beenden der Applikation."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnGetDynamicDragSource.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnGetDynamicDragSource.html",
    "title": "Method GlobalOnGetDynamicDragSource",
    "keywords": "Method GlobalOnGetDynamicDragSource | Improve this Doc View Source GlobalOnGetDynamicDragSource(MLContainer, String, Func<IDevFrameworkBaseObject>) Diese Methode wird aufgerufen, wenn für die Controls eines Forms ermittelt wird, ob eine Drag-Operation möglich ist und noch kein anderer DragSource oder ein OnDrag-Event am Control definiert wurde. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration Func<IDevFrameworkBaseObject, object> GlobalOnGetDynamicDragSource(MLContainer mdt, string propertyName, Func<IDevFrameworkBaseObject> objectGetter) Parameters mdt MLContainer Der Metadatentyp des Properties propertyName String Der Name des Properties objectGetter Func < FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject > Übergibt ein Delegate, welches das aktuelle im Datasource gesetzte Objekt zurückgibt. Returns Func < FrameworkSystems.FrameworkBase.IDevFrameworkBaseObject , Object > Ein Delegate, welches das Objekt entgegennimmt aus welchem der DragSource ermittelt und zurückgegeben werden kann Remarks Innerhalb einer Sitzung erfolgt pro Metadatentyp nur ein Aufruf. Das zurückgegebene Delegate wird gecached. Am this.Global gibt es Methoden, um diesen Cache zu bearbeiten: ClearDynamicDragSources() SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, Object>) RemoveDynamicDragSource(MLContainer)"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalGetMLText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalGetMLText.html",
    "title": "Method GlobalGetMLText",
    "keywords": "Method GlobalGetMLText | Improve this Doc View Source GlobalGetMLText(MLKey, String) Jedes mal, wenn aus einem MLKey einen Text erzeugt wird, wird diese Methode aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration string GlobalGetMLText(MLKey mlkey, string iso) Parameters mlkey MLKey iso String Returns String Remarks Die Sprach-Hierarchie der Session, welche am GlobalObject hinterlegt ist, wird außerhalb dieser Methode aufgelöst. Besteht die Hierarchie aus mehreren Fallbacks(z.B. fr, en, de ), wird diese Methode auch ggf.mehrfach nacheinander mit den unterschiedlichen Iso-Codes aufgerufen. Liefert die Methode einen Wert ungleich null oder String.Empty zurück, wird dieser als Text verwendet und es erfolgt kein weiterer Aufruf. Durch die Überschreibung dieser Methode ist es möglich die Ermittlung der Texte zu beeinflussen oder zu überwachen. Warning Diese Methode muss sehr performant gestaltet werden. Komplexe Logik kann die Performance der kompletten Anwendung sehr negativ beeinflussen. Der Basis-Aufruf muss sichergestellt werden. Ansonsten wird das komplette Wörterbuch ausgehebelt und es werden gar keine Texte mehr ermittelt."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GetClientCulture.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GetClientCulture.html",
    "title": "Method GetClientCulture",
    "keywords": "Method GetClientCulture | Improve this Doc View Source GetClientCulture() Liefert die Culture des Clients zurück. Diese Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration CultureInfo GetClientCulture() Returns CultureInfo Remarks Die FS-seitige Implementierung der Methode ermittelt die Culture anhand der ClientInfos am Global Object. Dabei greifen die folgenden Prioritäten Aus der Angabe \"Locale\" Aus den Angaben \"UserLanguage\" und \"UserCountry\" Die CurrentCulture , die in der Regel der Culture des Broker-Servers entspricht. Wird die Methode überschrieben, muss die ermittelte Culture ggf. in einem eigenen Property zwischengespeichert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.html",
    "title": "Interface IcGlobalBase",
    "keywords": "Interface IcGlobalBase Bereits im SystemPackage existiert im Namespace FSGeneral eine Component mit dem Namen cGlobal. Diese Component kann customized werden. Aus Forms oder Components heraus kann eine Instanz dieser Component mit this.Global. ocGlobal angesprochen werden. Namespace : FrameworkSystems.FrameworkBase.GlobalObj Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IcGlobalBase Methods GetClientCulture() Liefert die Culture des Clients zurück. Diese Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalGetMLText(MLKey, String) Jedes mal, wenn aus einem MLKey einen Text erzeugt wird, wird diese Methode aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalIsApplicationQuitAllowed() Diese Methode wird vom Broker bei einem vom Client gesendeten QuitApplication-Request aufgerufen. GlobalOnAfterHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die eigentliche Brokerlogik (Eventauswertung) durchgeführt wurde, bevor die Daten an den Client übermittelt werden. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnBeforeHandleRequest() Diese Methode wird bei jedem Broker Request durchlaufen, nachdem die übertragenen Daten eingelesen wurden, bevor die eigentliche Brokerlogik (Eventauswertung) ausgeführt wird. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnBeforeLoad(DevFrameworkObject, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf ein Einzelobjekt aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. GlobalOnBeforeLoad(DevFrameworkObjectColl, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf eine Collection aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. GlobalOnBeforeSaveAction(DevFrameworkObject) Diese Methode wird vor jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnGetDynamicDragSource(MLContainer, String, Func<IDevFrameworkBaseObject>) Diese Methode wird aufgerufen, wenn für die Controls eines Forms ermittelt wird, ob eine Drag-Operation möglich ist und noch kein anderer DragSource oder ein OnDrag-Event am Control definiert wurde. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. GlobalOnHandleException(Exception) Diese Methode wird vom Broker für alle Exceptions aufgerufen die er selber abfängt (ohne MsgBox-Exceptions!) GlobalOnHandlingException(ref Exception) GlobalOnIsDatabaseUpdateRequired() GlobalOnRegisterAuthServiceUnits() Diese Methode wird vom AUHelper aufgerufen, wenn mit Authentifizierung gearbeitet wird und (statisch einmalig) noch keine Registrierung der Units (Mandanten) am Auth Service erfolgt ist. Wird ein Enumerable zurückgegeben, so werden die angegebenen Units registriert. Wird \"null\" zurückgegeben, so wird keine Registrierung durchgeführt. Die Units werden durch KeyValuesPairs mit Key = ID (Primärschlüssel), Value = Name/Bezeichnung definiert."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count | Improve this Doc View Source Count Gibt die Anzahl der enthaltenen URIs zurück. Declaration public int Count { get; } Property Value Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text | Improve this Doc View Source Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Declaration public override string Text { get; protected set; } Property Value String Overrides TextFlavorData.Text"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator | Improve this Doc View Source GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück. Declaration public IEnumerator<string> GetEnumerator() Returns IEnumerator < String > Examples UriListFlavorData oUriListFlavorData = oExternalTransferObject.GetUriListFlavordata(); foreach (string sUri in oUriListFlavorData) { // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html",
    "title": "Class UriListFlavorData",
    "keywords": "Class UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Inheritance Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class UriListFlavorData : TextFlavorData, IEnumerable<string>, IEnumerable Remarks Die Klasse ist enumerierbar ( IEnumerator<String> ). Diese Klasse ist eine Spezialisierung von TextFlavorData , da der URI-Listen-Flavor ein spezieller Text-Flavor ist. Properties Count Gibt die Anzahl der enthaltenen URIs zurück. Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück."
  },
  "api/FrameworkSystems.FrameworkBase.DockPanelScrolling.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DockPanelScrolling.html",
    "title": "Enum DockPanelScrolling",
    "keywords": "Enum DockPanelScrolling Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense] public enum DockPanelScrolling Fields Name Description None Normal VerticalOverlay"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html",
    "title": "Method EndSafeInitialize",
    "keywords": "Method EndSafeInitialize | Improve this Doc View Source EndSafeInitialize() Deaktiviert den SafeInitializing Modus. Declaration void EndSafeInitialize()"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html",
    "title": "Interface IGlobalObjects",
    "keywords": "Interface IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten. Namespace : FrameworkSystems.FrameworkBase.GlobalObj Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IGlobalObjects : IFrameworkDBPerformanceCounter Properties AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. ClientInfos In diesem Dictionary sind Informationen abgelegt, die der Client beim Start der Anwendung an den Broker übertragen hat. LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. MLColumnLanguage Gibt den Iso-Code der Sprache zurück, die aktuell für die MLColumn-Properties verwendet wird. Normalerweise handelt es sich dabei um die SelectedLanguage . Mit der Methode UseMLColumnLanguage(String, Action) kann die Sprache vorrübergebend geändert werden. ocGlobal SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Methods ClearDynamicDragSources() CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. EndSafeInitialize() Deaktiviert den SafeInitializing Modus. FormatMLKeyText(MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. FormatMLKeyText(IFormatProvider, MLKey, Object[]) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. FormatMLText(MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Argumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die Client-Culture verwendet. FormatMLText(IFormatProvider, MLKey, Object[]) Übersetz einen MLKey in einen Text. Dabei wird ein String. Format(String, Object[]) mit den übergebenen Arumenten ausgeführt. Für die Fomatierung der übergebenen Argumente wird die übergebene Culture verwendet. GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. GetMLKeyText(MLKey) Diese Methode gibt ein MLKeyText -Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. GetMLText(MLKey) Ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. GetMLText(MLKey, String) Diese Methode ermittelt für den übergebenen MLKey den Text für die übergebene Sprache. Es erfolgt kein Fallback auf eine andere Sprache. RemoveDynamicDragSource(MLContainer) SetDynamicDragSource(MLContainer, Func<IDevFrameworkBaseObject, Object>) UseMLColumnLanguage(String, Action) Verwendet für MLColumn-Properties während der übergenenen Action die angegebene Sprache."
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.SetHighlighted.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.SetHighlighted.html",
    "title": "Method SetHighlighted",
    "keywords": "Method SetHighlighted | Improve this Doc View Source SetHighlighted(Boolean) TODO! Sends an action to the client, which sets the caption of the control. Declaration public virtual void SetHighlighted(bool highlighted) Parameters highlighted Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.ImageButtonControlAction.html",
    "title": "Class ImageButtonControlAction",
    "keywords": "Class ImageButtonControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control ImageButton angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction EditableControlAction ButtonControlAction ImageButtonControlAction Implements IFrameworkControlActionBase Inherited Members EditableControlAction.SetEnabled(Nullable<Boolean>) EditableControlAction.SetFocus() FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class ImageButtonControlAction : ButtonControlAction, IFrameworkControlActionBase, ISerializable Methods SetHighlighted(Boolean) TODO! Sends an action to the client, which sets the caption of the control. See Also ImageButtonDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnToolTip.html",
    "title": "Method SetColumnToolTip",
    "keywords": "Method SetColumnToolTip | Improve this Doc View Source SetColumnToolTip(Int32, String) !TODO Declaration public virtual void SetColumnToolTip(int columnPos, string toolTipExtension) Parameters columnPos Int32 toolTipExtension String | Improve this Doc View Source SetColumnToolTip(String, String) !TODO Declaration public virtual void SetColumnToolTip(string columnName, string toolTipExtension) Parameters columnName String toolTipExtension String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ScrollTo.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.ScrollTo.html",
    "title": "Method ScrollTo",
    "keywords": "Method ScrollTo | Improve this Doc View Source ScrollTo(Int32) !TODO Declaration public virtual void ScrollTo(int row) Parameters row Int32 | Improve this Doc View Source ScrollTo(guid) !TODO Declaration public virtual void ScrollTo(guid objectRowID) Parameters objectRowID guid"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCell.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCell.html",
    "title": "Method SetCell",
    "keywords": "Method SetCell | Improve this Doc View Source SetCell(guid, Int32) Diese Aktion setzt den Fokus in eine Zelle des Grids. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Declaration public virtual void SetCell(guid rowID, int columnPos) Parameters rowID guid columnPos Int32 | Improve this Doc View Source SetCell(guid, String) Wie SetCell(guid, Int32) . Zusätzlich gibt es hier den Parameter SelectAll , mit dem angegeben werden kann, ob der gesamte Inhalt der Zelle markiert werden soll. Mit true wird der Inhalt markiert und kann direkt überschrieben werden. Declaration public virtual void SetCell(guid rowID, string columnName) Parameters rowID guid columnName String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellEditable.html",
    "title": "Method SetCellEditable",
    "keywords": "Method SetCellEditable | Improve this Doc View Source SetCellEditable(guid, Int32, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. ColumnPos ist die Nummer der Spalte mit 0 beginnend. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. Declaration public virtual void SetCellEditable(guid rowID, int columnPos, bool isEditable) Parameters rowID guid columnPos Int32 isEditable Boolean | Improve this Doc View Source SetCellEditable(guid, String, Boolean) Diese Aktion setzt eine Zelle des Grids auf editierbar oder nicht editierbar. Die RowID ist das Property ObjectRowID eines Objekts der Collection. columnName ist der Name der Spalte. Ist IsEditable auf true gesetzt, wird die Zelle für Benutzereingaben zugänglich gemacht, bei false wird die Zelle gesperrt. Declaration public virtual void SetCellEditable(guid rowID, string columnName, bool isEditable) Parameters rowID guid columnName String isEditable Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellForeColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellForeColor.html",
    "title": "Method SetCellForeColor",
    "keywords": "Method SetCellForeColor | Improve this Doc View Source SetCellForeColor(guid, Int32, Color) !TODO Declaration public virtual void SetCellForeColor(guid rowID, int columnPos, Color color) Parameters rowID guid columnPos Int32 color Color | Improve this Doc View Source SetCellForeColor(guid, String, Color) !TODO Declaration public virtual void SetCellForeColor(guid rowID, string columnName, Color color) Parameters rowID guid columnName String color Color"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellBackColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetCellBackColor.html",
    "title": "Method SetCellBackColor",
    "keywords": "Method SetCellBackColor | Improve this Doc View Source SetCellBackColor(guid, Int32, Color) !TODO Declaration public virtual void SetCellBackColor(guid rowID, int columnPos, Color color) Parameters rowID guid columnPos Int32 color Color | Improve this Doc View Source SetCellBackColor(guid, String, Color) !TODO Declaration public virtual void SetCellBackColor(guid rowID, string columnName, Color color) Parameters rowID guid columnName String color Color"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnVisible.html",
    "title": "Method SetColumnVisible",
    "keywords": "Method SetColumnVisible | Improve this Doc View Source SetColumnVisible(Int32, Boolean) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. Declaration public virtual void SetColumnVisible(int columnPos, bool value) Parameters columnPos Int32 value Boolean | Improve this Doc View Source SetColumnVisible(Int32, Nullable<Boolean>) Legt fest, ob die Spalte mit der Nummer ColumnPos dargestellt werden soll. Declaration public virtual void SetColumnVisible(int columnPos, bool? value) Parameters columnPos Int32 value Nullable < Boolean > | Improve this Doc View Source SetColumnVisible(String, Boolean) Legt fest, ob die Spalte ColumnName dargestellt werden soll. Declaration public virtual void SetColumnVisible(string columnName, bool value) Parameters columnName String value Boolean | Improve this Doc View Source SetColumnVisible(String, Nullable<Boolean>) Legt fest, ob die Spalte ColumnName dargestellt werden soll. Declaration public virtual void SetColumnVisible(string columnName, bool? value) Parameters columnName String value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetColumnCaption.html",
    "title": "Method SetColumnCaption",
    "keywords": "Method SetColumnCaption | Improve this Doc View Source SetColumnCaption(Int32, String) Setzt die Spaltenüberschrift der Spalte Nummer ColumnPos auf den Wert value . Declaration public virtual void SetColumnCaption(int columnPos, string value) Parameters columnPos Int32 value String | Improve this Doc View Source SetColumnCaption(String, String) Setzt die Spaltenüberschrift der Spalte ColumnName auf den neuen Wert value . Declaration public virtual void SetColumnCaption(string columnName, string value) Parameters columnName String value String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridColor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridColor.html",
    "title": "Method SetGridColor",
    "keywords": "Method SetGridColor | Improve this Doc View Source SetGridColor(Color) !TODO Declaration public virtual void SetGridColor(Color color) Parameters color Color"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SaveGridLayout.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SaveGridLayout.html",
    "title": "Method SaveGridLayout",
    "keywords": "Method SaveGridLayout | Improve this Doc View Source SaveGridLayout(String, Boolean) !TODO Declaration public virtual void SaveGridLayout(string fileName, bool displayErrorMsg) Parameters fileName String displayErrorMsg Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.LoadGridLayout.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.LoadGridLayout.html",
    "title": "Method LoadGridLayout",
    "keywords": "Method LoadGridLayout | Improve this Doc View Source LoadGridLayout(String, Boolean) !TODO Declaration public virtual void LoadGridLayout(string fileName, bool displayErrorMsg) Parameters fileName String displayErrorMsg Boolean"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridRowHeight.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.GridControlAction.SetGridRowHeight.html",
    "title": "Method SetGridRowHeight",
    "keywords": "Method SetGridRowHeight | Improve this Doc View Source SetGridRowHeight(Int32) Legt die Zeilenhöhe der einzelnen Zeilen im Grid fest. Declaration public void SetGridRowHeight(int height) Parameters height Int32"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html",
    "title": "Class MLContainer",
    "keywords": "Class MLContainer TODO! Inheritance Object MLContainer Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class MLContainer"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.InvertFlowDirection.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.InvertFlowDirection.html",
    "title": "Property InvertFlowDirection",
    "keywords": "Property InvertFlowDirection | Improve this Doc View Source InvertFlowDirection Die Controls werden in umgekehrter Reihenfolge im WrapPanel platziert. Die Tab-Order wird dabei auch verdreht, sodass in der Anwendung die Tab-Order wieder von „vorne“ nach „hinten“ läuft. Diese Einstellung kann nützlich sein, wenn neu hinzugefügte Controls standardmäßig am Anfang platziert werden sollen – z.B. bei rechts ausgerichteten Button-Leisten. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? InvertFlowDirection { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.HorizontalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.HorizontalContentAlignment.html",
    "title": "Property HorizontalContentAlignment",
    "keywords": "Property HorizontalContentAlignment | Improve this Doc View Source HorizontalContentAlignment Die Controls werden zeilenweise angeordnet und brechen um, wenn der Platz in der Breite nicht ausreicht. Declaration [Browsable(false)] [ControlStylesBrowsable(true)] public WrapPanelHorizontalContentAlignment? HorizontalContentAlignment { get; set; } Property Value Nullable < WrapPanelHorizontalContentAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.VerticalContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.VerticalContentAlignment.html",
    "title": "Property VerticalContentAlignment",
    "keywords": "Property VerticalContentAlignment | Improve this Doc View Source VerticalContentAlignment Die Controls werden spaltenweise angeordnet, wobei das WrapPanel die Anonrdnung mit der geringsten Höhe sucht. Bei einer gegebenen Breite werden so viele Spalten wie möglich angezeigt. Declaration [Browsable(false)] [ControlStylesBrowsable(true)] public WrapPanelVerticalContentAlignment? VerticalContentAlignment { get; set; } Property Value Nullable < WrapPanelVerticalContentAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.ContentAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.ContentAlignment.html",
    "title": "Property ContentAlignment",
    "keywords": "Property ContentAlignment | Improve this Doc View Source ContentAlignment Definiert, wie der Inhalt ausgerichtet werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(AlignmentObjectConverter<WrapPanelHorizontalContentAlignment, WrapPanelVerticalContentAlignment>))] public Alignment<WrapPanelHorizontalContentAlignment, WrapPanelVerticalContentAlignment> ContentAlignment { get; set; } Property Value Alignment < WrapPanelHorizontalContentAlignment , WrapPanelVerticalContentAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.WrapPanelDesignViewModel.html",
    "title": "Class WrapPanelDesignViewModel",
    "keywords": "Class WrapPanelDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LayoutContainerDesignViewModel FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.SpaceableContainerDesignViewModel WrapPanelDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class WrapPanelDesignViewModel : SpaceableContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ContentAlignment Definiert, wie der Inhalt ausgerichtet werden soll. HorizontalContentAlignment Die Controls werden zeilenweise angeordnet und brechen um, wenn der Platz in der Breite nicht ausreicht. InvertFlowDirection Die Controls werden in umgekehrter Reihenfolge im WrapPanel platziert. Die Tab-Order wird dabei auch verdreht, sodass in der Anwendung die Tab-Order wieder von „vorne“ nach „hinten“ läuft. Diese Einstellung kann nützlich sein, wenn neu hinzugefügte Controls standardmäßig am Anfang platziert werden sollen – z.B. bei rechts ausgerichteten Button-Leisten. VerticalContentAlignment Die Controls werden spaltenweise angeordnet, wobei das WrapPanel die Anonrdnung mit der geringsten Höhe sucht. Bei einer gegebenen Breite werden so viele Spalten wie möglich angezeigt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.BackColor2.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.BackColor2.html",
    "title": "Property BackColor2",
    "keywords": "Property BackColor2 | Improve this Doc View Source BackColor2 Gibt die alternierende Hintergrundfarbe für die TreeView an. Für den Hintergrund der Tree-Nodes wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Nodes die BackColor verwendet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color BackColor2 { get; set; } Property Value Color"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsBorderVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsBorderVisible.html",
    "title": "Property IsBorderVisible",
    "keywords": "Property IsBorderVisible | Improve this Doc View Source IsBorderVisible Gibt an, ob der Rahmen angezeigt werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? IsBorderVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsFirstLevelExpandIconVisible.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.IsFirstLevelExpandIconVisible.html",
    "title": "Property IsFirstLevelExpandIconVisible",
    "keywords": "Property IsFirstLevelExpandIconVisible | Improve this Doc View Source IsFirstLevelExpandIconVisible Mit diesem Property kann gesteuert werden, ob in der ersten Ebene des TreeViews das ExpandIcon („+“ Symbol zum Aufklappen) angezeigt werden soll oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? IsFirstLevelExpandIconVisible { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.ShowLines.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.ShowLines.html",
    "title": "Property ShowLines",
    "keywords": "Property ShowLines | Improve this Doc View Source ShowLines Gibt an, ob die Linien der Baum-Struktur vor den Tree-Nodes angezeigt werden sollen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowLines { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.DragDropMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.DragDropMode.html",
    "title": "Property DragDropMode",
    "keywords": "Property DragDropMode | Improve this Doc View Source DragDropMode Gibt an, von welchen Controls aus in den aktuellen Tree-View Drag and Drop ausgeführt werden Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TreeViewDragDropMode? DragDropMode { get; set; } Property Value Nullable < TreeViewDragDropMode >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.InitialDepth.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.InitialDepth.html",
    "title": "Property InitialDepth",
    "keywords": "Property InitialDepth | Improve this Doc View Source InitialDepth Gibt an, bis zu welcher Ebene Daten vom TreeView an den Anzeige-Client übertragen werden. Hat ein Tree z.B. 5 Ebenen und InitialDepth ist mit 2 definiert, werden erst beim Aufklappen der 3. Ebene im Client die neuen Daten übertragen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public byte? InitialDepth { get; set; } Property Value Nullable < Byte >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeViewDesignViewModel.html",
    "title": "Class TreeViewDesignViewModel",
    "keywords": "Class TreeViewDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TreeViewDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TreeViewDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties BackColor2 Gibt die alternierende Hintergrundfarbe für die TreeView an. Für den Hintergrund der Tree-Nodes wird abwechselnd BackColor und BackColor2 verwendet. Wenn keine Farbe angegeben ist, dann wird für alle Nodes die BackColor verwendet. DragDropMode Gibt an, von welchen Controls aus in den aktuellen Tree-View Drag and Drop ausgeführt werden InitialDepth Gibt an, bis zu welcher Ebene Daten vom TreeView an den Anzeige-Client übertragen werden. Hat ein Tree z.B. 5 Ebenen und InitialDepth ist mit 2 definiert, werden erst beim Aufklappen der 3. Ebene im Client die neuen Daten übertragen. IsBorderVisible Gibt an, ob der Rahmen angezeigt werden soll. IsFirstLevelExpandIconVisible Mit diesem Property kann gesteuert werden, ob in der ersten Ebene des TreeViews das ExpandIcon („+“ Symbol zum Aufklappen) angezeigt werden soll oder nicht. ShowLines Gibt an, ob die Linien der Baum-Struktur vor den Tree-Nodes angezeigt werden sollen."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FormContainerDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FormContainerDesignViewModel.html",
    "title": "Class FormContainerDesignViewModel",
    "keywords": "Class FormContainerDesignViewModel Diese Klasse repräsentiert das Control FormContainer . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel FormContainerDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class FormContainerDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord See Also FormContainerControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.LabelMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.LabelMode.html",
    "title": "Property LabelMode",
    "keywords": "Property LabelMode | Improve this Doc View Source LabelMode Über die Eigenschaft LabelMode können Sie einstellen, wie für die Controls die Labels generiert werden sollen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public FieldRowLabelMode? LabelMode { get; set; } Property Value Nullable < FieldRowLabelMode >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.OptimizeGeneratedLabels.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.FieldRowDesignViewModel.OptimizeGeneratedLabels.html",
    "title": "Property OptimizeGeneratedLabels",
    "keywords": "Property OptimizeGeneratedLabels | Improve this Doc View Source OptimizeGeneratedLabels Über diese Eigenschaft können von mehreren Labels redundante Worte zusammengefasst werden. Diese Einstelllung funktioniert sowohl im LabelMode Generated als auch GeneratedMerged . Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? OptimizeGeneratedLabels { get; set; } Property Value Nullable < Boolean > Examples • Artikelnr von; Artikelnr bis -> Artikelnr von / bis • von Datum; bis Datum -> von / bis Datum"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontUnderline.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetFontUnderline.html",
    "title": "Method SetFontUnderline",
    "keywords": "Method SetFontUnderline | Improve this Doc View Source SetFontUnderline(FSbool) !TODO Declaration public virtual void SetFontUnderline(FSbool underline) Parameters underline FSbool | Improve this Doc View Source SetFontUnderline(Nullable<Boolean>) !TODO Declaration public virtual void SetFontUnderline(bool? underline) Parameters underline Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.SetCaption.html",
    "title": "Method SetCaption",
    "keywords": "Method SetCaption | Improve this Doc View Source SetCaption(String) !TODO Declaration public virtual void SetCaption(string caption) Parameters caption String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.GetDefaultLabel.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.GetDefaultLabel.html",
    "title": "Method GetDefaultLabel",
    "keywords": "Method GetDefaultLabel | Improve this Doc View Source GetDefaultLabel() !TODO Declaration public virtual string GetDefaultLabel() Returns String"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FrameworkControlAction.html",
    "title": "Class FrameworkControlAction",
    "keywords": "Class FrameworkControlAction Summary description for FrameworkControlAction. Inheritance Object FrameworkControlActionBase FrameworkControlAction BrowserControlAction DashboardContainerControlAction EditableControlAction FormContainerControlAction LabelControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class FrameworkControlAction : FrameworkControlActionBase, IFrameworkControlActionBase, ISerializable Methods GetDefaultLabel() !TODO SetBackColor(Nullable<Color>) !TODO SetBorderColor(Nullable<Color>) !TODO SetCaption(String) !TODO SetFontBold(FSbool) !TODO SetFontBold(Nullable<Boolean>) !TODO SetFontFamily(String) !TODO SetFontItalic(FSbool) !TODO SetFontItalic(Nullable<Boolean>) !TODO SetFontSize(FSint) !TODO SetFontSize(Nullable<Int32>) !TODO SetFontUnderline(FSbool) !TODO SetFontUnderline(Nullable<Boolean>) !TODO SetForeColor(Nullable<Color>) Ermöglicht das Setzen der Control-Farbe zur Laufzeit. SetMaxHeight(FSint) !TODO SetMaxHeight(Nullable<Int32>) !TODO SetMaxWidth(FSint) !TODO SetMaxWidth(Nullable<Int32>) !TODO SetMinHeight(FSint) !TODO SetMinHeight(Nullable<Int32>) !TODO SetMinWidth(FSint) !TODO SetMinWidth(Nullable<Int32>) !TODO SetToolTip(String) !TODO"
  },
  "api/FrameworkSystems.FrameworkControls.Actions.FormContainerControlAction.html": {
    "href": "api/FrameworkSystems.FrameworkControls.Actions.FormContainerControlAction.html",
    "title": "Class FormContainerControlAction",
    "keywords": "Class FormContainerControlAction Über diese Klasse werden zur Laufzeit die Actions für das Control FormCointainer angeboten. Inheritance Object FrameworkControlActionBase FrameworkControlAction FormContainerControlAction Implements IFrameworkControlActionBase Inherited Members FrameworkControlAction.SetForeColor(Nullable<Color>) FrameworkControlAction.SetBackColor(Nullable<Color>) FrameworkControlAction.SetBorderColor(Nullable<Color>) FrameworkControlAction.SetMinWidth(FSint) FrameworkControlAction.SetMinWidth(Nullable<Int32>) FrameworkControlAction.SetMinHeight(FSint) FrameworkControlAction.SetMinHeight(Nullable<Int32>) FrameworkControlAction.SetMaxWidth(FSint) FrameworkControlAction.SetMaxWidth(Nullable<Int32>) FrameworkControlAction.SetMaxHeight(FSint) FrameworkControlAction.SetMaxHeight(Nullable<Int32>) FrameworkControlAction.SetToolTip(String) FrameworkControlAction.SetFontFamily(String) FrameworkControlAction.SetFontSize(FSint) FrameworkControlAction.SetFontSize(Nullable<Int32>) FrameworkControlAction.SetFontBold(FSbool) FrameworkControlAction.SetFontBold(Nullable<Boolean>) FrameworkControlAction.SetFontItalic(FSbool) FrameworkControlAction.SetFontItalic(Nullable<Boolean>) FrameworkControlAction.SetFontUnderline(FSbool) FrameworkControlAction.SetFontUnderline(Nullable<Boolean>) FrameworkControlAction.SetCaption(String) FrameworkControlAction.GetDefaultLabel() FrameworkControlActionBase.SetVisible(Boolean) FrameworkControlActionBase.SetVisible(Nullable<FSVisibility>) FrameworkControlActionBase.HidePermanent() Namespace : FrameworkSystems.FrameworkControls.Actions Assembly : FrameworkSystems.FrameworkControls.dll Syntax [Serializable] public class FormContainerControlAction : FrameworkControlAction, IFrameworkControlActionBase, ISerializable See Also FormContainerDesignViewModel"
  },
  "api/FrameworkSystems.FrameworkBase.VerticalAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.VerticalAlignment.html",
    "title": "Enum VerticalAlignment",
    "keywords": "Enum VerticalAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum VerticalAlignment Fields Name Description Bottom Middle Stretch Top"
  },
  "api/FrameworkSystems.FrameworkBase.TreeViewDragDropMode.html": {
    "href": "api/FrameworkSystems.FrameworkBase.TreeViewDragDropMode.html",
    "title": "Enum TreeViewDragDropMode",
    "keywords": "Enum TreeViewDragDropMode Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense(true)] public enum TreeViewDragDropMode Fields Name Description AllTreeViews Drop ist von allen TreeViews aus möglich. None Drop in diesen TreeView ist nicht erlaubt. OtherTreeViews Drop ist nur mit Knoten von anderen TreeViews möglich. ThisTreeView Drop ist nur mit Knoten desselben TreeViews möglich."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign | Improve this Doc View Source TextAlign Ausrichtung des Textes innerhalb des Labels. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public DevTextAlign? TextAlign { get; set; } Property Value Nullable < DevTextAlign >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Hier geben Sie mehrsprachig den Text ein, den das Label anzeigen soll. Wenn der Text des Default-Labels wiederhergestellt werden soll, muss der Inhalt aus Caption nur gelöscht werden. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption Remarks Es ist die Eingabe von Plaintext und HTML-Text möglich. HTML-Text muss mit beginnen und mit enden. Soll ein Und-Zeichen (&) dargestellt werden, müssen zwei Und-Zeichen (&&) angegeben werden. Ist auf dem Label ein DataSource hinterlegt, wird der Text, der hier unter Caption eingetragen wurde, nicht mehr angezeigt. Der Datasource hat dann höhere Priorität."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Gibt das Property an, dessen Inhalt in dem Label angezeigt werden soll. Ist ein Datasource angegeben, wird der Text aus Caption nicht angezeigt. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.LabelDesignViewModel.html",
    "title": "Class LabelDesignViewModel",
    "keywords": "Class LabelDesignViewModel Diese Klasse repräsentiert das Control Label . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel LabelDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class LabelDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Hier geben Sie mehrsprachig den Text ein, den das Label anzeigen soll. Wenn der Text des Default-Labels wiederhergestellt werden soll, muss der Inhalt aus Caption nur gelöscht werden. DataSource Gibt das Property an, dessen Inhalt in dem Label angezeigt werden soll. Ist ein Datasource angegeben, wird der Text aus Caption nicht angezeigt. TextAlign Ausrichtung des Textes innerhalb des Labels. See Also LabelControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image | Improve this Doc View Source Image Gibt das Bild an, das im Normalzustand angezeigt werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.PressedImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.PressedImage.html",
    "title": "Property PressedImage",
    "keywords": "Property PressedImage | Improve this Doc View Source PressedImage Gibt das Bild an, das angezeigt werden soll, wenn der Image-Button gedrückt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string PressedImage { get; set; } Property Value String Remarks Warning In der Regel ist es sinnvoll, Image-Buttons im Default Control Style-Editor zu definieren und nur inSonderfällen von dieser Definition abzuweichen( Default Control Styles )."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MouseOverImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.MouseOverImage.html",
    "title": "Property MouseOverImage",
    "keywords": "Property MouseOverImage | Improve this Doc View Source MouseOverImage Gibt das Bild an, das angezeigt werden soll, wenn der Mauszeiger sich über dem Image-Button befindet. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string MouseOverImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.DisabledImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.DisabledImage.html",
    "title": "Property DisabledImage",
    "keywords": "Property DisabledImage | Improve this Doc View Source DisabledImage Gibt das Bild an, das angezeigt werden soll, wenn der Button disabled ist. Die URL kann einen relativen (zum Applikations-Verzeichnis) oder einen absoluten Pfad darstellen. Über die Drop- Down-Box kann geprüft werden, ob es sich um eine gültige URL handelt. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string DisabledImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.CaptionAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ImageButtonDesignViewModel.CaptionAlign.html",
    "title": "Property CaptionAlign",
    "keywords": "Property CaptionAlign | Improve this Doc View Source CaptionAlign Ausrichtung des Textes auf dem Image-Button. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ContentAlignment? CaptionAlign { get; set; } Property Value Nullable < ContentAlignment > Remarks"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Beschriftung des Radio-Buttons. Wird rechts neben dem Radio-Button angezeigt. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.SearchOperator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.SearchOperator.html",
    "title": "Property SearchOperator",
    "keywords": "Property SearchOperator | Improve this Doc View Source SearchOperator Gibt an, mit welchem Operator sich das Control in die Load-Condition eintragen soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) Declaration [Browsable(true)] public SearchCompareOperator? SearchOperator { get; set; } Property Value Nullable < SearchCompareOperator >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.FullTextSearch.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.FullTextSearch.html",
    "title": "Property FullTextSearch",
    "keywords": "Property FullTextSearch | Improve this Doc View Source FullTextSearch Declaration [Browsable(true)] public bool? FullTextSearch { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.LabelTemplate.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.LabelTemplate.html",
    "title": "Property LabelTemplate",
    "keywords": "Property LabelTemplate | Improve this Doc View Source LabelTemplate Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ControlLabelTemplate LabelTemplate { get; set; } Property Value ControlLabelTemplate"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderColor.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderColor.html",
    "title": "Property BorderColor",
    "keywords": "Property BorderColor | Improve this Doc View Source BorderColor Gibt die Farbe des Rands um das Control herum an. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] [TypeConverter(typeof(ColorTypeConverter))] public Color? BorderColor { get; set; } Property Value Nullable < Color >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderThickness.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderThickness.html",
    "title": "Property BorderThickness",
    "keywords": "Property BorderThickness | Improve this Doc View Source BorderThickness Gibt die Dicke des Rands um das Control herum an.Der Rand wird in die Größe des Controls hineingerechnet.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public virtual Bounds BorderThickness { get; set; } Property Value Bounds"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderRadius.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.BorderRadius.html",
    "title": "Property BorderRadius",
    "keywords": "Property BorderRadius | Improve this Doc View Source BorderRadius Gibt den Radius für die Rundung des Randes an. Die Unter-Eigenschaften TopLeft , TopRight , BottomRight und BottomLeft können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public BorderRadius BorderRadius { get; set; } Property Value BorderRadius"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnEnter.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnEnter.html",
    "title": "Event OnEnter",
    "keywords": "Event OnEnter Wird beim setzen des Fokus auf ein Control ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkEventArgs> OnEnter Returns Type Description EventHandler < FrameworkEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnLeave.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnLeave.html",
    "title": "Event OnLeave",
    "keywords": "Event OnLeave Wird beim Entfernen des Fokus von einem Control ausgelöst. Wenn sich der Wert des Controls geändert hat, wird vor diesem Event das Event OnValidated ausgelöst. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnLeaveEventArgs> OnLeave Returns Type Description EventHandler < FrameworkOnLeaveEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnCanDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnCanDrop.html",
    "title": "Event OnCanDrop",
    "keywords": "Event OnCanDrop !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnCanDropEventArgs> OnCanDrop Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnCanDropEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnDrag.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.OnDrag.html",
    "title": "Event OnDrag",
    "keywords": "Event OnDrag !TODO Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnDragEventArgs> OnDrag Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnDragEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.html",
    "title": "Class ControlDesignViewModel",
    "keywords": "Class ControlDesignViewModel TODO Inheritance Object ControlTreeNode ControlDesignViewModel BrowserDesignViewModel ButtonBaseDesignViewModel CheckBoxDesignViewModel ContainerDesignViewModel DashBoardContainerViewModel EditboxDesignViewModel FormContainerDesignViewModel GridColDesignViewModel LabelDesignViewModel ListBaseDesignViewModel ListViewDesignViewModel PictureDesignViewModel RadioButtonDesignViewModel TemplateControlDesignViewModel Inherited Members ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public abstract class ControlDesignViewModel : ControlTreeNode, INotifyPropertyChanged, IDisposable, INamedRecord Properties Alignment Gibt an, wie sich das Control in seinem Container ausrichten soll. Standardwerte sind Stretch und Stretch BackColor Gibt die Hintergrund-Farbe des Controls an. Über den Alpha-Kanal (Transparenz-Wert) der Farbe kann die Transparenz des Controls gesteuert werden. BorderColor Gibt die Farbe des Rands um das Control herum an. BorderRadius Gibt den Radius für die Rundung des Randes an. Die Unter-Eigenschaften TopLeft , TopRight , BottomRight und BottomLeft können getrennt voneinander angegeben oder überschrieben werden. BorderThickness Gibt die Dicke des Rands um das Control herum an.Der Rand wird in die Größe des Controls hineingerechnet.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. Caption Gibt eine mehrsprachige Beschriftung des Controls an. Je nach Control wird diese entweder selber vom Control angezeigt (z.B. Button, ImageButton, Label) oder es wird durch das [FieldPanel](!TODO LINK) ein Label mit dieser Beschriftung generiert (z.B. Editfield, Combobox). ControlEvents Dieses Property dient dazu, den Editor für die Events anzuzeigen. Es selber selber keinen relevanten Wert. (siehe Events ) CtrlStyleName DataSource Documentation Öffnet den Dokumentations-Editor (siehe Editor ) Font Hier kann die Schrift des Controls eingestellt werden. Die Unter-Properties Family , Size , Bold , Italic und Underline können jeweils getrennt voneinander überschrieben werden. Die Size definiert, wieviel Pixel Platz die Schrift insgesamt bei einer Skalierung von 100% verbraucht.Somit ergibt sich aus Summe der Size und den Properties Padding, BorderThickness und Margin die tatsächliche Höhe des Controls. ForeColor Schriftfarbe. Über das die Action SetForeColor(Nullable<Color>) kann die Farbe zur Laufzeit geändert werden. FullTextSearch HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. IsEditable Wenn hier true gesetzt ist, ist das Control editierbar. Ansonsten ist das Control für Eingaben gesperrt. Über die Action SetEnabled(Nullable<Boolean>) kann das Control zur Laufzeit gesperrt werden. IsEditableAU Das IsEditable Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) IsSearchField Soll sich das Control in die automatisch generierte Load-Condition eintragen, muss dieses Property auf True gesetzt werden. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) IsVisibleAU Das IsVisible Property wird je nach AccessUnits eingeschränkt. (siehe IsVisibleAU/IsEditableAU ) LabelTemplate Margin Gibt den äußeren Rand um das Control herum an. Der Margin wird nicht in die Größe des Controls hineingerechnet. Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. MaxSize Gibt die maximale Größe des Controls an. Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin. Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. MinSize Gibt die minimale Größe des Controls an.Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin.Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. Padding Gibt den inneren Rand des Controls – also den Abstand des Control-Inhalts zur Border an.Die Unter-Eigenschaften Left , Top , Right und Bottom können getrennt voneinander angegeben oder überschrieben werden. SearchOperator Gibt an, mit welchem Operator sich das Control in die Load-Condition eintragen soll. (Siehe Erzeugen eines Suchdialogs durch Property-Funktionalität .) TabStop Wenn dieses Property den Wert true besitzt, wird das Steuerelement bei der Fokustraversierung mittels Tastatur erfasst. Ist es auf false , so wird das Steuerelement bei der Tab-Reihenfolge überspringen. Der Standardwert für die Eigenschaft ist true . TooltipText Verweilt ein Benutzer eine kurze Zeit mit dem Mauszeiger auf dem Control, wird der Tooltip angezeigt. Der Tooltip kann mehrsprachig hinterlegt werden. Visibility Steuert die Sichtbarkeit des Controls. Über die Control-Action SetVisible(Nullable<FSVisibility>) kann die Eigenschaft zur Laufzeit geändert werden. Events OnCanDrop !TODO OnDrag !TODO OnEnter Wird beim setzen des Fokus auf ein Control ausgelöst. OnLeave Wird beim Entfernen des Fokus von einem Control ausgelöst. Wenn sich der Wert des Controls geändert hat, wird vor diesem Event das Event OnValidated ausgelöst."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Dient lediglich der Bezeichnung in der generierten Dokumentation. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides MainMenuDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Ohne Funktion. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides MainMenuDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ContextMenuDesignViewModel.html",
    "title": "Class ContextMenuDesignViewModel",
    "keywords": "Class ContextMenuDesignViewModel Diese Klasse repräsentiert das Control ContextMenu . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel MainMenuDesignViewModel ContextMenuDesignViewModel Inherited Members MainMenuDesignViewModel.Checked MainMenuDesignViewModel.Shortcut MainMenuDesignViewModel.Image MainMenuDesignViewModel.OnClick MainMenuDesignViewModel.OnEnter MainMenuDesignViewModel.OnLeave MainMenuDesignViewModel.OnCanDrop MainMenuDesignViewModel.OnDrag ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class ContextMenuDesignViewModel : MainMenuDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Dient lediglich der Bezeichnung in der generierten Dokumentation. DataSource Ohne Funktion. See Also MainMenuControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Left.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Left.html",
    "title": "Property Left",
    "keywords": "Property Left | Improve this Doc View Source Left Declaration public int? Left { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Right.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Controls.Bounds.Right.html",
    "title": "Property Right",
    "keywords": "Property Right | Improve this Doc View Source Right Declaration public int? Right { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.Template.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.Template.html",
    "title": "Property Template",
    "keywords": "Property Template | Improve this Doc View Source Template Öffnet den ListView Template Editor . Declaration [Browsable(true)] public object Template { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TemplateControlDesignViewModel.html",
    "title": "Class TemplateControlDesignViewModel",
    "keywords": "Class TemplateControlDesignViewModel Diese Klasse repräsentiert das Control TemplateControl . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel TemplateControlDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TemplateControlDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Template Öffnet den ListView Template Editor . See Also TemplateControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.NextControlAfterKeyboardEvent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.NextControlAfterKeyboardEvent.html",
    "title": "Property NextControlAfterKeyboardEvent",
    "keywords": "Property NextControlAfterKeyboardEvent | Improve this Doc View Source NextControlAfterKeyboardEvent Diese Eigenschaft kann vom Programmierer geändert werden.Hier kann das Control angegeben werden, in das der Focus als nächstes gesetzt werden soll.Dadurch wird die Angabe in DefaultNextControl übersteuert. Diese Angabe funktioniert aber nur, wenn das OnLeave durch eine Tastatur-Eingabe ausgelöst wurde.Wenn der Benutzer mit der Maus gezielt in ein anderes Control klickt, dann hat das für den Client Priorität. Declaration public IFrameworkControlActionBase NextControlAfterKeyboardEvent { get; set; } Property Value IFrameworkControlActionBase Examples protected virtual void FE_edt3_OnLeave(FrameworkOnLeaveEventArgs e) { // Ausgabe der Informationen this.sInfo = \"edt3_OnLeave\" + \"\\r\\n Activator: \" + e.Activator + \"\\r\\n DefaultNextControl: \" + (e.DefaultNextControl == null ? \"<null>\" : e.DefaultNextControl.ControlName); // vorwärts >> Focus in das nächste Control setzen if (e.Activator == OnLeaveActivator.KeyboardEnter || e.Activator == OnLeaveActivator.KeyboardTabForward) { e.NextControlAfterKeyboardEvent = this.edt2; } // rückwärts >> Focus in das vorherige Control setzen else if (e.Activator == OnLeaveActivator.KeyboardTabBackward) { e.NextControlAfterKeyboardEvent = this.edtsInfo; } }"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.Activator.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.Activator.html",
    "title": "Property Activator",
    "keywords": "Property Activator | Improve this Doc View Source Activator Gibt die Ursache des Events (Typ OnLeaveActivator ) an. Declaration public OnLeaveActivator Activator { get; } Property Value OnLeaveActivator"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.DefaultNextControl.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.DefaultNextControl.html",
    "title": "Property DefaultNextControl",
    "keywords": "Property DefaultNextControl | Improve this Doc View Source DefaultNextControl Gibt das Control an, in welches der Focus als nächstes vom Client gesetzt wird bzw.gesetzt werden würde. Wenn der Focus in ein anderes Form wechselt, dann ist der Wert <null> . Declaration public IFrameworkControlActionBase DefaultNextControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.SourceControl.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.SourceControl.html",
    "title": "Property SourceControl",
    "keywords": "Property SourceControl | Improve this Doc View Source SourceControl Gibt an, aus welchem Control das Event gefeuert wurde. Das ist hilfreich, wenn die EventArgs als Parameter in andere Logiken übergeben werden. Declaration public IFrameworkControlActionBase SourceControl { get; } Property Value IFrameworkControlActionBase"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.HasValueChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.HasValueChanged.html",
    "title": "Property HasValueChanged",
    "keywords": "Property HasValueChanged | Improve this Doc View Source HasValueChanged Diese Eigenschaft gibt an, ob der Inhalt des Controls geändert wurde. So können Validierungsprüfungen in diesem Event behandelt werden. Declaration public bool HasValueChanged { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLeaveEventArgs.html",
    "title": "Class FrameworkOnLeaveEventArgs",
    "keywords": "Class FrameworkOnLeaveEventArgs Spezialisierung von FrameworkEventArgs . Die mit dem FormEvent von FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnLeaveDefinition des Parameters der Methode zugreifen. Inheritance Object EventArgs FrameworkEventArgs FrameworkOnLeaveEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnLeaveEventArgs : FrameworkEventArgs Examples private void MyDataGrid_DoubleClickEventHandler (FrameworkDoubleClickEventArgs e) { ArtikelObj = ArtikelColl[e.RowID]; } Properties Activator Gibt die Ursache des Events (Typ OnLeaveActivator ) an. DefaultNextControl Gibt das Control an, in welches der Focus als nächstes vom Client gesetzt wird bzw.gesetzt werden würde. Wenn der Focus in ein anderes Form wechselt, dann ist der Wert <null> . HasValueChanged Diese Eigenschaft gibt an, ob der Inhalt des Controls geändert wurde. So können Validierungsprüfungen in diesem Event behandelt werden. NextControlAfterKeyboardEvent Diese Eigenschaft kann vom Programmierer geändert werden.Hier kann das Control angegeben werden, in das der Focus als nächstes gesetzt werden soll.Dadurch wird die Angabe in DefaultNextControl übersteuert. Diese Angabe funktioniert aber nur, wenn das OnLeave durch eine Tastatur-Eingabe ausgelöst wurde.Wenn der Benutzer mit der Maus gezielt in ein anderes Control klickt, dann hat das für den Client Priorität. SourceControl Gibt an, aus welchem Control das Event gefeuert wurde. Das ist hilfreich, wenn die EventArgs als Parameter in andere Logiken übergeben werden."
  },
  "api/FrameworkSystems.FrameworkBase.StackPanelHAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkBase.StackPanelHAlignment.html",
    "title": "Enum StackPanelHAlignment",
    "keywords": "Enum StackPanelHAlignment Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum StackPanelHAlignment Fields Name Description Center Left Right"
  },
  "api/FrameworkSystems.FrameworkBase.DockPanelOrientation.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DockPanelOrientation.html",
    "title": "Enum DockPanelOrientation",
    "keywords": "Enum DockPanelOrientation Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [HideForIntellisense(true)] public enum DockPanelOrientation Fields Name Description Horizontal HorizontalOrVertical Vertical"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkColumnChangedEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkColumnChangedEventArgs.html",
    "title": "Class FrameworkColumnChangedEventArgs",
    "keywords": "Class FrameworkColumnChangedEventArgs !TODO Inheritance Object EventArgs FrameworkEventArgs FrameworkDoubleClickEventArgs FrameworkCellDoubleClickEventArgs FrameworkColumnChangedEventArgs Inherited Members FrameworkCellDoubleClickEventArgs.ColNum FrameworkCellDoubleClickEventArgs.ColumnName FrameworkDoubleClickEventArgs.RowID FrameworkDoubleClickEventArgs.RowIndex Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkColumnChangedEventArgs : FrameworkCellDoubleClickEventArgs"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.IsChecked.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.IsChecked.html",
    "title": "Property IsChecked",
    "keywords": "Property IsChecked | Improve this Doc View Source IsChecked Declaration public bool IsChecked { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkCheckBoxClickEventArgs.html",
    "title": "Class FrameworkCheckBoxClickEventArgs",
    "keywords": "Class FrameworkCheckBoxClickEventArgs Inheritance Object EventArgs FrameworkEventArgs FrameworkCheckBoxClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkCheckBoxClickEventArgs : FrameworkEventArgs Properties IsChecked"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html",
    "title": "Enum FrameworkCloseMode",
    "keywords": "Enum FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll. Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Flags] public enum FrameworkCloseMode Fields Name Description Close KeepUserLogin Restart"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html",
    "title": "Constructor FrameworkApplicationException",
    "keywords": "Constructor FrameworkApplicationException | Improve this Doc View Source FrameworkApplicationException(String) Declaration public FrameworkApplicationException(string msg) Parameters msg String | Improve this Doc View Source FrameworkApplicationException(String, Int32) Declaration public FrameworkApplicationException(string msg, int severity) Parameters msg String severity Int32 | Improve this Doc View Source FrameworkApplicationException(String, Exception) Declaration public FrameworkApplicationException(string msg, Exception innerEx) Parameters msg String innerEx Exception | Improve this Doc View Source FrameworkApplicationException(String, Int32, Exception) Declaration public FrameworkApplicationException(string msg, int severity, Exception innerEx) Parameters msg String severity Int32 innerEx Exception | Improve this Doc View Source FrameworkApplicationException(MLKeyText) Declaration public FrameworkApplicationException(MLKeyText mlkeyText) Parameters mlkeyText MLKeyText | Improve this Doc View Source FrameworkApplicationException(MLKeyText, Int32) Declaration public FrameworkApplicationException(MLKeyText mlkeyText, int severity) Parameters mlkeyText MLKeyText severity Int32 | Improve this Doc View Source FrameworkApplicationException(MLKeyText, Exception) Declaration public FrameworkApplicationException(MLKeyText mlkeyText, Exception innerEx) Parameters mlkeyText MLKeyText innerEx Exception | Improve this Doc View Source FrameworkApplicationException(MLKeyText, Int32, Exception) Declaration public FrameworkApplicationException(MLKeyText mlkeyText, int severity, Exception innerEx) Parameters mlkeyText MLKeyText severity Int32 innerEx Exception"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html",
    "title": "Property Severity",
    "keywords": "Property Severity | Improve this Doc View Source Severity Definiert den Schweregrad der Exception. Declaration public int Severity { get; } Property Value Int32 Remarks Diese Information wird momentan nicht ausgewertet."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLStringWithGlobal.html",
    "title": "Class DevMLStringWithGlobal",
    "keywords": "Class DevMLStringWithGlobal Eine Spezialisierung von DevMLString , die in in den TextCollection-Einträgen ( IDevFrameworkObjectMLString ) verwendet wird. Über den Eintrag besitzt diese Instanz das GlobalObject ( this.Global ). Inheritance Object DevMLString DevMLStringWithGlobal Inherited Members DevMLString.GetKey() DevMLString.HasKey DevMLString.GetString(IGlobalObjects, String) DevMLString.GetString(IGlobalObjects, IEnumerable<String>) DevMLString.GetString(IGlobalObjects) DevMLString.Item[IGlobalObjects] Namespace : FrameworkSystems.FrameworkBase.MultiLanguage Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevMLStringWithGlobal : DevMLString Properties Item[String] Gibt den Text in der gewünschten Sprache zurück. Methods GetString(String) Gibt den Text in der gewünschten Sprache zurück."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html",
    "title": "Struct FSfloat",
    "keywords": "Struct FSfloat TODO! Summary description for FSfloat. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSfloat : IFSfloat, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.ListViewTemplateVariableDataSourceOrigin.html": {
    "href": "api/FrameworkSystems.FrameworkBase.ListViewTemplateVariableDataSourceOrigin.html",
    "title": "Enum ListViewTemplateVariableDataSourceOrigin",
    "keywords": "Enum ListViewTemplateVariableDataSourceOrigin Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum ListViewTemplateVariableDataSourceOrigin Fields Name Description Form ListItem"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.HasError.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.HasError.html",
    "title": "Property HasError",
    "keywords": "Property HasError | Improve this Doc View Source HasError true wenn beim Bestimmen des Standortes ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Declaration bool HasError { get; } Property Value Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.ErrorMessage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.ErrorMessage.html",
    "title": "Property ErrorMessage",
    "keywords": "Property ErrorMessage | Improve this Doc View Source ErrorMessage Fehlermeldung, wenn der Standort nicht bestimmt werden konnte Declaration string ErrorMessage { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Latitude.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Latitude.html",
    "title": "Property Latitude",
    "keywords": "Property Latitude | Improve this Doc View Source Latitude Breitengrad z.B. 47.8477500 Declaration double? Latitude { get; } Property Value Nullable < Double >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Longitude.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Longitude.html",
    "title": "Property Longitude",
    "keywords": "Property Longitude | Improve this Doc View Source Longitude Längengrad z.B. 9.0057000 Declaration double? Longitude { get; } Property Value Nullable < Double >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Altitude.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Altitude.html",
    "title": "Property Altitude",
    "keywords": "Property Altitude | Improve this Doc View Source Altitude Höhe in Metern über dem Meeresspiegel Declaration int? Altitude { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Accuracy.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Accuracy.html",
    "title": "Property Accuracy",
    "keywords": "Property Accuracy | Improve this Doc View Source Accuracy Genauigkeit für die Werte Latitude und Logitude in Metern Declaration int? Accuracy { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Heading.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Heading.html",
    "title": "Property Heading",
    "keywords": "Property Heading | Improve this Doc View Source Heading Bewegungsrichtung in Grad relativ zum Norden (im Uhrzeigersinn) Declaration int? Heading { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Speed.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Speed.html",
    "title": "Property Speed",
    "keywords": "Property Speed | Improve this Doc View Source Speed Geschwindigkeit des Getätes in m/s Declaration int? Speed { get; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Timestamp.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Timestamp.html",
    "title": "Property Timestamp",
    "keywords": "Property Timestamp | Improve this Doc View Source Timestamp Zeitstempel der Standortbestimmung Declaration long? Timestamp { get; } Property Value Nullable < Int64 >"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Identifier.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.Identifier.html",
    "title": "Property Identifier",
    "keywords": "Property Identifier | Improve this Doc View Source Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworGeoLocationInfo},System.String) übergebene Wert, sonst null . Declaration string Identifier { get; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.IFrameworkGeoLocationInfo.html",
    "title": "Interface IFrameworkGeoLocationInfo",
    "keywords": "Interface IFrameworkGeoLocationInfo Eine Instanz dieses Typs wird nach einem mit der Action GetGeoLocation(Action<IFrameworkGeoLocationInfo>) ausgelösten Vorgang der Callback-Methode übergeben. Sie beinhaltet alle Informationen zum derzeitigen Standort des Endgeräts. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IFrameworkGeoLocationInfo Properties Accuracy Genauigkeit für die Werte Latitude und Logitude in Metern Altitude Höhe in Metern über dem Meeresspiegel ErrorMessage Fehlermeldung, wenn der Standort nicht bestimmt werden konnte HasError true wenn beim Bestimmen des Standortes ein Fehler aufgetreten ist. Die Details können über die ErrorMessage ermittelt werden. Heading Bewegungsrichtung in Grad relativ zum Norden (im Uhrzeigersinn) Identifier Der in der Action FrameworkSystems.FrameworkControls.GeneratedForm.GetGeoLocation(System.Action{FrameworkSystems.FrameworkBase.IFrameworGeoLocationInfo},System.String) übergebene Wert, sonst null . Latitude Breitengrad z.B. 47.8477500 Longitude Längengrad z.B. 9.0057000 Speed Geschwindigkeit des Getätes in m/s Timestamp Zeitstempel der Standortbestimmung"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeLoad.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeLoad.html",
    "title": "Method GlobalOnBeforeLoad",
    "keywords": "Method GlobalOnBeforeLoad | Improve this Doc View Source GlobalOnBeforeLoad(DevFrameworkObject, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf ein Einzelobjekt aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. Declaration void GlobalOnBeforeLoad(DevFrameworkObject obj, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Parameters obj DevFrameworkObject Component auf die der Load abgesetzt wurde. loadCondition String replacingHavingClause String replacingOrderClause String | Improve this Doc View Source GlobalOnBeforeLoad(DevFrameworkObjectColl, ref String, ref String, ref String) Bietet also einen Einsprungpunkt, um global alle Load Befehle modifizieren zu können. Diese Überladung wird beim Load auf eine Collection aufgerufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Die als Reeferenz übergebenen Load-Parameter können in der Methode modifiziert werden. Declaration void GlobalOnBeforeLoad(DevFrameworkObjectColl coll, ref string loadCondition, ref string replacingHavingClause, ref string replacingOrderClause) Parameters coll FrameworkSystems.FrameworkBase.DevFrameworkObjectColl Collection auf der der Load abgesetzt wurde. loadCondition String replacingHavingClause String replacingOrderClause String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeSaveAction.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IcGlobalBase.GlobalOnBeforeSaveAction.html",
    "title": "Method GlobalOnBeforeSaveAction",
    "keywords": "Method GlobalOnBeforeSaveAction | Improve this Doc View Source GlobalOnBeforeSaveAction(DevFrameworkObject) Diese Methode wird vor jedem Save, der für eine Component auf die Datenbank abgesetzt wird, durchlaufen. Die Methode kann in der Component FSGeneral.cGlobal überschrieben werden. Declaration void GlobalOnBeforeSaveAction(DevFrameworkObject obj) Parameters obj DevFrameworkObject"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.DatasourceOnValue.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.DatasourceOnValue.html",
    "title": "Property DatasourceOnValue",
    "keywords": "Property DatasourceOnValue | Improve this Doc View Source DatasourceOnValue Wert, bei dem der Radio-Button aktiv ist. Declaration [Browsable(true)] public int? DatasourceOnValue { get; set; } Property Value Nullable < Int32 >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird bei einem Click auf den Radio-Button ausgelöst. Der Button GroupDataSource des übergeordneten Panels wird auf den DataSourceOnValue-Wert gestellt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkRadioButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkRadioButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.RadioButtonDesignViewModel.html",
    "title": "Class RadioButtonDesignViewModel",
    "keywords": "Class RadioButtonDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel RadioButtonDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class RadioButtonDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Beschriftung des Radio-Buttons. Wird rechts neben dem Radio-Button angezeigt. DatasourceOnValue Wert, bei dem der Radio-Button aktiv ist. Events OnClick Wird bei einem Click auf den Radio-Button ausgelöst. Der Button GroupDataSource des übergeordneten Panels wird auf den DataSourceOnValue-Wert gestellt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ShowCaption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ShowCaption.html",
    "title": "Property ShowCaption",
    "keywords": "Property ShowCaption | Improve this Doc View Source ShowCaption Gibt an, ob das Caption angezeigt wird oder nicht. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? ShowCaption { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.CaptionAlign.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.CaptionAlign.html",
    "title": "Property CaptionAlign",
    "keywords": "Property CaptionAlign | Improve this Doc View Source CaptionAlign Wenn das Bild eine Caption anzeigen soll, können Sie hier bestimmen, wo dies arrangiert ist. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public ContentAlignment? CaptionAlign { get; set; } Property Value Nullable < ContentAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ScaleMode.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.ScaleMode.html",
    "title": "Property ScaleMode",
    "keywords": "Property ScaleMode | Improve this Doc View Source ScaleMode Diese Eigenschaft gibt an, wie ein Bild skaliert werden soll. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public PictureScaleMode? ScaleMode { get; set; } Property Value Nullable < PictureScaleMode > Remarks Wenn ein PictureControl durch Angabe von Anchors dynamisch vergrößert wird, dann ziehen die oben beschriebenen Einstellungen auch. Note Einschränkung: Die Modi funktionieren bei Bildern, die per Datasource als FSbyteArray an das Control übergeben werden. Bei Bildern, die über eine URL gelesen werden, funktionieren nur die Modi Normal und Stretch. Wenn ein anderer Mode angegeben ist, dann zieht Stretch ."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Image.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Image.html",
    "title": "Property Image",
    "keywords": "Property Image | Improve this Doc View Source Image URL zu dem Bild, das angezeigt werden soll. Zum Anwendungsverzeichnis relative und absolute Pfade sind zulässig. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string Image { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption | Improve this Doc View Source Caption Hinterlegen Sie hier mehrsprachig die Caption des Bildes. Declaration public override IMLString Caption { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.MultiLanguage.IMLString Overrides ControlDesignViewModel.Caption"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Hier kann eine Datenquelle angegeben werden, aus der das Bild zur Laufzeit ermittelt wird. Zur Auswahl stehen alle Properties des Forms (und deren Unter-Properties). Gültige Typen für den Datasource sind String und FSstring sowie Byte [] und FSbyteArray . Dabei gilt für die String Datentypen, dass der Inhalt eine URL zu dem Bild enthält, das dargestellt werden soll. Ist der Typ des Datasources ein Byte Array, so muss dieses Byte Array das Bild in einem der folgenden Formate darstellen: GIF, JPG oder PNG. Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.OnClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.OnClick.html",
    "title": "Event OnClick",
    "keywords": "Event OnClick Wird ausgelöst, wenn der Benutzer auf das Bild klickt. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkButtonClickEventArgs> OnClick Returns Type Description EventHandler < FrameworkButtonClickEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.PictureDesignViewModel.html",
    "title": "Class PictureDesignViewModel",
    "keywords": "Class PictureDesignViewModel Diese Klasse repräsentiert das Control Picture . Die Properties und Events dieser Klasse werden im Form-Designer angeboten. Inheritance Object ControlTreeNode ControlDesignViewModel PictureDesignViewModel Inherited Members ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class PictureDesignViewModel : ControlDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties Caption Hinterlegen Sie hier mehrsprachig die Caption des Bildes. CaptionAlign Wenn das Bild eine Caption anzeigen soll, können Sie hier bestimmen, wo dies arrangiert ist. DataSource Hier kann eine Datenquelle angegeben werden, aus der das Bild zur Laufzeit ermittelt wird. Zur Auswahl stehen alle Properties des Forms (und deren Unter-Properties). Gültige Typen für den Datasource sind String und FSstring sowie Byte [] und FSbyteArray . Dabei gilt für die String Datentypen, dass der Inhalt eine URL zu dem Bild enthält, das dargestellt werden soll. Ist der Typ des Datasources ein Byte Array, so muss dieses Byte Array das Bild in einem der folgenden Formate darstellen: GIF, JPG oder PNG. Image URL zu dem Bild, das angezeigt werden soll. Zum Anwendungsverzeichnis relative und absolute Pfade sind zulässig. ScaleMode Diese Eigenschaft gibt an, wie ein Bild skaliert werden soll. ShowCaption Gibt an, ob das Caption angezeigt wird oder nicht. Events OnClick Wird ausgelöst, wenn der Benutzer auf das Bild klickt. See Also PictureControlAction"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ControlEvents.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.ControlEvents.html",
    "title": "Property ControlEvents",
    "keywords": "Property ControlEvents | Improve this Doc View Source ControlEvents Dieses Property dient dazu, den Editor für die Events anzuzeigen. Es selber selber keinen relevanten Wert. (siehe Events ) Declaration [Browsable(true)] public object ControlEvents { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Documentation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.Documentation.html",
    "title": "Property Documentation",
    "keywords": "Property Documentation | Improve this Doc View Source Documentation Öffnet den Dokumentations-Editor (siehe Editor ) Declaration [Browsable(true)] public object Documentation { get; set; } Property Value Object"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.HideInDocumentation.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.HideInDocumentation.html",
    "title": "Property HideInDocumentation",
    "keywords": "Property HideInDocumentation | Improve this Doc View Source HideInDocumentation Gibt an, ob das ausgewählte Control in die Dokumentation gerendert werden soll oder nicht. Dies kann z.B. dann hilfreich sein, wenn in einem abgeleiteten Form Controls aus dem Basis-Form in der Dokumentation ausgeblendet werden sollen. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public bool? HideInDocumentation { get; set; } Property Value Nullable < Boolean >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Declaration [Browsable(true)] [TypeConverter(typeof(DataSourceTypeConverter))] public virtual IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.ControlDesignViewModel.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize | Improve this Doc View Source MaxSize Gibt die maximale Größe des Controls an. Die Größe des Controls zählt immer inklusive Padding und Border aber exklusive Margin. Die beiden Unter-Eigenschaften Width und Height können getrennt voneinander angegeben oder überschrieben werden. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public NonableSize MaxSize { get; set; } Property Value NonableSize Remarks Der spezielle Wert None definiert keine Angabe der Größe. Er muss vom Wert 0 unterschieden werden – damit wird das Control nicht angezeigt."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabPageDesignViewModel.html",
    "title": "Class TabPageDesignViewModel",
    "keywords": "Class TabPageDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TabPageDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TabPageDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ActiveImage Für die TabPage kann ein Header-Image hinterlegt, bzw. das auf Tabbed Window Ebene hinterlegte überschrieben werden. Das Image wird angezeigt, wenn das Tabbed Window aktiviert wird. Shortcut Definiert die Tastenkombination, mit der die TabPage ausgewählt werden kann. Der Shortcut wird in der Anwendung als Tooltip angezeigt, wenn sich die Maus über der TabPage befindet."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource | Improve this Doc View Source DataSource Der hinterlegte Datasource erhält einen Wert vom Typ Int, in dem zurückgegeben wird, welches Tab aktiv ist (mit 0 beginnend). Declaration public override IDatasource DataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.Base.IDatasource Overrides ControlDesignViewModel.DataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.TabAlignment.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.TabAlignment.html",
    "title": "Property TabAlignment",
    "keywords": "Property TabAlignment | Improve this Doc View Source TabAlignment Bestimmt, an welcher Stelle der Registerkarte die Bezeichnung/der Name der Registerkarte (der \"Reiter\", hier als Beispiel „Seite“) dargestellt wird. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public TabAlignment? TabAlignment { get; set; } Property Value Nullable < TabAlignment >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.ActiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.ActiveImage.html",
    "title": "Property ActiveImage",
    "keywords": "Property ActiveImage | Improve this Doc View Source ActiveImage Sie können für die Registerkarten-Bezeichnung Grafiken hinterlegen, welche im Viewer statt des normalen Graus angezeigt werden. Die aktuell ausgewählte Registerkarte zeigt die hier hinterlegte Grafik an. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string ActiveImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.InactiveImage.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.InactiveImage.html",
    "title": "Property InactiveImage",
    "keywords": "Property InactiveImage | Improve this Doc View Source InactiveImage Die Grafik wird auf allen Tabs angezeigt, die nicht aktiv sind. Declaration [Browsable(true)] [ControlStylesBrowsable(true)] public string InactiveImage { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChange.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChange.html",
    "title": "Event OnSelectedTabPageChange",
    "keywords": "Event OnSelectedTabPageChange Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar bevor das Programm auf das neue Tab gewechselt ist. Soll z.B. der Wechsel auf ein anderes Tab unterbunden werden, kann hier entsprechend eine Anweisung an den Datasource hinterlegt werden. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnSelectedTabChangeEventArgs> OnSelectedTabPageChange Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnSelectedTabChangeEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChanged.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.OnSelectedTabPageChanged.html",
    "title": "Event OnSelectedTabPageChanged",
    "keywords": "Event OnSelectedTabPageChanged Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar nachdem das Programm auf das neue Tab gewechselt ist. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<FrameworkOnSelectedTabChangedEventArgs> OnSelectedTabPageChanged Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnSelectedTabChangedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TabbedWindowDesignViewModel.html",
    "title": "Class TabbedWindowDesignViewModel",
    "keywords": "Class TabbedWindowDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TabbedWindowDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TabbedWindowDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ActiveImage Sie können für die Registerkarten-Bezeichnung Grafiken hinterlegen, welche im Viewer statt des normalen Graus angezeigt werden. Die aktuell ausgewählte Registerkarte zeigt die hier hinterlegte Grafik an. DataSource Der hinterlegte Datasource erhält einen Wert vom Typ Int, in dem zurückgegeben wird, welches Tab aktiv ist (mit 0 beginnend). InactiveImage Die Grafik wird auf allen Tabs angezeigt, die nicht aktiv sind. TabAlignment Bestimmt, an welcher Stelle der Registerkarte die Bezeichnung/der Name der Registerkarte (der \"Reiter\", hier als Beispiel „Seite“) dargestellt wird. Events OnSelectedTabPageChange Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar bevor das Programm auf das neue Tab gewechselt ist. Soll z.B. der Wechsel auf ein anderes Tab unterbunden werden, kann hier entsprechend eine Anweisung an den Datasource hinterlegt werden. OnSelectedTabPageChanged Dieses Event tritt auf, wenn der Benutzer auf ein anderes Tab klickt, und zwar nachdem das Programm auf das neue Tab gewechselt ist."
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ClosedIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ClosedIcon.html",
    "title": "Property ClosedIcon",
    "keywords": "Property ClosedIcon | Improve this Doc View Source ClosedIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist und benötigt das Property des NodeDataSource-Objekts. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public string ClosedIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OpenIcon.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OpenIcon.html",
    "title": "Property OpenIcon",
    "keywords": "Property OpenIcon | Improve this Doc View Source OpenIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist. Benötigt das Property des NodeDataSource-Objekts. Declaration [Browsable(true)] [DevBrowsable(true)] [ControlStylesBrowsable(true)] public string OpenIcon { get; set; } Property Value String"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ContinueEquivalent.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.ContinueEquivalent.html",
    "title": "Property ContinueEquivalent",
    "keywords": "Property ContinueEquivalent | Improve this Doc View Source ContinueEquivalent Um eine Rekursion aufzubauen, wählen Sie hier den eigenen TreeNode als ContinueEquivalent aus. Für Elemente der ersten Ebene ist null default, für Elemente der zweiten Ebene der TreeNode der ersten Ebene. Declaration [Browsable(true)] [DevBrowsable(true)] [TypeConverter(typeof(DevControlTreeNodeConverter))] public guid ContinueEquivalent { get; set; } Property Value guid"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.NodeDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.NodeDataSource.html",
    "title": "Property NodeDataSource",
    "keywords": "Property NodeDataSource | Improve this Doc View Source NodeDataSource DataSource des TreeNodes. Collections oder Textcollections sind möglich. Declaration [Browsable(true)] [DevBrowsable(true)] [TypeConverter(typeof(DataBindingConverter))] public NodeListDataSource NodeDataSource { get; set; } Property Value FrameworkSystems.FrameworkStudio.DevFormBase.DataBindings.NodeListDataSource"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnAfterSelect.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnAfterSelect.html",
    "title": "Event OnAfterSelect",
    "keywords": "Event OnAfterSelect Tritt ein, wenn ein Knoten ausgewählt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> OnAfterSelect Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnTreeNodeSelectedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDoubleClick.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDoubleClick.html",
    "title": "Event OnDoubleClick",
    "keywords": "Event OnDoubleClick Tritt ein, wenn auf einen Knoten doppelt geklickt wurde. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<DevEventHandlerOnTreeNodeSelectedEventArgs> OnDoubleClick Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnTreeNodeSelectedEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDragDrop.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.OnDragDrop.html",
    "title": "Event OnDragDrop",
    "keywords": "Event OnDragDrop Tritt ein, wenn ein Tree-Node per Drag and Drop innerhalb eines TreeViews oder (aus einem anderen TreeView) in einen TreeView verschoben wird. Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public event EventHandler<DevEventHandlerOnTreeNodeDragDropEventArgs> OnDragDrop Returns Type Description EventHandler < FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.DevEventHandlerOnTreeNodeDragDropEventArgs >"
  },
  "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels.TreeNodeDesignViewModel.html",
    "title": "Class TreeNodeDesignViewModel",
    "keywords": "Class TreeNodeDesignViewModel Inheritance Object ControlTreeNode ControlDesignViewModel ContainerDesignViewModel TreeNodeDesignViewModel Inherited Members ContainerDesignViewModel.GenerateDocSection ControlDesignViewModel.ControlEvents ControlDesignViewModel.Documentation ControlDesignViewModel.HideInDocumentation ControlDesignViewModel.DataSource ControlDesignViewModel.MaxSize ControlDesignViewModel.MinSize ControlDesignViewModel.Padding ControlDesignViewModel.Margin ControlDesignViewModel.BackColor ControlDesignViewModel.ForeColor ControlDesignViewModel.Caption ControlDesignViewModel.CtrlStyleName ControlDesignViewModel.TooltipText ControlDesignViewModel.Font ControlDesignViewModel.Alignment ControlDesignViewModel.TabStop ControlDesignViewModel.IsEditable ControlDesignViewModel.IsEditableAU ControlDesignViewModel.Visibility ControlDesignViewModel.IsVisibleAU ControlDesignViewModel.IsSearchField ControlDesignViewModel.SearchOperator ControlDesignViewModel.FullTextSearch ControlDesignViewModel.LabelTemplate ControlDesignViewModel.BorderColor ControlDesignViewModel.BorderThickness ControlDesignViewModel.BorderRadius ControlDesignViewModel.OnEnter ControlDesignViewModel.OnLeave ControlDesignViewModel.OnCanDrop ControlDesignViewModel.OnDrag ControlTreeNode.Name Namespace : FrameworkSystems.FrameworkStudio.General.DevObjects.Form.Designer.ViewModels Assembly : FrameworkSystems.FrameworkStudio.General.dll Syntax public class TreeNodeDesignViewModel : ContainerDesignViewModel, INotifyPropertyChanged, IDisposable, INamedRecord Properties ClosedIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist und benötigt das Property des NodeDataSource-Objekts. ContinueEquivalent Um eine Rekursion aufzubauen, wählen Sie hier den eigenen TreeNode als ContinueEquivalent aus. Für Elemente der ersten Ebene ist null default, für Elemente der zweiten Ebene der TreeNode der ersten Ebene. NodeDataSource DataSource des TreeNodes. Collections oder Textcollections sind möglich. OpenIcon Grafik die angezeigt wird, wenn der Knoten geschlossen ist. Benötigt das Property des NodeDataSource-Objekts. Events OnAfterSelect Tritt ein, wenn ein Knoten ausgewählt wurde. OnDoubleClick Tritt ein, wenn auf einen Knoten doppelt geklickt wurde. OnDragDrop Tritt ein, wenn ein Tree-Node per Drag and Drop innerhalb eines TreeViews oder (aus einem anderen TreeView) in einen TreeView verschoben wird."
  }
}