{
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsVisible.html",
    "title": "Property IsVisible",
    "keywords": "Property IsVisible IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsVisible { get; set; } Property Value Type Description System.Nullable < System.Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.TextAlign.html",
    "title": "Property TextAlign",
    "keywords": "Property TextAlign TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. Declaration public GridColumnDefinition.ColumnTextAlign? TextAlign { get; set; } Property Value Type Description System.Nullable < GridColumnDefinition.ColumnTextAlign >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Width.html",
    "title": "Property Width",
    "keywords": "Property Width Width Gibt die initiale Spaltenbreite zurück oder legt diese fest. Declaration public int? Width { get; set; } Property Value Type Description System.Nullable < System.Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Caption.html",
    "title": "Property Caption",
    "keywords": "Property Caption Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. Declaration public string Caption { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLCaption.html",
    "title": "Property MLCaption",
    "keywords": "Property MLCaption MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. Declaration public DevMLString MLCaption { get; set; } Property Value Type Description DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ToolTip.html",
    "title": "Property ToolTip",
    "keywords": "Property ToolTip ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Declaration public string ToolTip { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MLToolTip.html",
    "title": "Property MLToolTip",
    "keywords": "Property MLToolTip MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Declaration public DevMLString MLToolTip { get; set; } Property Value Type Description DevMLString"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.DependsDataSourceOnRowData.html",
    "title": "Property DependsDataSourceOnRowData",
    "keywords": "Property DependsDataSourceOnRowData DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. Declaration public bool? DependsDataSourceOnRowData { get; set; } Property Value Type Description System.Nullable < System.Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.List.html",
    "title": "Property List",
    "keywords": "Property List List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. Declaration public ColumnListDataSource List { get; set; } Property Value Type Description ColumnListDataSource"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ListSortOrder.html",
    "title": "Property ListSortOrder",
    "keywords": "Property ListSortOrder ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. Declaration public GridColumnDefinition.ColumnSortOrder ListSortOrder { get; set; } Property Value Type Description GridColumnDefinition.ColumnSortOrder"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ComponentType.html",
    "title": "Property ComponentType",
    "keywords": "Property ComponentType ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. Declaration public Type ComponentType { get; set; } Property Value Type Description System.Type"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.html",
    "title": "Class GridColumnDefinition",
    "keywords": "Class GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Inheritance System.Object GridColumnDefinition Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class GridColumnDefinition Constructors GridColumnDefinition() Properties Caption Gibt die Spaltenbezeichnung in der Sprache des Clients zurück oder legt diese fest. ComponentType Diese Eigenschaft muss nur dann gesetzt werden, wenn nicht alle Properties (bis auf das letzte) aus dem Property-Pfad Property konkrete Component-Typen sind, also z.B. ein Property den Typ DevFrameworkObject hat. Andernfalls kann der ComponentType über Reflection von Framework Studio automatisch ermittelt werden. DependsDataSourceOnRowData Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, ob die Liste abhängig von dem Datensatz der Reihe ist. EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. IsVisible Gibt die Sichtbarkeit der Spalte zurück oder legt diese fest. List Gibt den Listendatasource, der verwendet wird, wenn der EditorStyle auf „Combobox“ festgelegt ist, mit allen dazugehörigen Details zurück oder legt diesen fest. ListSortOrder Gibt für den Fall, dass die Daten in einer Combobox aufbereitet werden, zurück oder legt fest, wie die Einträge der Combobox sortiert werden sollen. MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. MLCaption Gibt die mehrsprachige Spaltenbezeichnung zurück oder legt diese fest. MLToolTip Gibt den mehrsprachigen ToolTip zurück oder legt diesen fest. Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. TextAlign Gibt die Ausrichtung der Texte in der Spalte zurück oder legt diese fest. ToolTip Gibt den ToolTip in der Sprache des Clients zurück oder legt diesen fest. Width Gibt die initiale Spaltenbreite zurück oder legt diese fest."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.GlobalObj",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.GlobalObj Interfaces IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.Now.html",
    "title": "Property Now",
    "keywords": "Property Now Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time. Declaration public static FSDateTime Now { get; } Property Value Type Description FSDateTime"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSDateTime.html",
    "title": "Struct FSDateTime",
    "keywords": "Struct FSDateTime TODO! Summary description for FSDateTime. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSDateTime : IFSDateTime, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen Properties Now Gets a FSDateTime object that is set to the current date and time (without milliseconds and ticks) on this computer, expressed as the local time."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.ImageByteArray.html",
    "title": "Property ImageByteArray",
    "keywords": "Property ImageByteArray ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde. Declaration public byte[] ImageByteArray { get; } Property Value Type Description System.Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ImageFlavorData.html",
    "title": "Class ImageFlavorData",
    "keywords": "Class ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. Inheritance System.Object FlavorData ImageFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ImageFlavorData : FlavorData Properties ImageByteArray Gibt im OnDrop Eventhandler das Bild im PNG-Format zurück, wenn im OnCanDrop Eventhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.BROKER_TAG.html",
    "title": "Field BROKER_TAG",
    "keywords": "Field BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string BROKER_TAG = \"fsbroker://\" Returns Type Description System.String Remarks Ressourcen mit fsbroker://RelativerPfad werden von dem Browser ausgewertet und durch den absoluten Pfad ersetzt."
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateCommand.html",
    "title": "Method CreateCommand",
    "keywords": "Method CreateCommand CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, IDictionary<string, string> args = null) Parameters Type Name Description System.String commandName System.Collections.Generic.IDictionary < System.String , System.String > args Returns Type Description System.String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: //Command-Args erstellen Dictionary<string, string> linkCommandArgs = new Dictionary<string, string>(); linkCommandArgs.Add(\"Key1\", \"1235\"); linkCommandArgs.Add(\"Key2\", \"Test\"); linkCommandArgs.Add(\"Key3\", \"Test 1234\"); // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", linkCommandArgs); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\"; CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. Declaration public static string CreateCommand(string commandName, params KeyValuePair<string, string>[] args) Parameters Type Name Description System.String commandName System.Collections.Generic.KeyValuePair < System.String , System.String >[] args Returns Type Description System.String Remarks Link-Kommandos beginnen mit dem Schlüsselwort fscommand und verfügen über ein Kommando ( commandName ) und über eine beliebige Anzahl von Argumenten ( args ). Die Argumente bestehen immer aus einem Schlüssel ( Key ) und einem Wert ( Value ) und können entweder als generische Auflistung vom Typ IDictionary oder einzeln als KeyValuePairs an die Funktion übergeben werden. Das Schlüsselwort, Kommando und die Argumente werden in Url Schreibweise miteinander verbunden, codiert und als string zurückgegeben. Die einzelnen Argumente können mit der Methode CreateArgument(String, Object) erzeugt werden, um die Konvertierung verschiedener Typen korrekt vorzunehmen. Die Verwendung von GenerateCommand könnte folgendermaßen aussehen: // Link-Kommand erstellen string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", new KeyValuePair<string, string>(\"Key1\", \"Wert1\"), BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); // Html-Link erzeugen und mit Content-Datsource vom Browser anzeigen lassen this.contentDatasource = \"<a href=\\\"\" + linkCommand + \">Link</a>\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateArgument.html",
    "title": "Method CreateArgument",
    "keywords": "Method CreateArgument CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. Declaration public static KeyValuePair<string, string> CreateArgument(string key, object value) Parameters Type Name Description System.String key System.Object value Returns Type Description System.Collections.Generic.KeyValuePair < System.String , System.String > Remarks So können z.B. die FS-Datentypen wie in dem nachfolgenden Beispiel als Wert übergeben werden: string linkCommand = BrowserCommand.CreateCommand(\"TestCommand\", BrowserCommand.CreateArgument(\"Belegnummer\", new FSlong(1005342)), BrowserCommand.CreateArgument(\"Belegart\", \"ABC\"), BrowserCommand.CreateArgument(\"Datum\", FSDateTime.Today)); Die FrameworkOnLinkClickEventArgs bieten Methoden GetArgument -Methoden (z.B. GetArgumentFSlong ) um mit dem richtigen Schlüssel einen Wert im entsprechenden FSTyp wieder auszulesen. Auslesen der Argumente im Browser-Event OnLinkClick : if (e.IsCommand && e.Command == \"TestCommand\") { FSlong lngDocumentID = e.GetArgumentFSlong(\"Belegnummer\"); FSstring sDocumentType = e.GetArgumentFSstring(\"Belegart\"); FSDateTime dtDate = e.GetArgumentFSDateTime(\"Datum\"); }"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.TryParseCommand.html",
    "title": "Method TryParseCommand",
    "keywords": "Method TryParseCommand TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben. Declaration public static bool TryParseCommand(string url, out string commandName, out Dictionary<string, string> args) Parameters Type Name Description System.String url System.String commandName System.Collections.Generic.Dictionary < System.String , System.String > args Returns Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.CreateRessourcesUrl.html",
    "title": "Method CreateRessourcesUrl",
    "keywords": "Method CreateRessourcesUrl CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. Declaration public static string CreateRessourcesUrl(string relativePath) Parameters Type Name Description System.String relativePath Returns Type Description System.String Remarks Diese Url kann dann, wie im nachfolgendem Beispiel, in Verbindung mit HTML z.B. als Link zu einer Datei verwendet warden: // Link zu einer CSS-Datei sStyle = \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + BrowserCommand.CreateRessourcesUrl(\"test.css\") + \"\\\" />\";"
  },
  "api/FrameworkSystems.FrameworkBase.BrowserCommand.html": {
    "href": "api/FrameworkSystems.FrameworkBase.BrowserCommand.html",
    "title": "Class BrowserCommand",
    "keywords": "Class BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. Inheritance System.Object BrowserCommand Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class BrowserCommand Fields BROKER_TAG Der Broker-Tag ist ein Platzhalter für den absoluten Pfad des Broker-Verzeichnisses. Methods CreateArgument(String, Object) Mit der Methode CreateArgument() können Event-Argumente für CreateCommand() einzeln erstellt werden. CreateCommand(String, IDictionary<String, String>) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateCommand(String, KeyValuePair<String, String>[]) Mit der Methode CreateCommand können Link-Kommandos mit der Notation fscommand:[Kommando]?[Key]=[Value]&[Key1]=[Value1]&…[KeyN]=[ValueN] erstellt werden. CreateRessourcesUrl(String) Mit dieser Methode kann eine Broker-Url erstellt werden, die vom Browser in einen absoluten Pfad umgewandelt wird. TryParseCommand(String, out String, out Dictionary<String, String>) Die Methode TryParseCommand ist das Gegenstück zu CreateCommand(String, IDictionary<String, String>) und extrahiert, falls es sich bei dem übergebenen Link ( url ) um ein Link-Kommando handelt, das Kommando ( commandName ) und die Argumente ( args ). Andernfalls wird false zurückgegeben."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.DevMLString.html",
    "title": "Class DevMLString",
    "keywords": "Class DevMLString TODO! Inheritance System.Object DevMLString Namespace : FrameworkSystems.FrameworkBase.MultiLanguage Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class DevMLString"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSlong.html",
    "title": "Struct FSlong",
    "keywords": "Struct FSlong TODO! Summary description for FSlong. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSlong : IFSlong, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DevFrameworkObject.html",
    "title": "Class DevFrameworkObject",
    "keywords": "Class DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. Inheritance System.Object FrameworkSystems.FrameworkBase.DevFrameworkBaseObject DevFrameworkObject Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public abstract class DevFrameworkObject : DevFrameworkBaseObject, ICloneable, IFSRebind, IDevFrameworkObject, IDevFrameworkBaseObject, FrameworkDataTransaction.ISource, IGuidObject, IGuidObjectBase"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.-ctor.html",
    "title": "Constructor ColumnListDataSource",
    "keywords": "Constructor ColumnListDataSource ColumnListDataSource() Declaration public ColumnListDataSource()"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DataSource.html",
    "title": "Property DataSource",
    "keywords": "Property DataSource DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. Declaration public string DataSource { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ContainsNullEntry.html",
    "title": "Property ContainsNullEntry",
    "keywords": "Property ContainsNullEntry ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. Declaration public bool? ContainsNullEntry { get; set; } Property Value Type Description System.Nullable < System.Boolean >"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMember.html",
    "title": "Property DisplayMember",
    "keywords": "Property DisplayMember DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string DisplayMember { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.ValueMember.html",
    "title": "Property ValueMember",
    "keywords": "Property ValueMember ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest. Declaration public string ValueMember { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CloseApplication.html",
    "title": "Method CloseApplication",
    "keywords": "Method CloseApplication CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. Declaration void CloseApplication() Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. Declaration void CloseApplication(FrameworkCloseMode closeMode) Parameters Type Name Description FrameworkCloseMode closeMode Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird. CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. Declaration void CloseApplication(string message) Parameters Type Name Description System.String message Die Meldung die am Client angezeigt werden soll. Wird String.Empty übergeben, wird die Anwendung ohne Meldung beendet. Wird null übergeben, verhält sich die Methode wie die parameterlose CloseApplication() . Remarks Diese Methode wirft intern eine Exception, die dafür sorgt, dass die gesamte Anwendung beendet wird. Dies wird auch dem Client mitgeteilt, sodass dieser ebenfalls geschlossen wird."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.AUHelper.html",
    "title": "Property AUHelper",
    "keywords": "Property AUHelper AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. Declaration AUHelper AUHelper { get; } Property Value Type Description AUHelper"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SelectedLanguage.html",
    "title": "Property SelectedLanguage",
    "keywords": "Property SelectedLanguage SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Declaration string SelectedLanguage { get; set; } Property Value Type Description System.String Remarks Beim Setzen der SelectedLanguage gibt es 2 Möglichkeiten: 1.) Es wird nur ein ISO-Code übergeben.Dieser wird an die erste Stelle der LanguageHierarchy gesetzt. Wenn dieser Code schon in der Hierarchie enthalten ist, dann wird dieser an die erste Stelle verschoben. 2.) Es wird eine Komma-separierte Liste von ISO-Codes übergeben.In diesem Fall wird aus dieser Liste eine neue LanguageHierarchy aufgebaut. Die Sprache wird beim Start im Client festgelegt. Der Broker wechselt beim Start der Anwendung ggf. auf die Default-Sprache der Anwendung, wenn die vom Client angefragte Sprache nicht zur Verfügung steht. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.CreateComponent.html",
    "title": "Method CreateComponent",
    "keywords": "Method CreateComponent CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. Declaration object CreateComponent(string componentName) Parameters Type Name Description System.String componentName Returns Type Description System.Object Remarks Das zurückgegebene Objekt muss ggf. in einen anderen Typ umgewandelt werden, damit eine Weiterverarbeitung möglich ist. DevFrameworkObject oObject = this.Global.CreateComponent(\"Namespace.cdComponent\") as DevFrameworkObject; DevFrameworkObjectColl oColl = this.Global.CreateComponent(\"Namespace.cdComponentColl\") as DevFrameworkObjectColl; Der ComponentName entspricht dem FullName des Typs. Dieser kann auch zur Laufzeit ermittelt werden. sComponentName = oComponent.GetType().FullName; Warning Da der übergebene Parameter nicht kompiliert ist, sollte diese Funktion nur in Ausnahmefällen eingesetzt werden, um z.B. verallgemeinerte Logik umzusetzen."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.GetCodeDirectory.html",
    "title": "Method GetCodeDirectory",
    "keywords": "Method GetCodeDirectory GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft. Declaration string GetCodeDirectory() Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.LanguageHierarchy.html",
    "title": "Property LanguageHierarchy",
    "keywords": "Property LanguageHierarchy LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. Declaration IEnumerable<string> LanguageHierarchy { get; set; } Property Value Type Description System.Collections.Generic.IEnumerable < System.String > Remarks Beim Setzen kann jeder Typ zugewiesen werden, der von IEnumerable<string> erbt. Es ist jedoch empfehlenswert, mit einer ReadOnlyCollection<string> zu arbeiten, um Manipulationen an dieser Liste zu verhindern. Diese kann zum Beispiel mit der Methode Liste<string>.AsReadOnly() erzeugt werden. Warning Dieser Wert sollte in einem normalen Broker nicht geändert werden."
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.SafeInitializing.html",
    "title": "Property SafeInitializing",
    "keywords": "Property SafeInitializing SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. Declaration bool SafeInitializing { get; } Property Value Type Description System.Boolean Remarks Der Modus kann mithilfe der Methode EndSafeInitialize() zurückgesetzt werden. Wenn diese Methode einmal aufgerufen wurde, dann ist es nicht mehr möglich, den Modus wieder zu aktivieren. Wenn dieser Modus aktiv ist, dann können z.B. in einer Update-Sitation Exceptions unterbunden werden, die den Start der Anwendung verhindern würden. Examples try { [Aktion] } catch (Exception ex) { if (this.Global.SafeInitializing) { [Fehler behandeln] } else { // Exception weiter werfen. throw; } }"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.EndSafeInitialize.html",
    "title": "Method EndSafeInitialize",
    "keywords": "Method EndSafeInitialize EndSafeInitialize() Deaktiviert den SafeInitializing Modus. Declaration void EndSafeInitialize()"
  },
  "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html": {
    "href": "api/FrameworkSystems.FrameworkBase.GlobalObj.IGlobalObjects.html",
    "title": "Interface IGlobalObjects",
    "keywords": "Interface IGlobalObjects Das GlobalObject ist von überall auf mit this.Global zu erreichen. Am GlobalObject werden alle Session-Daten verwaltet und Session-Funktionen angeboten. Namespace : FrameworkSystems.FrameworkBase.GlobalObj Assembly : FrameworkSystems.FrameworkBase.dll Syntax [ComVisible(false)] public interface IGlobalObjects : IFrameworkDBPerformanceCounter Properties AUHelper Gibt ein Objekt vom Typ AUHelper zurück. Dieses Objekt bietet Methoden für den Bereich Benutzer- und Rechte-Verwaltung an. LanguageHierarchy Gibt einen Enumeratur zurück, der die Sprach-Hierarchie beinhaltet, oder legt diesen fest. SafeInitializing Gibt zurück, ob der Safe-Initialize-Modus aktiv ist. Dieser Modus wird mithilfe einer Einstellung im Start-Workflow aktiviert. SelectedLanguage Gibt den 2-Zeichen IsoCode der ersten Sprache in der LanguageHierarchy zurück oder legt diesen fest. Methods CloseApplication() Schließt die Anwendung. Der Benutzer wird gefragt, ob er die Anwendung beenden möchte. An den geöffneten Forms wird die Methode IsApplicationQuitAllowed aufgerufen und eine entsprechende Message-Box ausgegeben bzw. das Schließen der Anwendung verhindert. CloseApplication(FrameworkCloseMode) Wird als closeMode das Flag Restart angegeben, so wird ein Neustart des Clients veranlasst. Allerdings darf ein Neustart nur unter der Bedingung ausgeführt werden, dass jedes aktuell laufende Ereignis eines der folgenden ist: MenuItem.OnClick Button.OnClick ImageButton.OnClick MessageBox-Event(Als Folge eine der oben genannten Events) Mit aktuell laufenden Ereignissen sind auch solche Ereignisse gemeint, die als Folge einen modalen Dialog geöffnet haben.Solange der Dialog offen ist, zählt das Ereignis zu den laufenden. Zusätzlich gibt es das Flag KeepUserLogin . Wird Restart mit diesem Flag kombiniert (bitweise Oder-Verknüpfung), so wird beim Neustart der User Token in die neue Sitzung übernommen und es ist kein erneuter Login erforderlich. CloseApplication(String) Schließt die Anwendung unmittelbar. Es wird keine weitere Prüfung durchgeführt und der Benutzer hat keine Möglichkeit die Aktion abzubrechen. Am Client wird dabei die übergebene Message ausgegeben. CreateComponent(String) Erzeugt eine neue Component mit dem übergebenen Namen. EndSafeInitialize() Deaktiviert den SafeInitializing Modus. GetCodeDirectory() Liefert den Pfad des Verzeichnisses, in dem die Anwendung läuft."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Size.html",
    "title": "Property Size",
    "keywords": "Property Size Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Declaration public long Size { get; protected set; } Property Value Type Description System.Int64"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Type.html",
    "title": "Property Type",
    "keywords": "Property Type Type Gibt den Typ der Datei zurück. Declaration public FileFlavorData.FileType Type { get; protected set; } Property Value Type Description FileFlavorData.FileType Remarks Mögliche Werte sind : File : Datei Directory : Verzeichnis"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Name.html",
    "title": "Property Name",
    "keywords": "Property Name Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Declaration public string Name { get; protected set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FullName.html",
    "title": "Property FullName",
    "keywords": "Property FullName FullName Gibt den Dateinamen inklusive Pfad zurück. Declaration public string FullName { get; protected set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.LastModified.html",
    "title": "Property LastModified",
    "keywords": "Property LastModified LastModified Gibt das letzte Änderungsdatum der Datei zurück. Declaration public DateTime LastModified { get; protected set; } Property Value Type Description System.DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.Content.html",
    "title": "Property Content",
    "keywords": "Property Content Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. Declaration public byte[] Content { get; protected set; } Property Value Type Description System.Byte []"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.Image.html",
    "title": "Field Image",
    "keywords": "Field Image Stellt ein Bild dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string Image = \"image/x-java-image\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.FileList.html",
    "title": "Field FileList",
    "keywords": "Field FileList Stellt Dateien dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string FileList = \"application/x-java-file-list\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextXml.html",
    "title": "Field TextXml",
    "keywords": "Field TextXml Stellt Text im XML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextXml = \"text/xml\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextHtml.html",
    "title": "Field TextHtml",
    "keywords": "Field TextHtml Stellt Text im HTML-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextHtml = \"text/html\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextRtf.html",
    "title": "Field TextRtf",
    "keywords": "Field TextRtf Stellt Text im RTF-Format dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextRtf = \"text/rtf\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextUriList.html",
    "title": "Field TextUriList",
    "keywords": "Field TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextUriList = \"text/uri-list\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.TextPlain.html",
    "title": "Field TextPlain",
    "keywords": "Field TextPlain Stellt unformatierten Text dar. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string TextPlain = \"text/plain\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.IsTextFlavor.html",
    "title": "Method IsTextFlavor",
    "keywords": "Method IsTextFlavor IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist. Declaration public static bool IsTextFlavor(string flavorType) Parameters Type Name Description System.String flavorType Returns Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorType.html",
    "title": "Class FlavorType",
    "keywords": "Class FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. Inheritance System.Object FlavorType Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static class FlavorType Remarks Diese Klasse stellt primär Konstanten für alle von Framework Studio bekannten Datenformate zur Verfügung. Die Konstanten sind vom Typ String. So kann das externe Transferobjekt grundsätzlich auch unbekannte Datenformate unterstützen. Fields FileList Stellt Dateien dar. Image Stellt ein Bild dar. TextHtml Stellt Text im HTML-Format dar. TextPlain Stellt unformatierten Text dar. TextRtf Stellt Text im RTF-Format dar. TextUriList Stellt eine Liste von URIs (Uniform Resource Identifier) (unter anderem als Text) dar. TextXml Stellt Text im XML-Format dar. Methods IsTextFlavor(String) Gibt zurück, ob das übergebene Format ein Textformat ist."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyteArray.html",
    "title": "Struct FSbyteArray",
    "keywords": "Struct FSbyteArray TODO! Summary description for FSbyteArray. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyteArray : IFSbyteArray, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.DragAndDrop Classes ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. FlavorType Wenn bei einem Drag&Drop-Vorgang Daten von außerhalb der Applikation in die Applikation hinein gezogen werden, so wird in den Events OnCanDrop und OnDrop ( Drag&Drop Events) ein TransferObject vom Typ ExternalTransferObject ( ExternalTransferObject ) zur Verfügung gestellt. An diesem externen Transferobjekt können alle Datenformate und die dazugehörigen Daten abgerufen werden. ImageFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang das transportierte Bild dar. TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Enums FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist."
  },
  "api/FrameworkSystems.FrameworkExceptions.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.html",
    "title": "Namespace FrameworkSystems.FrameworkExceptions",
    "keywords": "Namespace FrameworkSystems.FrameworkExceptions Classes FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Enums FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.ValueAsObject.html",
    "title": "Property ValueAsObject",
    "keywords": "Property ValueAsObject ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Declaration object ValueAsObject { get; set; } Property Value Type Description System.Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.IsNull.html",
    "title": "Property IsNull",
    "keywords": "Property IsNull IsNull Gibt an, ob der Wert der Variable Null ist. Declaration bool IsNull { get; set; } Property Value Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.HasValue.html",
    "title": "Property HasValue",
    "keywords": "Property HasValue HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. Declaration bool HasValue { get; } Property Value Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.GetFromObject.html",
    "title": "Method GetFromObject",
    "keywords": "Method GetFromObject GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter. Declaration IFSType GetFromObject(object val) Parameters Type Name Description System.Object val Returns Type Description IFSType"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.DBValue.html",
    "title": "Property DBValue",
    "keywords": "Property DBValue DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. Declaration object DBValue { get; } Property Value Type Description System.Object"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.EqualsValue.html",
    "title": "Method EqualsValue",
    "keywords": "Method EqualsValue EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. Declaration bool EqualsValue(string value2) Parameters Type Name Description System.String value2 Returns Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.IFSType.html",
    "title": "Interface IFSType",
    "keywords": "Interface IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung. Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkDataProvider.dll Syntax public interface IFSType : IComparable Remarks Siehe auch: FS-Datentypen Properties DBValue Gibt den Wert passend für die Verwendung in SQL-Parametern oder Datasets zurück. HasValue Gibt an, ob die Varaiable einen Wert hat - also nicht Null ist. IsNull Gibt an, ob der Wert der Variable Null ist. ValueAsObject Liefert den Wert verpackt als object zurück. Wird z.B. im Databinding verwendet. Methods EqualsValue(String) Wandelt value2 vor dem Vergleich in den Datentyp vom FSType, an dem die Methode aufgerufen wurde, um. GetFromObject(Object) Leitet lediglich den Aufruf an die statische FromObject Variante, die es in jeder implementierenden Klasse gibt weiter."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.FileType.html",
    "title": "Enum FileFlavorData.FileType",
    "keywords": "Enum FileFlavorData.FileType Der Dateityp, der Verzeichnis oder Datei ist. Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FileType Fields Name Description Directory Ordner / Verzeichnis. File Datei."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedFlavorTypes.html",
    "title": "Method GetSupportedFlavorTypes",
    "keywords": "Method GetSupportedFlavorTypes GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedFlavorTypes() Returns Type Description System.Collections.Generic.IEnumerable < System.String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetSupportedTextFlavorTypes.html",
    "title": "Method GetSupportedTextFlavorTypes",
    "keywords": "Method GetSupportedTextFlavorTypes GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. Declaration public IEnumerable<string> GetSupportedTextFlavorTypes() Returns Type Description System.Collections.Generic.IEnumerable < System.String >"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.IsFlavorTypeSupported.html",
    "title": "Method IsFlavorTypeSupported",
    "keywords": "Method IsFlavorTypeSupported IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können. Declaration public bool IsFlavorTypeSupported(string flavorType) Parameters Type Name Description System.String flavorType Returns Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFlavorData.html",
    "title": "Method GetFlavorData",
    "keywords": "Method GetFlavorData GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . Declaration public FlavorData GetFlavorData(string flavorType) Parameters Type Name Description System.String flavorType Returns Type Description FlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetTextFlavorData.html",
    "title": "Method GetTextFlavorData",
    "keywords": "Method GetTextFlavorData GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . Declaration public TextFlavorData GetTextFlavorData(string textFlavorType) Parameters Type Name Description System.String textFlavorType Returns Type Description TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorType.html",
    "title": "Method GetBestTextFlavorType",
    "keywords": "Method GetBestTextFlavorType GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. Declaration public string GetBestTextFlavorType() Returns Type Description System.String Remarks Zu dem Daten zur Verfügung gestellt werden: TextXml TextHtml TextUriList TextPlain Ein unbekanntes Textformat, soweit eines unterstützt wird null , falls gar kein Textformat unterstützt wird"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetBestTextFlavorData.html",
    "title": "Method GetBestTextFlavorData",
    "keywords": "Method GetBestTextFlavorData GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. Declaration public TextFlavorData GetBestTextFlavorData() Returns Type Description TextFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetImageFlavorData.html",
    "title": "Method GetImageFlavorData",
    "keywords": "Method GetImageFlavorData GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . Declaration public ImageFlavorData GetImageFlavorData() Returns Type Description ImageFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetFileListFlavorData.html",
    "title": "Method GetFileListFlavorData",
    "keywords": "Method GetFileListFlavorData GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . Declaration public FileListFlavorData GetFileListFlavorData() Returns Type Description FileListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.GetUriListFlavorData.html",
    "title": "Method GetUriListFlavorData",
    "keywords": "Method GetUriListFlavorData GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . Declaration public UriListFlavorData GetUriListFlavorData() Returns Type Description UriListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.ExternalTransferObject.html",
    "title": "Class ExternalTransferObject",
    "keywords": "Class ExternalTransferObject Ein Objekt dieser Klasse wird in den Events OnCanDrop und OnDrop (Drag&Drop Events) als TransferObject in den Eventparametern übergeben, wenn der Drag&Drop-Vorgang von außerhalb der Applikation in die Applikation hinein ausgelöst wurde. Inheritance System.Object ExternalTransferObject Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class ExternalTransferObject Remarks Die Klasse bietet Methoden, mit denen ermittelt werden kann, welche FlavorTypes ( FlavorType ) unterstützt werden, also in welchen Formaten Daten zur Verfügung stehen. Außerdem können zu jedem FlavorType die entsprechenden Daten ( FlavorData ) abgefragt werden. In den Events OnCanDrop und OnDrop kann eindeutig erkannt werden, ob es sich um einen internen oder einen externen Drag&Drop-Vorgang handelt, indem überprüft wird, ob das TransferObject vom Typ ExternalTransferObject ist. Examples ExternalTransferObject oExternalTransferObject = e.TransferObject as ExternalTransferObject; if (oExternalTransferObject != null) { // Drag&Drop-Vorgang von außerhalb der Applikation } else { // Drag&Drop-Vorgang innerhalb der Applikation } Methods GetBestTextFlavorData() Gibt die Daten zu dem mit der Methode GetBestTextFlavorType() ermittelten Textformat ( TextFlavorData ) zurück. Wenn kein Textformat unterstützt wird, wird null zurück gegeben. GetBestTextFlavorType() Gibt das erste Textformat aus der folgenden Prioritätenliste zurück. GetFileListFlavorData() Wenn im Drag&Drop-Vorgang Dateien transportiert werden, werden die Daten im Format einer Dateiliste ( FileListFlavorData ) zurückgegeben, andernfalls null . GetFlavorData(String) Wenn zu dem angegebenen Datenformat Daten abgerufen werden können, so werden diese (als Spezialisierung von FlavorData ) zurückgegeben, andernfalls null . GetImageFlavorData() Wenn im Drag&Drop-Vorgang ein Bild transportiert wird, werden die Bilddaten ( ImageFlavorData ) zurückgegeben, andernfalls null . GetSupportedFlavorTypes() Gibt alle Datenformate zurück, zu denen Daten abgerufen werden können. GetSupportedTextFlavorTypes() Gibt alle Textformate zurück, zu denen Daten abgerufen werden können. GetTextFlavorData(String) Gibt die Daten zum angegebenen Textformat zurück, falls abrufbar, ansonsten null . GetUriListFlavorData() Wenn im Drag&Drop-Vorgang URIs (Uniform Resource Identifier) transportiert werden, werden diese als URI-Liste ( UriListFlavorData ) zurückgegeben, ansonsten null . IsFlavorTypeSupported(String) Gibt zurück, ob Daten zum angegebenen Format abgerufen werden können."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UserTokenAsString.html",
    "title": "Property UserTokenAsString",
    "keywords": "Property UserTokenAsString UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string UserTokenAsString { get; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Username.html",
    "title": "Property Username",
    "keywords": "Property Username Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Declaration public string Username { get; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IsDefaultUser.html",
    "title": "Property IsDefaultUser",
    "keywords": "Property IsDefaultUser IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. Declaration public bool IsDefaultUser { get; } Property Value Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.AuthenticationEnabled.html",
    "title": "Property AuthenticationEnabled",
    "keywords": "Property AuthenticationEnabled AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. Declaration public bool AuthenticationEnabled { get; } Property Value Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyDefaultUser.html",
    "title": "Method IdentifyDefaultUser",
    "keywords": "Method IdentifyDefaultUser IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser() Returns Type Description System.Boolean Gibt bei Erfolg true und bei einem Fehler false zurück. IdentifyDefaultUser(out AUHelper.Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyDefaultUser(out AUHelper.Message msg) Parameters Type Name Description FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message msg Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. Returns Type Description System.Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUser.html",
    "title": "Method IdentifyUser",
    "keywords": "Method IdentifyUser IdentifyUser(out AUHelper.Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. Declaration public bool IdentifyUser(out AUHelper.Message msg, string username, string password, ref string loginInfo, bool includeRolesInToken) Parameters Type Name Description FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message msg Im übergebenen Message Objekt wird der Erfolg bzw. der Grund bei Misserfolg angegeben. System.String username System.String password System.String loginInfo Der Parameter LoginIngo wird ausgelesen und vom Authentication Service geloggt. Zurückgegeben wird die zuletzt geloggte Information. System.Boolean includeRolesInToken Der letzte Parameter gibt an, ob die Rollen im Token kommuniziert werden sollen - Standardwert true Returns Type Description System.Boolean Gibt bei Erfolg true und bei einem Fehler false zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.IdentifyUnit.html",
    "title": "Method IdentifyUnit",
    "keywords": "Method IdentifyUnit IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. Declaration public void IdentifyUnit(string unitKey) Parameters Type Name Description System.String unitKey"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.UnitKey.html",
    "title": "Property UnitKey",
    "keywords": "Property UnitKey UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Declaration public string UnitKey { get; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Units.html",
    "title": "Property Units",
    "keywords": "Property Units Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Declaration public IEnumerable<KeyValuePair<string, string>> Units { get; } Property Value Type Description System.Collections.Generic.IEnumerable < System.Collections.Generic.KeyValuePair < System.String , System.String >> Remarks KeyValuePair.Key = Schlüsselwert der Unit (Geschäftseinheit) KeyValuePair.Value = Name der Unit"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Granted.html",
    "title": "Method Granted",
    "keywords": "Method Granted Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. Declaration public bool Granted(AccessUnit accessUnit, AUPermissionType type) Parameters Type Name Description AccessUnit accessUnit AUPermissionType type Returns Type Description System.Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1, AUPermissionType.Delete ) ) { //Delete granted } if ( this.Global.Granted(AUList.aufrmForm1, AUPermissionType.Insert) ) { //Insert granted } Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Declaration public bool Granted(AccessUnit accessUnit) Parameters Type Name Description AccessUnit accessUnit Eine AccessUnit aus der AUList . Returns Type Description System.Boolean Remarks Es wird dann Zugriff auf eine AccessUnit gewährt, wenn sowohl die Lizenz als auch die dem Benutzer zugeteilten Rollen diese freischalten. Examples if ( this.Global.AUHelper.Granted( AUList.aufrmForm1 ) ) { //Access granted }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.LicenseGranted.html",
    "title": "Method LicenseGranted",
    "keywords": "Method LicenseGranted LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. Declaration public bool LicenseGranted(AccessUnit accessUnit, AUPermissionType type) Parameters Type Name Description AccessUnit accessUnit Eine AccessUnit aus der AUList . AUPermissionType type Eine AUPermissionType Returns Type Description System.Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access } LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt Declaration public bool LicenseGranted(AccessUnit accessUnit) Parameters Type Name Description AccessUnit accessUnit Eine AccessUnit aus der AUList . Returns Type Description System.Boolean Remarks Bei der Überprüfung der Rechte werden die zugeteilten Rollen nicht berücksichtigt. Examples if ( this.Global.AUHelper.LicenseGranted( AUList.aufrmForm1 ) ) { //License allows Access }"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetPackages.html",
    "title": "Method GetPackages",
    "keywords": "Method GetPackages GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. Declaration public List<AUHelper.PackageInfo> GetPackages() Returns Type Description System.Collections.Generic.List < AUHelper.PackageInfo > Remarks Das SystemPackage ist in der Liste nicht enthalten. Die Liste beginnt mit dem DefaultPackage und endet mit dem obersten CustomizingPackage. Die Klasse AUHelper.PackageInfo enthält über ein Package die Informationen ID, Name, Version und Hersteller (Manufacturer)."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePasswordChecked.html",
    "title": "Method ChangePasswordChecked",
    "keywords": "Method ChangePasswordChecked ChangePasswordChecked(String, String, String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, string oldPassword, string newPassword, out AUHelper.Message message, string loginInfo) Parameters Type Name Description System.String username System.String oldPassword System.String newPassword FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message message System.String loginInfo beliebiger Text, der vom Authentication Service geloggt wird, darf null sein ChangePasswordChecked(String, Byte[], String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. Declaration public void ChangePasswordChecked(string username, byte[] oldHashSign, string newPassword, out AUHelper.Message message, string loginInfo) Parameters Type Name Description System.String username System.Byte [] oldHashSign Der Hashwert des alten Passwortes. System.String newPassword FrameworkSystems.FrameworkBase.AccessControl.AUHelper.Message message System.String loginInfo beliebiger Text, der vom Authentication Service geloggt wird, darf null sein"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XMLNumberFormat.html",
    "title": "Field XMLNumberFormat",
    "keywords": "Field XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo XMLNumberFormat Returns Type Description System.Globalization.CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.DateTimeNumberFormat.html",
    "title": "Field DateTimeNumberFormat",
    "keywords": "Field DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public static readonly CultureInfo DateTimeNumberFormat Returns Type Description System.Globalization.CultureInfo"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.Get.html",
    "title": "Property Get",
    "keywords": "Property Get Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Declaration public static XmlConverter Get { get; } Property Value Type Description XmlConverter"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.IsConvertible.html",
    "title": "Method IsConvertible",
    "keywords": "Method IsConvertible IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). Declaration public bool IsConvertible(Type type) Parameters Type Name Description System.Type type Returns Type Description System.Boolean IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. Declaration public bool IsConvertible(string typeName) Parameters Type Name Description System.String typeName Returns Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public T FromXml<T>(string xml) Parameters Type Name Description System.String xml Returns Type Description T Type Parameters Name Description T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml<T>(T value) Parameters Type Name Description T value Returns Type Description System.String Type Parameters Name Description T ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . Declaration public string ToXml(object value) Parameters Type Name Description System.Object value Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.html",
    "title": "Class XmlConverter",
    "keywords": "Class XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Inheritance System.Object XmlConverter Implements IXmlConverter < FSbool > IXmlConverter < FSbyte > IXmlConverter < FSbyteArray > IXmlConverter < FSDateTime > IXmlConverter < FSdecimal > IXmlConverter < FSdouble > IXmlConverter < FSfloat > IXmlConverter < FSint > IXmlConverter < FSlong > IXmlConverter < FSshort > IXmlConverter < FSstring > IXmlConverter < FSSystemGuid > IXmlConverter < System.Boolean > IXmlConverter < System.Byte > IXmlConverter < System.Byte []> IXmlConverter < System.DateTime > IXmlConverter < System.Decimal > IXmlConverter < System.Double > IXmlConverter < System.Single > IXmlConverter < System.Int32 > IXmlConverter < System.Int64 > IXmlConverter < System.Int16 > IXmlConverter < System.String > IXmlConverter < System.Guid > Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class XmlConverter : IXmlConverter<FSbool>, IXmlConverter<FSbyte>, IXmlConverter<FSbyteArray>, IXmlConverter<FSDateTime>, IXmlConverter<FSdecimal>, IXmlConverter<FSdouble>, IXmlConverter<FSfloat>, IXmlConverter<FSint>, IXmlConverter<FSlong>, IXmlConverter<FSshort>, IXmlConverter<FSstring>, IXmlConverter<FSSystemGuid>, IXmlConverter<bool>, IXmlConverter<byte>, IXmlConverter<byte[]>, IXmlConverter<DateTime>, IXmlConverter<decimal>, IXmlConverter<double>, IXmlConverter<float>, IXmlConverter<int>, IXmlConverter<long>, IXmlConverter<short>, IXmlConverter<string>, IXmlConverter<Guid> Remarks Ein Objekt dieser Klasse wird als Singleton-Instanz angeboten. Note Im Java-Client gibt es ein entsprechendes Gegenstück, die Klasse FrameworkSystems.FSJavaClient.UIWrapper.DotNetTypes , welche statische Methoden zum Umwandeln von Objekten in einen String und umgekehrt anbietet. Unterstützte Typen Die Klasse unterstützt die Konvertierung ausschließlich für die im Folgenden aufgeführten Typen und implementiert für jeden der Typen T das entsprechende Interface IXmlConverter<T> : FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring FSSystemGuid bool byte byte[] DateTime decimal double float int long short string Guid Fields DateTimeNumberFormat Definiert das CultureInfo Objekt für das Format, in dem eine Datums- oder Zeitangabe im XML übertragen werden. XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. XMLNumberFormat Definiert das CultureInfo Objekt für das Format, in dem allgemein numerische Daten im XML übertragen werden. Properties Get Gibt die Singleton-Instanz der Klasse XmlConverter zurück. Methods FromXml<T>(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T . Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . IsConvertible(String) Gibt zurück, ob Objekte vom Typ typeName umgewandelt werden können ( Unterstützte Typen ). Zulässig ist sowohl die Angabe von integrierten Typen (z.B. long ) als auch deren .NET-Klassen (z.B. Int64 ), welche außerdem vollreferenziert (FullName) angegeben werden dürfen. IsConvertible(Type) Gibt zurück, ob Objekte des übergebenen Typs umgewandelt werden können ( Unterstützte Typen ). ToXml(Object) Konvertiert das übergebene Objekt in die String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException . ToXml<T>(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung im Xml. Nicht unterstützte Datentypen ( Unterstützte Typen ) führen zu einer NotImplementedException ."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileFlavorData.html",
    "title": "Class FileFlavorData",
    "keywords": "Class FileFlavorData Diese Klasse stellt eine einzelne Datei dar, die in einem externen Drag&Drop-Vorgang transportiert wird. Eine einzelne Datei ist immer ein Element einer Liste von Dateien ( FileListFlavorData ). Inheritance System.Object FileFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileFlavorData Properties Content Gibt den Dateiinhalt zurück. Dieser steht erst im OnDrop Eventhandler zur Verfügung und nur dann, wenn am FileFlavorData die Methode FillOnDrop() aufgerufen wurde. FullName Gibt den Dateinamen inklusive Pfad zurück. LastModified Gibt das letzte Änderungsdatum der Datei zurück. Name Gibt den Dateinamen (inkl. Dateiendung) zurück. Size Gibt die Größe der Datei in Bytes zurück. Diese Eigenschaft ist bereits im Event OnCanDrop gefüllt. Type Gibt den Typ der Datei zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AUPermissionType.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AUPermissionType.html",
    "title": "Enum AUPermissionType",
    "keywords": "Enum AUPermissionType Kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public enum AUPermissionType Fields Name Description Access Is general access allowed? AccessDerived Is access of an AccessUnit, which is derived from this AccessUnit, possible? Delete Is deleting allowed? Insert Is inserting allowed? Update Is updating allowed?"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.MLContainer.html",
    "title": "Class MLContainer",
    "keywords": "Class MLContainer TODO! Inheritance System.Object MLContainer Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class MLContainer"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSint.html",
    "title": "Struct FSint",
    "keywords": "Struct FSint TODO! Summary description for FSint. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSint : IFSint, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.Data Enums ComboEditStyle TODO!"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdouble.html",
    "title": "Struct FSdouble",
    "keywords": "Struct FSdouble TODO! Summary description for FSdouble. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdouble : IFSdouble, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnSortOrder.html",
    "title": "Enum GridColumnDefinition.ColumnSortOrder",
    "keywords": "Enum GridColumnDefinition.ColumnSortOrder Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnSortOrder Fields Name Description Ascending Descending Unsorted"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbool.html",
    "title": "Struct FSbool",
    "keywords": "Struct FSbool Summary description for FSbool. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbool : IFSbool, IFSType, IComparable, IConvertible Remarks TODO! Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.ChangePassword.html",
    "title": "Method ChangePassword",
    "keywords": "Method ChangePassword ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. Declaration public void ChangePassword(string oldPassword, string newPassword) Parameters Type Name Description System.String oldPassword System.String newPassword"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetAllLanguages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetAllLanguages.html",
    "title": "Method GetAllLanguages",
    "keywords": "Method GetAllLanguages GetAllLanguages() Gibt eine Liste mit ISO Kürzeln aller an dieser Applikation bekannten Sprachen zurück. Declaration public List<string> GetAllLanguages() Returns Type Description System.Collections.Generic.List < System.String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetGrantedLanguages.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetGrantedLanguages.html",
    "title": "Method GetGrantedLanguages",
    "keywords": "Method GetGrantedLanguages GetGrantedLanguages() Gibt eine Liste mit ISO Kürzeln der Sprachen zurück, die zur Verfügung stehen und durch die verwendeten Lizenzen freigegeben sind. Declaration public List<string> GetGrantedLanguages() Returns Type Description System.Collections.Generic.List < System.String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetApplicationRoles.html",
    "title": "Method GetApplicationRoles",
    "keywords": "Method GetApplicationRoles GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles(bool reload) Parameters Type Name Description System.Boolean reload Mit true wird ein neues Laden der Rollen vom Authentication Service erzwungen. Returns Type Description System.Collections.Generic.List < System.String > GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. Declaration public List<string> GetApplicationRoles() Returns Type Description System.Collections.Generic.List < System.String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserRoles.html",
    "title": "Method GetUserRoles",
    "keywords": "Method GetUserRoles GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. Declaration public List<string> GetUserRoles() Returns Type Description System.Collections.Generic.List < System.String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Version.html",
    "title": "Field Version",
    "keywords": "Field Version Die Version des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Version Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ProductName.html",
    "title": "Field ProductName",
    "keywords": "Field ProductName Der an der Package-Version definierte Product Name. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string ProductName Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Manufacturer.html",
    "title": "Field Manufacturer",
    "keywords": "Field Manufacturer Der im Package definierte Hersteller. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Manufacturer Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.PublicKey.html",
    "title": "Field PublicKey",
    "keywords": "Field PublicKey Der öffenliche Schlüssel des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly RSAKeyPair PublicKey Returns Type Description FrameworkSystems.FrameworkBase.License.RSAKeyPair"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.LastCompileDate.html",
    "title": "Field LastCompileDate",
    "keywords": "Field LastCompileDate Zeitpunkt des letzten Compiles. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly DateTime LastCompileDate Returns Type Description System.DateTime"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.WasLastCompileBugFix.html",
    "title": "Field WasLastCompileBugFix",
    "keywords": "Field WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly bool WasLastCompileBugFix Returns Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.html",
    "title": "Class AUHelper.PackageInfo",
    "keywords": "Class AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden. Inheritance System.Object AUHelper.PackageInfo Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class PackageInfo Remarks Warning Die Klasse darf nicht im eigenen Code instanziiert werden. Fields AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. ID Die eindeutige ID des Packages. LastCompileDate Zeitpunkt des letzten Compiles. Manufacturer Der im Package definierte Hersteller. Name Der Name des Packages. ProductName Der an der Package-Version definierte Product Name. PublicKey Der öffenliche Schlüssel des Packages. Version Die Version des Packages. WasLastCompileBugFix Gibt an, ob der letzte Compile im Service-Release-Modus stattgefunden hat."
  },
  "doc/mdt/vererbung.html": {
    "href": "doc/mdt/vererbung.html",
    "title": "Vererbung von Metadatentypen",
    "keywords": "Vererbung von Metadatentypen Es ist möglich, Metadatentypen zu vererben. Das macht dann Sinn, wenn Metadatentypen aufeinander aufbauen und z.B. ein gemeinsames Format-Pattern verwenden. Sie können so in einem Basis-Metadatentyp mit allen Datentypen Controls und einem Default-Label definieren. Anschließend brauchen Sie diesen nur abzuleiten und die Ableitung hat die gleichen Eigenschaften wie die Basis. Dann können Sie noch z.B. das Label oder den Wertebereich ändern. In der Ableitung werden die nachträglich geänderten Werte fettgedruckt dargestellt. Eine Ableitung können Sie auf zwei Wegen erstellen: Einen Metadatentypen ableiten, indem Sie den Metadatentyp im Overview auswählen, den Button ( Derive ) drücken und in der Namespace-Auswahl angeben, in welchem Namespace die Ableitung angelegt werden soll. Einem vorhandenen Metadatentypen im Feld Base eine Basis (oder auch eine andere Basis) zuweisen. Warning Wird beim Ändern der Basis auch der Datentyp geändert, kann das evtl. Auswirkungen auf die Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren."
  },
  "index.html": {
    "href": "index.html",
    "title": "Framework Studio 4.2",
    "keywords": "Framework Studio 4.2 Andere Versionen können hier aufgerufen werden. Note Diese Dokumentation befindet sich noch im Aufbau. Diese Seite gliedert sich in folgende Teile, die über die Navigation im oberen Bereich aufgerufen werden können: 1.) Framework Studio 4.2 Hier finden sie Neuheiten, Release-Listen, aktuelle Informationen und Systemvorrausetzungen 2.) Technische Dokumentation Alle Dokumentationen und Anleitungen für die Framework Studio IDE, Programmier-Themen und andere Programme. 3.) Api-Dokumentation Umfasst eine generierte Dokumentation der von Framework Studio bereitgestellten Klassen und Schnittstellen."
  },
  "doc/allgemein/options.html": {
    "href": "doc/allgemein/options.html",
    "title": "Options",
    "keywords": "Options Die Options können in der IDE über den Menüeintrag Tools / Options geöffnet werden. IDE (Registerkarte) Login Get DLLs Mit der Checkbox Enable option 'Include Debug DLLs' by default wird im Login dafür gesorgt, dass beim Get DLLs die vom Framework Compiler erzeugten Debug-Informationen gezogen werden. Das beinhaltet (soweit vorhanden) die Debug-Informationen der Basis-Packages. Appearance Error Display Wird die Checkbox Legacy Error Window gesetzt, kann erzwungen werden, dass die Errors in derselben Art und Weise ausgegeben werden, wie es bis Framework Studio 2.6 der Fall war. Background Image Wird die Checkbox Disable gesetzt, wird in der Framework Studio Umgebung kein Hintergrundbild mehr angezeigt. Dies kann zu einer Performancesteigerung bei Remote Sessions beitragen (z.B. VNC). Documentation Indicators Zeigt an den Controls im Form-Designer an, ob eine Dokumentation gepflegt ist, bzw vererbt wurde. Form Control DoubleClick Gibt an, was im Form-Designer passieren soll, wenn auf ein Control Strg + Doppelklick ausgeführt wird. RadioButton Show Control Events : Zeigt den Events-Dialog für das Control an. Diese Option ist sinnvoll für normale Entwickler. Der Documentation-Editor kann über das Context-Menü des Controls geöffnet werden. RadionButton Show Documentation : Zeigt den Documentation-Editor für das Control an. Diese Option ist sinnvoll für Benutzer, die viel an Dokumentationen arbeiten. Die Control-Events können über das Context-Menü des Controls geöffnet werden. Show form designer grid Gibt an, ob im Form-Designer das Raster-Grid angezeigt werden soll. Bei der Arbeit über Remote Desktop kann dieses Grid die Performance sehr stark verschlechtern. Languages in designer Hier können die Sprachen eingestellt werden, die in den MLStrings und im Wörterbuch angeboten werden sollen. Die Reihenfolge wird - sofern dies möglich ist - von den Designer-Fenstern berücksichtigt. Es werden kommasepariert die Iso-Codes der Sprachen angegeben - z.B. de,en,fr . Wird keine Angabe gemacht, werden in allen Designer-Fenstern immer alle verfügbaren Sprachen angeboten. Code Editor Font Family Hier können Schriftart und -größe für den Code-Editor angepasst werden. Go to Definition with Ctrl+DoubleClick Schaltet im Code-Editor die Funktion Go to Definition (F12) mit Strg + Doppelklick ein. Es kann sinnvoll sein, diese Funktion zu deaktivieren, wenn man diese Funktion öfters aus Versehen auslöst. Dann bleibt immer noch die F12-Taste oder das Context-Menü zum Aufruf dieser Funktion. Context Tooltip Gibt an, ob im Code-Editor Informationen zu Elementen angezeigt werden sollen, wenn mit der Maus auf Code-Teile gezeigt wird. Compile / Debug (Registerkarte) Broker Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Host Port Standard Broker Port. Wird 0 eingetragen, wird automatisch ein freier Port genutzt. Compile Rootdirectory Gibt an, unter welchem Ordner Framework Studio die Compile-Verzeichnisse erzeugen soll. Diese Einstellung muss manuell in der Datei FrameworkStudio.exe.config angepasst werden. Beispiel: <configuration> <appSettings> <add key=\"CompileBaseDirectory\" value=\"C:\\FS\\Compile42\" /> [...] Visual Studio Path Hier kann angegeben werden, wo Visual Studio installiert ist. Die aktuell von Framework Studio unterstützten Versionen von Visual Studio werden automatisch erkannt. Wenn eine andere Version oder Edition (z.B. Visual Studio Express) verwendet werden soll, kann das entsprechende Programm angegeben werden. Mit dem Button Reset wird der Wert auf die Original-Einstellung zurückgesetzt. Diese Einstellung wird für das Menu View / Compiled Code in Visual Studio in den Designer-Fenstern verwendet. Außerdem wird der Ordner aus dieser Einstellung verwendet, um für die Arbeit mit Services das Programm WcfTestClient.exe zu finden. Visual Studio Arguments Hier können die Kommandozeilen-Argumente für das Öffnen der Quellcode-Dateien angegeben werden. Beim Einsatz von Visual Studio können die Standard-Einstellungen %file% /Edit beibehalten werden. Der Platzhalter %file% steht für die zu öffnenden Dateien. Dieser werden in dem Format \"Datei1.cs\" \"Datei2.cs\"… übergeben. Wenn dieser Platzhalter nicht angegeben ist, dann werden die Dateien an der Parameter gestellt. Utilities (Registerkarte) Mit dem Button [...] kann jeweils ein Dateiauswahldialog geöffnet werden. SvcUtil Gibt den Pfad zur SvcUtil.exe des Windows SDK an. Diese wird für die Generierung des Services verwendet. InstallUtil Gibt den Pfad zur InstallUtil.exe des .NET-Frameworks an. Crystal Report Designer Gibt den Pfad zum Crystal Report Designer an. Diff Tool Hier kann die ausführbare Datei für das Diff Tool angegeben werden. Diff Tool Data Dir Hier kann das Datenverzeichnis für das Diff Tool angegeben werden."
  },
  "articles/requirements.html": {
    "href": "articles/requirements.html",
    "title": "Systemvoraussetzungen",
    "keywords": "Systemvoraussetzungen Entwicklungs-Rechner Ein Rechner auf dem mit der Framework Studio IDE entwickelt wird bzw. ein Rechner oder Server auf dem der Framework-Compiler ausgeführt wird. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows 10 - mind. Version 18.03 Windows 8.1 Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 .NET Framework .NET Framework 4.8 - oder höher https://dotnet.microsoft.com/download/dotnet-framework/net48 Weitere Software Java-Runtime Crystal Reports Runtime Crystal Reports Designer Visual Studio: empfohlen zum Debuggen von Anwendungen Visual Studio 2012 Visual Studio 2010 Andere Versionen und Editionen können auf eigene Verantwortung in den IDE-Options konfiguriert werden. Anwendungs-Server Rechner, auf dem Broker oder mit Framework Studio veröffentlichte Services laufen. Betriebssystem Es werden ausschließlich 64-Bit Systeme unterstützt. Windows Server 2019 Windows Server Version 1809, 1803 Windows Server 2016 Windows Server 2012 R2 Client-Betriebssysteme: Ein Broker oder Service kann prinzipiell auf einem Client-Betriebssystem (Windows 8.1, Windows 10) installiert werden. In einer Produktiv-Umgebung wird aber dringend der Einsatz eines o.g. Server-Betriebssystems empfohlen. Auf Client-Betriebssystemen können nur sehr wenige Benutzer parallel arbeiten. .NET Framework .NET Framework 4.8 - oder höher Weitere Software Crystal Reports Runtime IIS Print-Server Der Print-Service benötigt eine Verbindung zur Runtime-Repository-Datenbank und er muss die gewünschten Drucker ansprechen können. Er wird nicht von der Anwendung direkt kontaktiert, deshalb kann auch ein Client-Betriebssystem verwendet werden. Print-Service Die hier aufgeführten Systemvorrausetzungen gelten für den Print-Service Version 4.2. Framework Studio ist kompatibel mit älteren Versionen des Print-Service. Kommen diese zum Einsatz, gelten die Systemvorrausetzungen für die jeweilige Version. Framework Studio Print-Service 3.11 Framework Studio Print-Service 3.10.3 Framework Studio Print-Service 3.9.10 Framework Studio Print-Service 3.8.14 Betriebssystem siehe Entwicklungs-Rechner Es wird der Einsatz eines 64-Bit Betriebssystems empfohlen. Wenn z.B. ein spezieller Drucker-Treiber nur unter 32-Bit funktioniert, kann der Print-Service auch unter 32-Bit eingesetzt werden. Weitere Software Crystal Reports Runtime .NET Framework 4.8 - oder höher Authentication-Server Authentication-Service Framework Studio Authentication-Service 3.9 Framework Studio Authentication-Service 3.9.1 (unterstützt Runtime Supervisor) Framework Studio Authentication-Service 3.8 oder 3.8.5 Betriebssystem siehe Anwendungs-Server Weitere Software .NET Framework 4.5 / 4.5.1 / 4.5.2 / 4.6 Oracle-Client Client-Rechner Rechner, auf dem die Anwendung mit dem Java-Client ausgeführt wird. Betriebssystem An das Betriebssystem werden grundsätzlich keine besonderen Anforderungen gestellt. Entscheidend ist, dass die Java-Runtime verfügbar ist. Ja nach Framework-Studio-Anwendung kann es ggf. weitere Einschränkungen geben. Windows 10 Windows 8.1 Windows 8 Windows 7 SP1 Windows Vista SP2 Windows Server 2012 Windows Server 2008 Ubuntu Linux Mac OS X 10.9 Weitere Software Java-Runtime Crystal Reports Designer - sofern Reports bearbeitet werden sollen Je nach Framework-Studio-Anwendung ggf. weitere Software Java-Runtime Die Java Laufzeit-Umgebung wird benötigt am Client-Rechner und auf dem Entwicklungs-Rechner zur Ausführung der Anwendung. Java 8 Crystal Reports Runtime Diese Runtime wird benötigt auf dem Anwendungs-Server, dem Print-Service und dem Entwicklungs-Rechner. SAP Crystal Reports Runtime engine for .NET Framework 13.0.9 oder höher. Bei 64Bit-Betriebssystemen muss die 64Bit-Version der Runtime verwendet werden. Crystal Reports Designer Der Crystal Reports Designer wird für die Bearbeitung der Crystal Reports auf dem Entwicklungs-Rechner benötigt und sofern erforderlich auch auf dem Client-Rechner. Crystal Reports 2008 Datenbank-Server Microsoft SQL Server 2014 - oder höher (Standard / Enterprise / BI) Microsoft SQL Server 2012 SP1 (Standard / Enterprise / BI) Die Express- und Developer-Editionen des SQL Server können zu Entwicklungs- und Test-Zwecken eingesetzt werden. Dabei sind aber entsprechende funktionale und lizenzrechtliche Einschränkungen seitens Microsoft zu beachten. Der Einsatz erfolgt auf eigene Verantwortung. Oracle 12.2 - oder höher (Standard / Enterprise) Oracle-Client Es ist kein Oracle Client erforderlich. Der Oracle Managed Provider bringt seine eigene Client-DLL mit. Important der Oracle ODP Provider ist veraltet (deprecated). Ein produktiver Einsatz wird nicht mehr supported. In einer zukünftigen Version wird er komplett entfernt. Für die Verwendung des Oracle ODP Providers muss ein Oracle-Client installiert werden: Oracle Client 12.1.0.1+ mit Oracle Data Provider for .NET 4 Oracle Client 11.2.0.3+ mit Oracle Data Provider for .NET 4"
  },
  "articles/neuheiten-4-2.html": {
    "href": "articles/neuheiten-4-2.html",
    "title": "Neuheiten Framework Studio 4.2",
    "keywords": "Neuheiten Framework Studio 4.2 Informationen zu aktuellen Versionen und korrigierten Fehlern finden Sie in den Release-Informationen . Neue Systemvorraussetzungen In dieser Version gibt es einige Anpassungen bei den Systemvoraussetzungen . Im folgenden sind die wichtigsten Änderungen aufgeführt. 64 Bit Die folgenden Programme können nur noch auf 64-Bit Systemen installiert werden. Eine 32-Bit Installations-Routine wird nicht mehr angeboten: Framework Studio IDE / Package Manager Publish / Publish2Go Anwendungs-Broker Framework Studio Services 32-Bit wird weiterhin unterstützt für: Client-Rechner Print-Server .NET Framework 4.8 Framework Studio setzt auf das .NET Framework 4.8 auf. Dieses wird beim Ausführen der Installations-Routine (nach Rückfrage) automatisch installiert. Es ist nicht mehr im Requirements-Packet enthalten. Für eine manuelle Installation finden Sie das .NET Framework 4.8 direkt bei Microsoft unter https://dotnet.microsoft.com/download/dotnet-framework/net48 . Betriebssysteme Mit dem Umstieg auf das .NET Framework 4.8 können einige ältere Windows Betriebssysteme nicht mehr unterstütz werden. Es werden aktuell folgende Betriebssysteme unterstützt: Server Windows Server 2012 R2 - oder höher Client / Entwicklungs-Rechner Windows 10 (Version 18.03 - oder höher) Windows 8.1 Für die Endanwender-Rechner bzw. Terminal-Server gelten weiter die bisherigen Anforderungen. SQL-Server Es wird der SQL-Server 2012 oder höher unterstützt. Ältere Version (z.B. SQL-Server 2008) werden nicht mehr supported Oracle Server Es wird der Oracle Server 12.2 oder höher (18c, 19c, ...) unterstützt. Ältere Versionen werden nicht mehr supported. Oracle Client Es wird nur noch der Oracle Managed Provider unterstützt. Der Oracle ODP Provider ist veraltet (deprecated) und wird nicht mehr supported. C# 7 Mit dem Update auf das .net Framework 4.8 unterstützt Framework Studio auch die C# Sprach-Features bis zur Version 7.3. Eine Übersicht der Features bietet die Web-Seite: https://docs.microsoft.com/de-de/dotnet/csharp/whats-new/csharp-7 In der folgenden Liste werden einige Features genannt, die seit C# 6 hinzugekommen sind. Der Einsatz dieses Features ist in Framework-Studio empfehlenswert: out variables - inline-Deklaration (C# 7.0) Folgende Features können ggf. sinnvoll sein: Tuples (C# 7.0) Inferred tuple element names (C# 7.1) Tuples support == and != (C# 7.3) Pattern matching (C# 7.0) Local functions - aber nur sehr gut überlegt!! (C# 7.0) MLKey Wörterbuch Eine zentrale Neuerung in der Version 4.2 betrifft das Handling der fremdsprachigen Texte. Diese werden jetzt in einem zentralen Wörterbuch verwaltet. Bisher wurden alle Texte am jeweiligen Element (z.B. Metadatentyp, ComponentProperty, FormControl) gepflegt. Jetzt werden an allen diesen Stellen Schlüssel (MLKeys) angegeben, die auf das zentrale Wörterbuch verweisen. Dadurch hat man erst einmal etwas mehr organisatorischen Aufwand, aber auf längerer Sicht betrachtet bringt diese Vorgensweise viele Vorteile: Redundanzen werden vermieden, weil existierende Texte wiederverwendet werden können und sollen. Dadurch erhält man zudem in der kompletten Anwendung durchgängige und einheitliche Bezeichnungen. Die fremdsprachigen Übersetzungen können sehr einfach und zentral gepflegt werden. Besonders im Customizing-Package ist das von großem Vorteil, weil jetzt nicht mehr die einzelnen Elemente ausgecheckt werden müssen. Das Wörterbuch kann auch im Service-Release bearbeitet werden. Der Export und Import von Texten ist sehr einfach. Es wird das standardisierte TMX-Format verwendet. Texte können so zwischen verschiedenen Packages und Versionen ausgetauscht werden. Auch eine Übersetzung durch Werkzeuge oder externe Dienstleister ist dadurch deutlich einfacher als bisher. Eine detailliert Beschreibung der Funktionalität finden sie im Kapitel MLKey . Es ist sinnvoll, die Texte des eigenen Packages in das Wörterbuch zu überführen. Bitte beachten sie dazu die Hinweise und Anleitungen für die Migration . Code-Messages überarbeitet Die vom Exception- und MessageBox-Wizard generierten Code-Messages wurden überarbeitet. Das bisherige Konstrukt mit #region wurde durch eine Variante mit einem einfachen eingefärbten Kommentar // FSCodeMessage: ersetzt. Das macht den Quellcode kompakter und leserlicher – ohne extra aufklappen zu müssen. Der XML-Teil, welcher bisher die Informationen für die Wizard-Dialoge beinhaltet hat, entfällt. In der Vergangenheit konnte es sein, dass die XML-Informationen vom Code abwichen. Der Wizard hat dann den Code ignoriert und einfach ersetzt. Dadurch konnten wichtige Infos – wie z.B. ein MessageBox EventHandler – verloren gehen. Die Informationen werden jetzt aus dem Code geparsed. Kann (z.B. aufgrund von manuellen Anpassungen) der Code nicht geparsed werden, kann er nicht mehr durch den Wizard bearbeitet werden. Die Code-Messages können einen MLKey aus dem Wörterbuch verwenden. Die bisherige Variante mit TextCollection-Einträgen soll nach und nach durch die MLKeys ersetzt werden und so die ctMessage-TextCollections auslaufen. Bei MsgBox.Show() sind die Enum-Werte für Button und Icon leserlich ausgeschrieben. Bisher wurden dort nur die int-Werte verwendet. Die Konvertierung des bestehenden Codes in das neue Format erfolgt auf folgende Weise: Durch die MLKey-Konvertierungs-Routine – diese setzt alle Code-Messages automatisch auf einen MLKey und/oder das neue Format um. Durch manuellen Aufruf des Exception- oder MsgBox-Wizards. Beim Speichern wird der Code durch die neue Variante ersetzt. Bei beiden Konvertierungen wird nur der Code betrachtet - der alte XML-Teil wird ignoriert. Neue Messages werden immer im neuen Format generiert. Dabei ist es egal, ob ein Textcollection-Eintrag oder ein MLKey verwendet wird. Actions SetEnabled und SetVisible nullable Die Control-Actions SetEnabled und SetVisible haben neue Überladungen bekommen, welche das Zurücksetzen auf den im Property-Grid des Form-Designers eingestellten Wert ermöglichen. Dazu wurden folgende Überladungen ergänzt, bei denen der null -Wert zum Zurücksetzten verwendet werden kann: SetEnabled(bool? value) SetEnabled(FSbool value) SetVisible(FSVisibility? value) Caution Achtung, falls Reflection verwendet wurde! Sollte eine der ursprünglichen Methoden aus irgend einem Grund per Reflection angesprochen worden sein, so kann es nun zu dem Problem kommen, dass nicht mehr eine eindeutige, sondern mehrere Überladungen der Methode gefunden werden. Die Überladungen SetEnabled(bool value) und SetVisible(FSVisibility value) wurden entfernt, da Aufrufe vom Compiler direkt auf die entsprechenden Nullable-Überladungen umgelenkt werden."
  },
  "doc/mdt/metadatentypen.html": {
    "href": "doc/mdt/metadatentypen.html",
    "title": "Metadatentypen",
    "keywords": "Metadatentypen Die Idee der Metadatentypen kommt daher, dass bestimmte Felder innerhalb einer Anwendung immer wieder auftauchen (z.B. Artikelnummer, Kundennummer, ...). Deshalb können solche Felder an einer zentralen Stelle definiert werden, was Fehler in der Felddefinition verhindert und Redundanzen minimiert. Dabei werden Informationen wie das Label, das Datenformat, das zugehörige Control, die mehrsprachige Bezeichnung usw. hinterlegt, so dass sich der Arbeitsaufwand bei der späteren Arbeit mit dem Metadatentypen minimiert. Sie erkennen Metadatentypen an einem - Icon vor der Bezeichnung. Metadatentypen bearbeiten Um einen Metadatatypen zu bearbeiten, doppelklicken Sie den entsprechenden Eintrag auf der Registerkarte Namespaces . Der Metadatentyp wird im Hauptfenster des Framework Designers angezeigt. Der Metadatentyp kann in verschiedenen Teilen der Anwendung zum Einsatz kommen: Er kann auf unterster Ebene der Spalte einer DBTable zugeordnet werden. Er kann in Components oder Forms als Datentyp für Properties verwendet werden. Deshalb nehmen Sie an einem Metadatentyp verschiedene Einstellungen vor: Name : Geben Sie die Bezeichnung des Metadatentyps an. Datatype Database : Benennen Sie den Datentyp der Spalte in der Datenbank. Datatype Application : Gibt den FS-Datentyp des Metadatentyps an. Dieser Datentyp wird später in den Components und Forms gezogen. Die folgende Tabelle zeigt, welche Database-Datentypen mit welchem Application-Datatype kombiniert werden können: FSbool FSbyte FSbyteArray FSDateTime FSdecimal FSdouble FSfloat FSint FSlong FSshort FSstring Binary X Boolean X Byte X Date X DateTime X Time X Double X Currency X X X Single X X X Decimal X X Big Int X Integer X X Smallint X X X Tiny Int X X X Ansi String X Long Varchar X String X null X X X X X X X X X X X Warning Wenn Sie die Datentypen nachträglich ändern, kann das evtl. Auswirkungen auf Programmteile haben, die diesen Metadatentypen bereits verwenden. Unter Umständen lassen sich diese Programmteile nicht mehr kompilieren. Die Einstellungen für Size, Precision und Scale hängen von der Auswahl des Datatype Database ab. Je nachdem, ob der Datenbank-Datentyp Zeichen, Ganzzahlen oder Gleitkommazahlen unterstützt, sind die Felder für Eingaben zugänglich. Size : Definiert die Feldlänge bei Zeichenfeldern. Precision : Anzahl der Stellen inkl. eventueller Nachkommastellen bei numerischen Feldern. Scale : Anzahl der Nachkommastellen bei Dezimal -Feldern. Format : Gibt das Anzeige-Format des Felds an. Das Format wirkt sich in der Darstellung des Felds auf einem Form aus. Format Pattern : Wird im Feld Format User Defined gewählt, ist es möglich hier selbst ein Format anzugeben. Es können Formate für Zahlen, Daten und Zeichenketten entsprechend der Standard-Definition für reguläre Ausdrücke eingegeben werden. Siehe auch Format-Pattern Registerkarte Description Hier kann eine Beschreibung des Metadatentyps eingegeben werden. Registerkarte Values Für einen Metadatentypen kann definiert werden, welche Werte er annehmen darf. Wird hier nichts angegeben, sind alle Werte möglich, die der entsprechend hinterlegte Datentyp zulässt. Es können mehrere Werte oder Wertebereiche angegeben werden. From : Gibt die untere Grenze eines Wertebereichs an. Warning Ist nur dieses Feld gefüllt (und To nicht), wird dies als Wert und nicht als Wertebereich angesehen. To : Gibt die obere Grenze eines Wertebereichs an. Button Add New Range : Mit dem Button Add New Range kann ein neuer Bereich hinzugefügt werden. Button Remove Range : Mit dem Button Remove Range kann ein Bereich gelöscht werden. Registerkarte Default Label Einem Metadatentypen kann ein Label zugewiesen werden. Dieses Label wird im Form links neben dem Control des Metadatentyps angezeigt. Das Label kann mehrsprachig hinterlegt werden. Tip Es ist möglich, dieses Label in den Components und im Form zu überschreiben. Registerkarte Control Types Die Registerkarte ControlTypes zeigt an, welche Controls später im Form zur Verfügung stehen sollen. Es ist möglich, einem Metadatentypen mehrere Controls zuzuordnen. Es kann aber maximal ein Control als Default gekennzeichnet sein. Das als Default gekennzeichnete Control wird zunächst angezeigt, wenn ein Property (welches diesen Metadatentypen verwendet) in ein Form gezogen wird. Das Default-Control kann dann auf weitere, hier hinterlegte Controls geändert werden. Diese Liste von Controls kann auch im DBTable oder in der einer Component ergänzt werden. Ist kein Control als Standard-Control hinterlegt, wird ein Editfeld angenommen. Mit dem Button Add wird ein neuer Control-Type hinzugefügt. Es öffnet sich das Fenster Assign Controls. In diesem Fenster sind alle Controls aufgelistet, einschließlich der Controls, die Sie in den Control Default Styles definieren können (siehe Kapitel Control Default Styles). Wählen Sie hier ein Control aus und setzen Sie ggf. die Checkbox is Default . Mit dem Button OK wird das Control der Liste hinzugefügt. Mit dem Button Change können Sie das Control ändern. Es öffnet sich wieder wie bei Add das Fenster Assign Controls . Sie können hier ein anderes Control auswählen und dann mit OK bestätigen. Mit dem Button Delete wird das markierte Control gelöscht."
  },
  "doc/html-client/geraete-funktionen.html": {
    "href": "doc/html-client/geraete-funktionen.html",
    "title": "Gerätespezifische Funktionen",
    "keywords": "Gerätespezifische Funktionen Nachfolgend werden diejenigen Funktionen erläutert, die nur auf spezifischen Geräten verfügbar sind. Es ist nicht oder nur eingeschränkt möglich, vom Browser aus auf native Funktionen wie z.B. das Dateisystem zuzugreifen. Dadurch hat der HTML Client auf mobilen Geräten mehr Möglichkeiten als im Browser. Barcode Scanner (nur mobile Geräte) Über die in einem mobilen Gerät integrierte Kamera können im HTML Client Barcodes unterschiedlicher Formate eingescannt werden. Unterstützte Formate Name Beispiel AZTEC CODABAR CODE_39 CODE_93 CODE_128 DATA_MATRIX EAN_8 EAN_13 ITF PDF_417 QR_CODE UPC_A UPC_E Action ScanBarcode() In Framework Studio wird ein Scan über folgende Action am Form gestartet: ScanBarcode( Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat ) oder ScanBarcode( Action<IFrameworkBarcodeScanInfo> callback, BarcodeFormat allowedFormat, string identifier ) Beispiel: protected virtual void FE_btnScan_OnClick(FrameworkButtonClickEventArgs e) { this.ScanBarcode( this.ScanBarcodeCallback, BarcodeFormat.CODE_128 | BarcodeFormat.ITF, \"Article\" ); } Parameter Action callback Wenn der Scanvorgang am Client abgeschlossen ist, wird der übergebene Callback aufgerufen. Der Callback ist vom Typ Action<IFrameworkBarcodeScanInfo> IFrameworkBarcodeScanInfo Properties Property Typ Beschreibung Cancelled bool true wenn der Scanvorgang am Client abgebrochen wurde ErrorMessage string Fehlermeldung bei einem gescheiterten Scanvorgang Format BarcodeFormat Das Format des gescannten Barcodes HasError bool true wenn beim Scanvorgang ein Fehler aufgetreten ist Identifier string Der in ScanBarcode() übergebene Wert, sonst null Value string Der Wert des gescannten Barcodes Beispiel: public virtual void ScanBarcodeCallback(IFrameworkBarcodeScanInfo e) { this.Reset(); this.sIdentifier = e.Identifier; if (e.HasError) { this.sValue = e.ErrorMessage; } else if (e.Cancelled) { this.sValue = \"Cancelled\"; } else { this.sValue = e.Value; this.sFormat = e.Format.ToString(); } } Parameter BarcodeFormat allowedFormat Definiert, welches Barcode-Format am Client bei einem Scanvorgang unterstützt wird. Note Es wird dringend empfohlen, nur diejenigen Barcode-Formate zu übergeben, die auch tatsächlich beim Scanvorgang unterstützt werden sollen, um Fehler beim Scannen zu vermeiden. Je geringer die Anzahl der unterstützten Formate ist, desto unwahrscheinlicher ist es, dass der Scan fehlschlägt. Beispiel: Wenn am Client z.B. CODE_128 und ITF unterstützt werden soll, so können diese per bitweiser Oder-Verknüpfung übergeben werden. protected virtual void FE_btnScan_OnClick(FrameworkButtonClickEventArgs e) { this.ScanBarcode( this.ScanBarcodeCallback, BarcodeFormat.CODE_128 | BarcodeFormat.ITF, \"Article\" ); } Parameter string identifier Es kann vorkommen, dass auf einem Form mehrere Buttons einen Scan initiieren können. Beispielsweise könnte erst ein Auftrag und nachfolgend eine Menge eingescannt werden. Es ist aber oft nicht praktikabel, für jeden Scanvorgang einen separaten Callback zu implementieren. Anstatt dessen kann der ScanBarcode() -Action einfach ein beliebiger string mitgegeben werden, über den der Scanvorgang im Callback identifiziert werden kann. Beispiel: public virtual void ScanBarcodeCallback(IFrameworkBarcodeScanInfo e) { this.Reset(); this.sIdentifier = e.Identifier; if (e.HasError) { this.sValue = e.ErrorMessage; } else if (e.Cancelled) { this.sValue = \"Cancelled\"; } else { if (e.Identifier == \"Article\") { this.sArticle = e.Value; } else { this.sAmount = e.Value; } this.sFormat = e.Format.ToString(); } } Berechtigung für Kamera Der Barcode Scanner benötigt auf dem mobilen Gerät Zugriff auf die Kamera. Diese muss z.B. auf einem Android-Gerät einmalig erteilt werden:"
  },
  "doc/mlkey/mlkey-cleanup.html": {
    "href": "doc/mlkey/mlkey-cleanup.html",
    "title": "MLKeys Cleanup",
    "keywords": "MLKeys Cleanup MLKeys-Cleanup ist eine Wartungs-Routine, die bereinigungen im Wörterbuch durchführt. Sie kann über das Menu Tools / Checks / MLKeys Cleanup aufgerufen werden."
  },
  "doc/mlkey/migration.html": {
    "href": "doc/mlkey/migration.html",
    "title": "MLKey Migration",
    "keywords": "MLKey Migration Ziel ist es, dass alle Texte aus den Records entfernt und in das Wörterbuch übertragen werden. Die Records erhalten dafür Verweise auf Einträge im Wörterbuch, die MLKeys . Generell teilt sich die Migration in zwei große Phasen auf: MLKeys erzeugen und zuordnen : Diese Phase kann parallel zur Weiterentwicklung durchgeführt werden. Es werden zum Einen neue Einträge im Wörterbuch angelegt und zum Anderen vorgemerkt, wo diese später verwendet werden sollen. MLKeys übertragen : In dieser Phase werden primär die vorbereiteten Zuordnungen an die Elemente übertragen: angegebene Texte werden entfernt und statt dessen die gewünschten MLKeys eingetragen. Dazu müssen alle betroffenen Elemente ausgecheckt werden. Zusätzlich werden weitere Umstellungen (z.B. bestehende Messages und Exceptions) durchgeführt. Abwärts-Kompatibilität Texte, die bisher an den Records definiert sind, funktionieren auch weiterhin, weil jeder MLString neben dem MLKey explizit gesetzte Texte versteht. So kann man nach dem Update auf die Version 4.2 die Migration in aller Ruhe angehen. Note In Kunden-Packages ist die Umstellung der eigenen Texte auf MLKeys empfohlen. Sie ist aber nicht zwingend notwendig. Das hat aber langfristig einige Nachteile zur Folge - insbesondere in Hinblick auf die Mehrsprachigkeit der Anwendung: Der Language Export / Import funktioniert nur für das Wörterbuch. Individuelle Texte an Records werden nicht (mehr) berücksichtigt. Das Pflegen von Fremdsprachen an den Records ist sehr aufwändig. Die MLKeys aus dem Wörterbuch bringen hingegen die Übersetzungen automatisch in alle Bereiche der Anwendung. Important Funktionale Packages, die als Produkt an mehrere Kunden vertrieben werden, sollten in jedem Fall migriert werden. MLKeys erzeugen und zuordnen Diese erste Phase der MLKey Migration dient zum Einen der Erzeugung der benötigten Einträge im Wörterbuch (MLKeys) und zum Anderen der Zuordnung, wo diese später verwendet werden sollen. Zentrales Werkzeug für diese Phase ist der Dialog Multilanguage Text Migration , welcher über das Menü Tools / Multilanguage Text Migration geöffnet werden kann. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Alle durch den Benutzer definierten Zuordnungen werden in der Ressource Migration.xml im Verzeichnis FSGeneral/Resources/lang gespeichert, welche automatisch bei der ersten Benutzung angelegt wird. Ist diese Datei bei der Bearbeitung mit dem Multilanguage Text Migration Dialog nicht ausgecheckt, so wird beim Speichern mit dem Button Save automatisch die neueste Version ausgecheckt, die Änderungen ergänzt und anschließend sofort wieder eingecheckt. Dieses Verhalten ist dann hilfreich, wenn mehrere Benutzer gleichzeitig mit dem Multilanguage Text Migration Dialog arbeiten. Andernfalls empfiehlt es sich, die Datei vor Beginn der Arbeit auszuchecken und erst nach Beendigung der Arbeit wieder einzuchecken. So werden unnötige Checkin- und Checkout-Vorgänge vermieden. Beim Speichern werden außerdem ggf. ungespeicherte Änderungen am Wörterbuch gespeichert. Generelles Vorgehen Die zu leistende Arbeit besteht in erster Linie darin, logisch identische Begriffe zusammenzuführen und logisch unterschiedliche Begriffe, die ggf. in einzelnen Sprachen Überlappungen mit anderen Begriffen haben, zu trennen. Beispiel: Die Begriffe Suche mit SQL , Suchen mit SQL , SQL Suche , SQL-Suche , Suchen SQL , Sql Suche und weitere Varianten sollten zu einem einzigen Eintrag zusammengefasst werden. (1) Load Data Important Zunächst sollten Tooltips außen vor gelassen werden. Dazu darf die Checkbox Include Tooltips NICHT gesetzt sein, wenn mit dem Button Load Data alle im Package angegebenen Texte eingelesen werden. Erst wenn allen Texten ein MLKey zugeordnet wurde, werden die im Folgenden beschriebenen Schritte nach dem erneuten Laden der Daten inklusive Tooltips ein zweites Mal durchgeführt. Note Wenn durch ein Basis-Package bereits Einträge im Wörterbuch existieren, so wird Framework Studio nach dem Laden automatisch einem mehrsprachigen Text aus dem Custom-Package den MLKey zuweisen, der mindestens in den angegebenen Sprachen die Texte in exakt der Schreibweise enthält. Die mit dem Button Load Data eingelesenen Texte werden in einer Tabelle angezeigt. Die einzelnen Spalten haben folgende Bedeutung: Record : Name des Elements, an dem der Text angegeben ist, z.B. frmArticle . Element : Name des Unterelements, an dem der Text angegeben ist, z.B. edtsName . Type : Typ des Unterelements, z.B. FormControl . Property : Eigenschaft, an der der Text angegeben ist, z.B. Caption . MLKey : Der MLKey, welcher zugeordnet werden soll, z.B. LBL_Name . {Sprachen...} , z.B. German , English usw.: Der Text, welcher in der jeweiligen Sprache angegeben ist, z.B. Name . Die Spalten können durch anklicken der Spaltenüberschrift sortiert werden. Meist wird man nach deutschem Text sortiert arbeiten. Ein Doppelklick in die Spalten Record oder Element öffnet das Designerfenster für das Element und springt soweit möglich zum Unterelement. In allen anderen Spalten wird beim Doppelklick der Text der Zelle als Filterkriterium in das Feld Search: gesetzt. Für die Filterfunktion mit dem Feld Search: gelten folgende Regeln: Groß-Kleinschreibung wird ignoriert Es wird in allen Spalten gesucht Es werden nur die Zeilen angezeigt, die ALLE der durch ein Leerzeichen getrennten Buchstabenfolgen enthalten In Anführungsstriche \" gekapselte Buchstabenfolgen müssen genau so in der Zeile enthalten sein, damit diese angezeigt wird Beispiel: Die Suche nach LBL_Quantity \" geliefert\" zeigt nur die Zeilen an, welche geliefert mit einem führenden Leerzeichen und LBL_Quantity in irgendeiner Spalte enthalten. (2) Auto Create MLKeys Nach dem Einlesen der Daten (zunächst ohne Tooltips, siehe Load Data ) sollten einmalig mit dem Button Auto Create MLKeys alle automatisch erzeugbaren MLKeys in das Wörterbuch eingefügt werden. Automatisch erzeugt werden MLKeys dann, wenn es zu gleichen Texten in einer Sprachen keine abweichenden Texte in anderen Sprachen gibt. Note Framework Studio weist danach automatisch den Zeilen einen MLKey zu, die nur Texte enthalten, welche zu einem MLKey aus dem Wörterbuch keinen Wiederspruch aufweisen. (3) Manuelle Zuweisungen Ist die Checkbox Show only missing keys gesetzt, so wird die Anzeige aller Texte in der Tabelle auf die Einträge reduziert, welchen bisher noch kein MLKey zugewiesen wurde - die noch zu bearbeitenden Einträge. Im unteren Bereich des Multilanguage Migration Dialogs werden im Bereich Details zum aktuell in der Tabelle selektierten Eintrag alle Eigenschaften angezeigt. Ist bereits ein MLKey zugewiesen, werden die Texte des MLKeys in der Tabellenspalte In MLKey angezeigt. In der oberen Tabelle können auch mehrere Zeilen gleichzeitig ausgewählt werden. So kann mehreren Zeilen gleichzeitig ein MLKey zugewiesen werden. Für die Zuweisung stehen mehrere Optionen zur Verfügung: Mit dem Button im Bereich Details kann ein bereits existierender MLKey ausgewählt werden, siehe Multilanguage Text Editor , insbesondere Suchen von MLKeys . Wurde bereits ein MLKey zugewiesen, so wird ein weiterer Button Set ... angeboten, mit dem der zuletzt zugewiesene MLKey den aktuell selektierten Zeilen zugewiesen werden kann. Mit dem Button im Bereich Details kann ein neuer MLKey (basierend auf den selektierten Zeilen) erzeugt werden. Wenn beim Erzeugen eines neuen MLKeys mehrere Zeilen ausgewählt wurden und diese in einzelnen Sprachen abweichende Texte enthalten, so wird pro Sprache bei Bedarf der folgende Dialog geöffnet: In diesem werden alle Varianten, sortiert nach Häufigkeit absteigend, aufgeführt. Durch Selektion und Bestätigung mit dem Button OK oder durch Doppelklick wird die Auswahl als Vorbelegung für den neuen MLKey verwendet (siehe Erfassen neuer MLKeys ). Important Bei der Zuweisung und Erzeugung von MLKeys sind die eNVenta Regeln für MLKeys zu beachten. Mit dem Button Rename MLKey ist es im Rahmen der Migration möglich, einen bestehenden MLKey umzubenennen. Alle manuellen Zuordnungen dieses MLKeys werden automatisch angepasst. (4) Bereinigungen Im Wörterbuch werden sich durch die vorangegangenen Schritte (z.B. durch die von Framework Studio automatisch generierten MLKeys) einige Unsauberkeiten eingeschlichen haben. Daher sind die folgenden Maßnahmen empfehlenswert: Maßnahmen im Wörterbuch: Sortierung nach MLKey: Folgen aufeinander logisch identische Begriffe? Suche Nach _1 , _2 , _3 usw: Sind diese Varianten nötig oder sollten anders benannt werden? Sortierung nach deutschem Text: Folgen aufeinander logisch identische Begriffe? In Custom-Packages sind dabei nur die MLKeys aus dem eigenen Package (zu erkennen an der Fettschreibung) und ihre Vorgänger und Nachfolger interessant. Außerdem können im Multilanguage Text Migration Dialog mit dem Button Find unused MLKeys alle MLKeys aus dem eigenen Package aufgelistet werden, welche im Wörterbuch existieren, jedoch nirgendwo zugeordnet sind. Diese gilt es, kritisch zu prüfen. (5) Abschluss Phase 1 Wurden die vorigen Schritte (zunächst ohne Tooltips, danach mit Tooltips) abgeschlossen, so kann nun mit Phase 2 ( MLKeys übertragen ) fortgefahren werden. MLKeys in Custom-Packages Im Customizing kann man grundsätzlich 2 verschiedene Arten von überschriebenen Texten unterscheiden: Texte, die eine ganz neue Bedeutung haben. Wenn z.B. ein relativ allgemeiner Metadatentyp in einem Component-Property verwendet wird, wird dort am Default-Label ein neuer Text formuliert. In diesen Fällen sollte auf jeden Fall ein entsprechender (ggf. neuer) MLKey zugeordnet werden. Ändern eines bestehenden Textes. Es wird z.B. ein Metadatentyp customized und das Default-Label geändert - aus dem Begriff \"Angebot\" wird z.B. \"Offerte\". Die Bedeutung bleibt aber dieselbe. In solchen Fällen gilt es zu prüfen, ob es evtl. ratsam ist, diese Änderung direkt im Wörterbuch vorzunehmen. So zieht diese für die gesamte Anwendung. Bei der Migration weist man dann diesen Einträgen den existierenden MLKey zu - auch wenn er identisch mit dem bereits zugeordneten MLKey aus dem Basis-Package sein sollte. In einem späteren Schritt der Migration wird eine redundante Zuordnung dann automatisch eliminiert. MLKeys übertragen Ist das Wörterbuch komplett vorbereitet (siehe MLKeys erzeugen und zuordnen ), ist es an der Zeit, die MLKeys in die Records zu übertragen. In diesem Schritt werden alle Aktionen ausgeführt, die einen Checkout der Records zur Folge haben. So wird die ggf. erhebliche Menge an Checkouts auf das nötigste reduziert. (1) Als FCUser anmelden Weil nach der Konvertierung sehr viel kompiliert werden muss, ist es empfehlenswert als FCUser zu arbeiten. So kann direkt nach dem Kompilieren der Complete Framework Compiler aufgerufen werden und es ist kein zusätzlicher FrameworkCompiler nötig. Mit dem Benutzer FrameworkCompiler anmelden - mit Refresh Workspace. Get DLLs ist nicht notwendig. Framework Studio direkt wieder beenden. Jetzt als FC-User anmelden - mit Refresh Workspace. Das übernimmt den Workspace vom Benutzer FrameworkCompiler. (2) Apply MLKeys Im Fenster Multilanguage Text Migration mit dem Button Load Data (inkl. den Tooltips) alle Daten einlesen. Es sollte jetzt keine offenen Zuordnungen mehr geben - wenn man die Checkbox Show only missing keys setzt, dürfen keine Einträge angezeigt werden. Mit dem Button Apply MLKeys wird die Routine gestartet. Es werden alle zugeordneten MLKeys an die entsprechenden Properties der Records übertragen. Dabei werden ALLE in den jeweiligen Sprachen gesetzten Texte aus den Records entfernt. Somit ziehen ab diesem Zeitpunkt die Texte nur noch aus dem Wörterbuch. (3) Convert Messages Mit dem Button Convert Messages im Fenster Multilangage Text Migration wird die Routine gestartet. Für diese Routine müssen keine Daten eingelesen werden - das gilt auch, wenn sie zu einem späteren Zeitpunkt erneut gestartet wird. Es werden alle Methoden-Codes analysiert und nach Exceptions- und MessageBox-Aufrufen gesucht. Diese werden in das neue Message-Format umgewandelt und die Verweise auf die Text-Collections werden durch den entsprechenden MLKey ersetzt. Warning Die Routine Apply MLKeys muss zuvor ausgeführt worden sein, damit die Message-TextCollections sauber zugeordnete MLKeys besitzen. Alter Exception-Code vor der Konvertierung: #region Required for Exception Editor support. Do not modify manually. //Component type is required. //Severity: 0 ; Buttons: OK; Icon:Error throw new FrameworkApplicationException (String.Format(FSGeneral.ctMessagesFactory.Get(this.Global,3550).Value[Global.SelectedLanguage],new object []{}),0 ); //<ExceptionEditor TextColl=\"Messages\" ID =\"832e0e50c2b748068ba38a2c4422aaab\" Severity=\"0\" EHID=\"\" ></ExceptionEditor> #endregion End of generated section Neuer Exception-Code nach der Konvertierung: // FSCodeMessage: Component type is required. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_445559f2ca44452e8d49ca9515b3a83e), 0); Es ist relativ wahrscheinlich, dass Warnings oder sogar Errors ausgegeben werden. Diese können erst einmal ignoriert werden. Es handelt sich dabei um inhaltliche Probleme und nicht um Compile-Errors. Die Convert Code Messages Routine kann zu einem späteren Zeitpunkt erneut ausgeführt und diese Probleme dann behoben werden. Important Damit sind die Message-Text-Collections jetzt obsolete. Sie dürfen aber nicht gelöscht oder geleert werden, weil sie ggf. noch von Customizing-Packages referenziert werden. (4) MLStrings Cleanup Nachdem alle MLKeys übertragen wurden, können jetzt noch einige Bereinigungen durchgeführt werden. Über das Menü Tools / Checks / MLStrings Cleanup kann das Cleanup-Fenster geöffnet werden. Dort stehen mehrere Routinen zur Auswahl. Diese sollten einer nach der anderen ausgeführt werden. Dabei ist es ratsam zuerst den Button Analyze zu benutzen. Erst nach der Sichtung der Infos und Warnings wird die Routine mit dem Button Cleanup ausgeführt. Clean MLKeys Wird in einem Record (z.B. DBColumn, Form-Control) der MLKey mit demselben Wert überschrieben, wie er in der Basis (z.B. Metadatentyp, Basis-Package) definiert ist, dann wird diese Überschreibung entfernt. Transfer translations Wurden trotz vererbtem MLKey Übersetzungen nur an Records gepflegt, dann wurden diese mit der Migration ggf. nicht in das Wörterbuch übertragen. Das wird mit dieser Routine nachgeholt. Wird an einem Record, der einen MLKey besitzt, eine Übersetzung gefunden und das Wörterbuch kennt diese noch nicht, wird diese in das Wörterbuch übertragen und der Text vom Record entfernt. Dabei gewinnt pro MLKey der erste Record. Wird ein weiterer Record mit gleichem MLKey aber einer anderen Übersetzung gefunden, dann wird dieser als Warning ausgegeben. Beim Cleanup verbleibt dieser Text am Record. Bei einem weiteren Lauf würde dieser Record mit der Routine Clean individual texts gefunden werden. Clean individual texts Die MLKey-Migration berücksichtigt nur Texte, die mindestens in Deutsch und Englisch gepflegt sind. Sind an einem Record nur andere Sprachen definiert, dann wird dieser Text nicht migriert. Oftmals erben diese Records schon einen Text aus der Basis und es sind nur einige Übersetzungen gepflegt. Diese sollen hier bereinigt werden. Es werden Texte, die identisch mit dem Wörterbuch sind, entfernt. Vom Wörterbuch abweichende Texte werden als Warning ausgegeben und NICHT entfernt. Diese müssen in einem weiteren Schritt bearbeitet werden. Warnings bearbeiten Jetzt müssen die aufgetretenen Warnings begutachtet und ggf. manuell bearbeitet werden. Clean individual texts mit Remove different Wurden im vorherigen Schritt die Warnings begutachtet, können mit dieser Aktion alle abweichenden Texte entfernt werden. (5) Compile und CheckIn Jetzt müssen alle Änderungen compiliert werden. Menü Compile / Compile Changes . Nachdem der Compiler erfolgreich beendet wurde, werden alle Elemente eingecheckt. Dabei sollte ein CheckIn-Kommentar z.B. MLKey Migration angegeben werden. Zum Abschluss noch über den Compile-Manager den Button Complete Framework Compiler aufrufen."
  },
  "doc/mlkey/import-export.html": {
    "href": "doc/mlkey/import-export.html",
    "title": "MLKey Import / Export",
    "keywords": "MLKey Import / Export"
  },
  "doc/index.html": {
    "href": "doc/index.html",
    "title": "Framework Studio Technische Dokumentation",
    "keywords": "Framework Studio Technische Dokumentation"
  },
  "doc/comp/components.html": {
    "href": "doc/comp/components.html",
    "title": "Components",
    "keywords": "Components"
  },
  "doc/code-editor/index.html": {
    "href": "doc/code-editor/index.html",
    "title": "Code-Editor",
    "keywords": "Code-Editor Framework Studio bietet einen umfangreichen C#-Code Editor mit IntelliSense Funktion und Code Highlighting. Intellisense Der Code Editor beinhaltet die Funktionalität von IntelliSense, die kontextabhängig Code-Vervollständigung zur Verfügung stellt. Aufgerufen werden kann IntelliSense mit der Tastenkombination Strg + Leertaste an einer beliebigen Stelle im Code. Go to Definition Mit der Kombination Strg + Doppelklick oder über das Kontextmenü kann aus dem Code Editor heraus zu den angeklickten Zielen gesprungen werden. Dies funktioniert bei Properties und Methoden. Ausgenommen davon sind Methoden fremder Components. Go to Base Über den Eintrag Go to Base im Kontextmenü des Code Editors kann zu der Basis der aktuellen Methode navigiert werden. Compare with Base Über den Kontextmenüeintrag Compare with Base im Code Editor ist es möglich, Überschreibungen von Methoden mit deren Implementierung im Basis-Package zu vergleichen. Zum Vergleich wird ein externes Programm verwendet, welches mit dem Menüpunkt Tools / Options im Hauptfenster konfiguriert werden muss. (Vgl. Konfiguration von Method History Browser)"
  },
  "doc/tables/ml_config.html": {
    "href": "doc/tables/ml_config.html",
    "title": "ML_Config (Business-Datenbank)",
    "keywords": "ML_Config (Business-Datenbank) Die ML-Columns arbeiten standardmäßig mit der Default-Sprache de Deutsch. Ist die \"führende\" Sprache nicht de , dann kann über diese Tabelle die korrekte Default-Sprache eingestellt werden. Das geschieht in der Business-Datenbank, wo auch die Übersetzungs-Tabelle dbRun_MLStrings abgelegt ist, welche die anderssprachigen Werte speichert. Die Einstellung muss in dieser Datenbank stehen, damit sichergestellt ist, dass die Übersetzungs-Tabelle immer mit derselben Konfiguration angesprochen wird - unabhängig davon, wie die Anwendung FS-seitig konfiguriert ist. Die Tabelle muss bei Bedarf manuell per SQL angelegt werden. Dazu können die folgenden Scripte verwendet werden. Das Iso-Sprach-Kürzel de muss entsprechend durch das gewünschte Iso-Sprach-Kürzel ersetzt werden. -- SQL-Server CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR(2), CONSTRAINT PK_ML_CONFIG PRIMARY KEY CLUSTERED (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); -- Oracle CREATE TABLE ML_CONFIG ( CONFIG_KEY VARCHAR2(10) NOT NULL, DEFAULT_LANGUAGE VARCHAR2(2) NULL, CONSTRAINT PK_ML_CONFIG PRIMARY KEY (CONFIG_KEY) ); INSERT INTO ML_CONFIG (CONFIG_KEY, DEFAULT_LANGUAGE) values ('!!!!!', 'de'); Caution Wenn die Konfiguration geändert wurde, dann müssen die Anwendungs-Broker und FS-Services neu gestartet werden, weil diese Informationen aus Performance-Gründen zwischengespeichert werden. Die Konfiguration darf nicht nachträglich geändert werden, weil ansonsten die in der Übersetzungs-Tabelle abgelegten Texte nicht mehr stimmen. Wenn die Konfiguration zu Beginn bei Einrichtung der Business-Datenbank vorgenommen wird, dann muss im Anschluss sichergestellt werden, dass die Tabelle dbRun_MLStrings leer ist. Wenn bei einer Änderung der Konfiguration doch dbRun_MLStrings -Inhalte erhalten bleiben sollen, müssen alle Einträge, für die neue Default-Sprache gelöscht werden."
  },
  "doc/tables/dbrun_mlstrings.html": {
    "href": "doc/tables/dbrun_mlstrings.html",
    "title": "dbRun_MLStrings (Business-Datenbank)",
    "keywords": "dbRun_MLStrings (Business-Datenbank) In dieser Tabelle werden die Fremdsprachen-Texte für die ML-Columns abgelegt. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Spalte Beschreibung ML_TableName Der Name der Datenbank-Tabelle (Uppercase) ML_ColumnName Der Name der MLColumn-Tabellen-Spalte (Uppercase) ML_FSRowID Die FSRowID des referenzierten Datensatzes. Diese kann für SQL-Abfragen verwendet werden. ML_Iso Der 2-stellige Iso-Code der Fremdsprache (Lowercase) ML_Text Der fremdsprachige Text (Langtext)"
  },
  "doc/sql/grammatik.html": {
    "href": "doc/sql/grammatik.html",
    "title": "SQL-Grammatik",
    "keywords": "SQL-Grammatik Im Folgenden ist die Grammatik beschrieben, die vom Framework Studio SQL-Parser verstanden wird. Alle an die Datenbank geschickten Befehle müssen dieser Grammatik genügen, ansonsten kommt es zu SqlParser-Exceptions. Grammatik für SQL-Kommandos <select> SELECT [DISTINCT] { * | <resultColumn>[,…n] } FROM { <singleSource> | <joinSource> } [ WHERE <condition> ] [ GROUP BY <value>[,…n] [HAVING <condition>]] [ {UNION [ALL] | INTERSECT | EXCEPT} <select(ohne orderby)> ] [ ORDER BY <orderColumn>[,…n] ] <insert> INSERT INTO <identifierChain> ( <identifier>[,…n] ) { VALUES ( <value>[,…n] ) | <select> } <update> UPDATE <identifierChain> SET {<identifierChain> = <value> } [,…n] [ WHERE <condition> ] <delete> DELETE [FROM] <identifierChain> [ WHERE <condition> ] Grammatik für die Bestandteile der Kommandos <resultColumn> <identifierChain>.* | <value> [AS <identifier>] <singleSource> ( <singleSource> ) | <identifierChain> [ [AS] <identifier> ] <joinSource> ( <joinSource> ) | { <singleSource> | <joinSource> } { INNER | {LEFT | RIGHT | FULL} [OUTER] } JOIN { <singleSource> | <joinSource> } ON <condition> <condition> ( <condition> ) | NOT <condition> | <condition> {{ AND | OR } <condition>}[,…n] | <value> <predicate2> | EXISTS ( <select> ) <predicate2> { = | != | < | <= | > | >= } <value> | IS [NOT] NULL | BETWEEN <value> AND <value> | IN ( <select> | <value> [,…n] ) | LIKE <value> | LIKEESCAPE <value> <value> NULL | ( <value> ) | { - | + } <value> | <value> { + | - | * | / | “||” } <value> | <identifierChain> | [<identifierChain>.] <FunktionsName> ( [ <value> [,…n] ] ) | <searchedCaseWhen> | <simpleCaseWhen> | \"[[\" <natives sql fragment> \"]]\" | <stringLiteral> | <integerValue> | <decimalValue> <searchedCaseWhen> CASE {WHEN <condition> THEN <value>}[,…n] [ ELSE <value> ] END <simpleCaseWhen> CASE <value> {WHEN {<predicate2> | <value>} THEN <value>}[,…n] [ ELSE <value> ] END <orderColumn> <value> [ASC | DESC] <identifierChain> <identifier>[.<identifier>][,…n] <identifier> \"[\" <beliebige Zeichenfolge> \"]\" | <Wort, mit einem Buchstaben beginnend>"
  },
  "doc/sql/funktionen.html": {
    "href": "doc/sql/funktionen.html",
    "title": "SQL-Funktionen",
    "keywords": "SQL-Funktionen GETGUID GETGUID ( ) Liefert eine neue Guid mit folgendem Format: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server LOWER( REPLACE ( NEWID ( ), '-', '' ) ) Oracle LOWER( SYS_GUID ( ) )"
  },
  "doc/code-editor/code-messages.html": {
    "href": "doc/code-editor/code-messages.html",
    "title": "Code-Messages",
    "keywords": "Code-Messages Wenn Sie eine Methode eines Forms bearbeiten, stehen Ihnen Editoren zum komfortablen Erstellen und Bearbeiten von mehrsprachigen Ausnahmen (Exceptions) und Meldungen (Message-Boxen) zur Verfügung. Diese können Sie über die Buttons Exception Editor Wizard und Message Box Editor Wizard aufrufen. Wenn Sie eine Textcollection ändern, indem Sie beispielsweise einen neuen Eintrag erzeugen oder einen bestehenden Eintrag ändern, dann muss die Textcollection dazu in der aktuellen Version für Sie ausgecheckt werden. Benutzen Sie dazu den Button Edit Message . Andere Benutzer können nun die Textcollection nicht bearbeiten. Beim Verlassen des Message Box Editors bzw. Exception Editors wird die Textcollection automatisch wieder eingecheckt, so dass auch andere Benutzer wieder auf die Textcollection zugreifen können. Beide Editoren weisen nur sehr geringfügige Unterschiede auf. Radiobutton ML Key Hier können sie einen MLKey angeben. Mit dem Auswahl-Button neben dem Textfeld öffnet sich der Dialog Select ML Key . Dies ist die Standard-Option. Neue Meldungen sollten immer über das Wörterbuch gezogen werden. Radiobutton New Message Wenn Sie diesen Radiobutton auswählen, wird ein neuer Text in die ausgewählte Textcollection eingetragen. Important Wenn Sie einen neuen Text hinzufügen, müssen Sie auch die Textcollection kompilieren, da es sonst beim Ausführen des Programms Fehlermeldungen gibt. Radiobutton Change Message Wenn Sie diesen Radiobutton auswählen, können Sie mit dem Button Choose existing Message einen bestehenden Eintrag aus der angegebenen Textcollection auswählen oder mit dem Button Search nach einem bestehenden Eintrag suchen. Button Change Collection Mit diesem Button kann die Textcollection geändert werden, aus der ein Text ausgewählt werden soll, bzw. in welcher der neue Text eingetragen werden soll. Als Default-Wert ist die Textcollection ctMessages ausgewählt. Button Choose existing Message Mit diesem Button kann aus der gewählten Textcollection ein existierender Eintrag ausgewählt werden. Feld Collection Zeigt an, welche Textcollection ausgewählt ist. Button Search Mit diesem Button öffnen Sie einen Suchdialog. In diesem Dialog wird die Suche auf die Textcollection, die im Exception Editor / Message Box Editor angegeben ist, eingeschränkt. Die Suchfunktionalität ist identisch mit den Möglichkeiten, die auf der Registerkarte Search im Framework-Designer zur Verfügung gestellt werden. Text-Grid Ist ein MLKey ausgewählt, wird hier nur der Text angezeigt. Der ML Key kann über das Textfeld bzw. den Auswahl-Button geändert werden. Die Bearbeitung der Texte-Inhalte erfolgt über das Wörterbuch . In diesem Grid kann der Text der Message in den verschiedenen Sprachen eingegeben werden. Wurde mit Choose existing Message ein Eintrag ausgewählt, wird dieser geändert und in die Textcollection zurückgeschrieben. Alle vorhandenen Message-Boxen, die diesen Eintrag verwenden, sind ebenfalls davon betroffen. Dem Text können Parameter zugewiesen werden. Die Parameter werden in der Form {0}, {1} usw. angegeben. Jeder Parameter kann mehrmals verwendet werden. Der Beleg {0} für Kunde {1} hat sich geändert. Wollen Sie den Beleg {0} speichern? Die Parameter werden in der Textbox String.Format... gefüllt. Combobox Icon (nur Message-Box) Gibt an, welches Icon verwendet werden soll Error Exclamation Information Question None Combobox Buttons (nur Message-Box) Gibt an, welche Buttons angezeigt werden sollen. Wird OK ausgewählt, ist es nicht notwendig, einen Event-Handler zu hinterlegen. Werden andere Buttons ausgewählt, muss ein Event-Handler hinterlegt werden. AbortRetryIgnore OK OKCancel RetryCancel YesNo YesNoCancel Combobox Default (nur Message-Box) Gibt den Button an, der beim Anzeigen der Message-Box ausgewählt sein soll. So kann z.B. bei den Buttons YesNo durch Angabe von Button2 das versehentliche Betätigen des Yes -Button verhindert werden. Button1 Button2 Button3 Die Nummer des Buttons entspricht der Angabe bei Buttons. z.B. YesNoCancel bedeutet Button1 = OK , Button2 = No , Button3 = Cancel Button Event Handler (nur Message Box Editor) Mit diesem Button kann angegeben werden, ob mit dem Klick in der Message-Box (z.B. auf OK oder Cancel ) ein Event angestoßen werden soll oder nicht. Ist der Button gedrückt, erscheint rechts daneben eine Combobox, mit der evtl. bestehende Methoden ausgewählt werden können. Mit dem Button New wird ein neuer Event-Handler angelegt. Es wird eine Methode OnMsgBoxClick1 angelegt. Der Parameter MsgBoxEventArgs hat ein Property DialogResult, damit abgefragt werden kann, welcher Button gedrückt wurde. public void OnMsgBoxClick1(object sender, MsgBoxEventArgs e) { if (e.DialogResult == DialogResult.OK) { //Code for Ok. } } Combobox Severity (nur Exception Editor) Hier können Sie den Schweregrad der Ausnahme (0-3) festlegen. Add Inner Exception (nur Exception Editor) Wenn die Checkbox gesetzt ist, können Sie das Property InnerException füllen. Geben Sie dazu die zu übergebende Variable im Textfeld an. Geben Sie dazu im Textfeld den Namen der lokalen Exception-Variable an. Textbox String.Format... In dieser Textbox können die Parameter der Message angegeben werden. Es ist möglich im Message Text Parameter anzugeben. Dies geschieht mit {0}, {1} usw. Diese Parameter können im Text auch mehrmals verwendet werden. Für jeden dieser Parameter kann hier, mit Komma getrennt, ein Wert angegeben werden. Der erste Parameter steht für {0} , der zweite für {1} usw. this.oOrder.lngOrderID, this.oOrder.lngCustomerID Button OK Schließt den Dialog und fügt den generierten Message-Code in den Code-Editor ein. Button Cancel Schließt den Dialog und verwirft die Änderungen. Wenn der Message-Box-Editor mit OK verlassen wird, wird an die Stelle im Code, an der sich der Cursor befindet der Code generiert. // FSCodeMessage: Really delete article {0}? MsgBox.Show(this.Global.FormatMLKeyText(MLKeys.MSG_9188180c5ac64a5384141b553eef8105, this.oSelectedArticle.sName), \"\", MsgBoxButtons.YesNo, MsgBoxIcons.Question, new MsgBoxEventHandler(OnDeleteQuestionMsgBoxClick)); Durch eine farbige Markierung ist dieser Code im Code-Editor gut zu erkennen. Um die Code-Message nachträglich zu ändern, setzen Sie den Fokus irgendwo in den generierten Code-Block und drücken erneut den entsprechenden Wizard-Button. Es öffnet sich wieder der Editor wie oben und die Daten der Code-Message werden angezeigt und können geändert werden. Bei Bedarf können auch einzelne Bestandteile wie z.B. der MLKey oder ein Enum-Wert direkt im Code geändert werden. Caution Die Struktur des Code darf jedoch nicht geändert werden, weil dieser sonst für eine spätere Bearbeitung mit dem Editor nicht geparsed werden kann. Der Code darf nicht mehrzeilig sein."
  },
  "doc/application/application.html": {
    "href": "doc/application/application.html",
    "title": "Application",
    "keywords": "Application"
  },
  "doc/sql/operatoren.html": {
    "href": "doc/sql/operatoren.html",
    "title": "Operatoren",
    "keywords": "Operatoren || Verbindet 2 Zeichenketten. Beispiel: SELECT column1 || ' - ' || colum2 FROM tabelle Bei Zeichen-Ketten muss dieser Operator verwendet werden. Der + - Operator ist nicht zulässig. Wenn dennoch der + - Operator verwendet wird, versucht der Parser dies zu korrigieren. Das ist möglich, wenn bei der Operation Zeichen-Ketten oder bestimmte Zeichenketten-Funktionen beteiligt sind. Nicht erkannt wird z.B. das Verbinden von 2 Spalten. In diesem Fall kann es zu Fehlern auf der Ziel-Datenbank kommen. + - * / Addiert, subtrahiert, multipliziert bzw. dividiert 2 Zahlenwerte. Der Framework Studio SQL-Parser versteht die im Folgenden beschriebenen Operatoren und Funktionen. Diese werden Datenbank-spezifisch umgesetzt und können bedenkenlos in selbst formuliertem Sql verwendet werden. Funktionen, die der Parser nicht kennt, werden direkt ohne Konvertierung an die Datenbank weitergegeben. Das bedingt, dass diese Funktionen von der Datenbank verstanden werden. Ggf. Ist es in solchen Fällen nötig, selbst dafür zu sorgen, dass das Sql datenbankspezifisch formuliert wird."
  },
  "doc/sql/num-funktionen.html": {
    "href": "doc/sql/num-funktionen.html",
    "title": "Numerische Funktionen",
    "keywords": "Numerische Funktionen ABS ABS ( <Numeric Expression> ) Liefert den absoluten Betrag einer Zahl TRUNC TRUNC ( <Numeric Expression>, <Decimals> ) Schneidet eine Dezimal-Zahl auf die angegebene Anzahl Stellen ab. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server ROUND ( <Numeric Expression>, <Decimals>, 1 ) Oracle TRUNC ( <Numeric Expression>, <Decimals> ) ROUND ROUND ( <Numeric Expression>, <Decimals> ) Rundet eine Dezimal-Zahl auf die angegebene Anzahl Stellen. POWER POWER ( <Numeric Expression>, <y> ) Potenziert eine Zahl mit y SQUARE SQUARE ( <Numeric Expression> ) Quadrat eine Zahl. SQRT SQRT ( <Numeric Expression> ) Quadratwurzel einer Zahl CEILING CEILING ( <Numeric Expression> ) Rundet eine Zahl auf. FLOOR FLOOR ( <Numeric Expression> ) Rundet eine Zahl ab. LOG LOG (<Float Expression> ) Natürlicher Logarithmus einer Fließkommazahl. LOG10 LOG10 ( <Float Expression> ) Logarithmus mit der Basis 10. EXP EXP ( <float Expression> ) Gibt den exponentiellen Wert des angegebenen float-Ausdrucks zurück. (e x ) SIN SIN ( <float Expression> ) Sinus einer Fließkommazahl. TAN TAN (<Float Expression> ) Tangens einer Fließkommazahl. SIGN SIGN ( <Number> ) Gibt das Vorzeichen der Zahl zurück. Negativ -> -1, 0 -> 0, positiv -> +1."
  },
  "doc/sql/datum-funktionen.html": {
    "href": "doc/sql/datum-funktionen.html",
    "title": "Datums-Funktionen",
    "keywords": "Datums-Funktionen GETDATE GETDATE ( ) Liefert das aktuelle Datum auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETDATE ( ) Oracle SYSDATE GETUTCDATE GETUTCDATE ( ) Liefert die aktuelle Weltzeit (UTC) auf dem Datenbank-Server. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server GETUTCDATE ( ) Oracle CAST(sys_extract_utc(systimestamp) AS TIMESTAMP) ADD_DAYS ADD_DAYS ( <Date Expression>, <Days> ) Addiert die übergebenen Tage zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( DAY, <Days>, <Date Expression> ) Oracle <Date Expression> + <Days> ADD_MINUTES ADD_MINUTES ( <Date Expression>, <Minutes> ) Addiert die übergebenen Minuten zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MINUTE, <Minutes>, <Date Expression> ) Oracle <Date Expression> + ( <Minutes> / 1440 ) ADD_MONTHS ADD_MONTHS ( <Date Expression>, <Months> ) Addiert die übergebenen Monate zu einem Datum/Zeit-Ausdruck. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEADD ( MONTH, <Months>, <Date Expression> ) Oracle ADD_MONTHS ( <Date Expression>, <Months> ) DAYS_BETWEEN DAYS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Tage zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF ( DAY, <Start-Date>, <End-Date> ) Oracle TRUNC ( <End-Date> - <Start-Date> ) MONTHS_BETWEEN MONTHS_BETWEEN (<Start-Date>, <End-Date>) Liefert die Anzahl der ganzen Monate zwischen 2 Datums-Werten. Wenn das Start-Datum größer ist als das End-Datum, dann werden negative Werte zurückgegeben. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEDIFF (MONTH, <Start-Date>, <End-Date>) Oracle MONTHS_BETWEEN (<End-Date>, <Start-Date>) YEAR YEAR ( <Date Expression> ) Liefert eine 4-stellige Zahl, die dem Jahr des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server YEAR ( <Date Expression> ) Oracle EXTRACT ( YEAR FROM <Date Expression> ) MONTH MONTH ( <Date Expression> ) Liefert eine Zahl, die dem Monat des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server MONTH ( <Date Expression> ) Oracle EXTRACT ( MONTH FROM <Date Expression> ) DAY DAY ( <Date Expression> ) Liefert eine Zahl, die dem Tag (Tag des Monats) des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DAY ( <Date Expression> ) Oracle EXTRACT ( DAY FROM <Date Expression> ) HOUR HOUR ( <Date Expression> ) Liefert eine Zahl, die der Stunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( HOUR, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'HH24' ) ) MINUTE MINUTE ( <Date Expression> ) Liefert eine Zahl, die der Minute des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( MINUTE, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>,'MI' ) ) SECOND SECOND ( <Date Expression> ) Liefert eine Zahl, die der Sekunde des Datum/Zeit-Wertes entspricht. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server DATEPART ( SECOND, <Date Expression> ) Oracle TO_NUMBER ( TO_CHAR ( <Date Expression>, 'SS' ) )"
  },
  "doc/sql/cast-funktionen.html": {
    "href": "doc/sql/cast-funktionen.html",
    "title": "Umwandlungsfunktionen",
    "keywords": "Umwandlungsfunktionen CHAR_TO_DATE CHAR_TO_DATE ( <Expression>, <format-Number>) Wandelt eine Zeichen-Kette in ein Datum um. Dabei wird das angegebene Format verwendet. Die Format-Nummer muss als konstante Zahl übergeben werden. Sie kann folgende Werte haben: Number Format YY Format YYYY 1 / 101 MM/DD/YY MM/DD/YYYY 2 / 102 YY/MM/DD YYYY/MM/DD 3 / 103 DD/MM/YY DD/MM/YYYY 4 / 104 DD.MM.YY DD.MM.YYYY 5 / 105 DD-MM-YY DD-MM-YYYY 6 / 106 DD MM YYY DD MM YYYY 7 / 107 Mon DD, YY Mon DD, YYYY 8 / 108 hh:mm:ss (24h) 10 / 110 MM-DD-YY MM-DD-YYYY 11 / 111 YY/MM/DD YYYY/MM/DD 12 / 112 YYMMDD YYYYMMDD 20 / 120 YYYY-MM-DD hh:mm:ss (24h) DATE_TO_CHAR DATE_TO_CHAR ( <date Expression>, <format-Number> ) Wandelt ein Datum in eine Zeichenkette um. Die Format-Nummer arbeitet wie bei der Funktion CHAR_TO_DATE. NUMBER_TO_CHAR NUMBER_TO_CHAR ( <Number Expression>, <Decimals>) Wandelt eine Dezimal-Zahl in einen Text um. Dabei wird die Zahl auf die übergebene Anzahl von Dezimal-Stellen gerundet bzw. abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, <Decimals> ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999.9999' ) ) Die Anzahl der Nachkommastellen ist gleich <Decimals> INT_TO_CHAR INT_TO_CHAR ( <Number Expression>) Wandelt eine Ganzzahl in einen Text um. Bei einer Dezimal-Zahl wird gerundet bzw. es werden die Dezimal-Stellen abgeschnitten. Umsetzung des Statements auf den verschiedenen Datenbanken SQL-Server CAST ( ROUND ( <Number Expression>, 0 ) AS VARCHAR ) Oracle LTRIM ( TO_CHAR (<Number Expression>, '99999999999999999999999999999999' ) ) CHAR_TO_DECIMAL CHAR_TO_DECIMAL ( <Expression> ) Wandelt eine Zeichenkette in eine Dezimal-Zahl um."
  },
  "doc/mlkey/woerterbuch.html": {
    "href": "doc/mlkey/woerterbuch.html",
    "title": "Wörterbuch",
    "keywords": "Wörterbuch Alle mehrsprachigen Texte der Anwendung werden in einem zentralen Wörterbuch abgelegt. Organisiert werden die Einträge mit einem eindeutigen alphanumerischen Schüssel - dem MLKey . Die MLKeys und deren Texte können folgendermaßen genutzt werden: In den MLString -Properties überall in Framework Studio Im selbst geschriebenen Methoden-Code (siehe Programmierung ) In den Code-Messages (Exceptions, Message-Boxen) Multilanguage Text Editor Die Bearbeitung des Wörterbuchs erfolgt über den Multilanguage Text Editor . Dieser wird über das Menü Tools / Multilanguage Text Editor geöffnet. Note Die im Grid angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Die Bearbeitung des Wörterbuchs funktioniert ohne Checkout-Mechanismus. Wenn mehrere Benutzer zur gleichen Zeit an denselben MLKeys arbeiten sollten, dann gewinnt derjenige, der zuletzt den Button Save drückt. Der Editor sammelt alle vorgenommenen Änderungen (Add, Edit, Delete) im Hintergrund. Mit dem Button Save werden diese in das Repository gespeichert. Dabei wird in einer Transaktion zuerst der aktuelle Stand frisch aus dem Repository gelesen, dann die Änderungen erneut auf diesen (evtl. durch einen anderen Benutzer veränderten) Stand angewendet und zuletzt der neue Stand wieder zurück in das Repository gespeichert. Das hat die Folge, dass nach einem Save Änderungen sichtbar sind, die zuvor von einem anderen Benutzer vorgenommen wurden. Eine Ausnahme sind die Basis-Packages. Diese werden aus einem Stand gezogen, den der FrameworkCompiler zum Zeitpunkt des Compile-Laufs in den Workspace gespeichert hat. Suchen von MLKeys Essentiell für die tägliche Arbeit ist das Auffinden von existierenden MLKeys. Dazu wird das Search Feld angeboten. Die Suche scannt alle Felder des MLKeys: MLKey, Comment, Obsolete, Texte. Die Groß-Klein-Schreibung wird nicht berücksichtigt. Es können mehrere Worte eingegeben werden. Dann müssen alle Worte oder Wortteile in irgend einem Feld auftauchen. z.B. MSG_ Artikel Save sucht nach Messages die mit Artikel und Save zu tun haben. Generell wird nach Wortteilen gesucht. Wenn man das Wort oder den Text in Anführungszeichen setzt, wird nach einem exakten Treffer und ganzen Worten gesucht. Das funktioniert auch mit mehreren Worten und in Kombination mit der normalen Suche. z.B. LBL_ \"Kunde\" Ziel des Wörterbuches ist es, Texte wiederzuverwenden und die Anzahl der Einträge auf das Nötigste zu reduzieren. Aus diesem Grund sollte man immer zuerst nach einem MLKey suchen, bevor man einen neuen erfasst. Zu einem logischen Begriff sollen keine zwei MLKeys existieren. Tip Die Suche sollte durchaus kreativ gestaltet werden - besonders bei Texten die eigentlich schon vorhanden sein müssten. Ein Beispiel dafür ist das Wort Einfügen . Möchte man dieses mit der englischen Bezeichnung Add nutzen, stellt man fest, dass es Einfügen schon mit mehreren Übersetzungen gibt, jedoch keine mit der englischen Bezeichnung Add . Sucht man dann aber direkt nach Add , so findet man den statt Einfügen zu verwendenden deutschen Text Hinzufügen . Erfassen neuer MLKeys Mit dem Button Add öffnet sich ein Dialog, in dem der neue MLKey erfasst werden kann. MLKey : Hier wird der MLKey angegeben. Im Customizing-Package wird der Package-Code automatisch vorbelegt. Note Der MLKey kann zu einem späteren Zeitpunkt nicht mehr geändert werden. Der MLKey kann frei vergeben werden, es gibt jedoch ein paar Regeln und Empfehlungen: Es handelt sich um einen C#-Identifier, der auch im Quellcode verwendet wird. Buchstaben, Zahlen, Unterstrich Groß-Klein-Schreibung ist relevant Der sprechende Name sollte sich nach Möglichkeit an den englischen Text anlehnen. z.B. LBL_Article Wenn der Text zu komplex ist - z.B. bei Messages oder Tooltips, dann kann der Name eine Guid enthalten. Diese kann mit dem Button Generate Guid angefügt werden. z.B. MSG_1c9f3024dfc340dfba0651cb92d90ad6 In Customizing-Packages erhält der MLKey einen Package-Code. Dieser wird automatisch vorbelegt. z.B. LBL_K87_SpecialArticle In der eNVenta/WS Standard-Entwicklung sind entsprechende Namensregeln einzuhalten. Wird dieser Dialog aus der MLKey-Suche heraus geöffnet, dann wird abhängig vom jeweiligen Context auch ein passender Präfix vorbelegt: LBL_ / LBL_<PackageCode>_ : Der Suchdialog wurde z.B. aus einem Caption- oder Default-Label-Property aufgerufen. TTT_ / TTT_<PackageCode>_ : Der Suchdialog wurde aus dem Tooltip-Property aufgerufen. MSG_ / MSG_<PackageCode>_ : Der Suchdialog wurde aus dem MessageBox- bzw. Exception-Wizard aufgerufen. Comment : Der Kommentar beschreibt bei Bedarf den MLKey genauer. Das ist sinnvoll, wenn der Text oder auch der MLKey erklärungsbedürftige Abkürzungen beinhaltet oder wenn es ähnliche Texte mit verschiedenen Verwendungszwecken gibt. Obsolete : Ein MLKey kann durch die Eingabe einer Obsolete-Message als veraltet markiert werden. Der Compiler wird bei Verwendung dieses MLKeys diese Message als Warning ausgeben. Weil das Löschen von MLKeys vor allem im Hinblick auf Customizing-Packages Compile-Errors erzeugt, sollte davon abgesehen und stattdessen diese Obsolete-Message verwendet werden. Ein Hinweis auf einen alternativ zu verwendenden MLKey ist empfehlenswert. German : Die Eingabe eines deutschen Textes ist Pflicht, weil Deutsch immer der letzte Fallback ist, wenn eine Fremdsprache nicht gepflegt ist. Fremdsprachen : Über die Radio-Buttons kann festgelegt werden, welche Sprache im 2. Textfeld angezeigt oder bearbeitet werden soll. Diese Texte sind optional. Die angebotenen Fremdsprachen und deren Reihenfolge kann in den Options mit der Einstellung Languages in designer eingestellt werden. German lässt sich in diesem Dialog aber nicht steuern - diese Sprache wird immer im separaten Feld angezeigt. In der eNVenta/WS Standard-Entwicklung muss der englische Text gepflegt werden. Button Untranslatable : Es gibt Texte, die nicht übersetzt werden können wie z.B. Eigennamen oder Einheiten. Dieser Button löscht alle Fremdsprachen-Texte und Schreibt den Text untranslatable in das Comment Feld. Mit der Routine MLKeys Cleanup kann diese Aktion systematisch für das komplette Wörterbuch ausgeführt werden. Bearbeiten von MLKeys Mit dem Button Edit wird für den selektierten MLKey der Bearbeitungs-Dialog geöffnet. Durch einen Doppelklick in das Grid kann der Bearbeitungs-Dialog ebenfalls geöffnet werden. Dabei wird der Fokus automatisch in das Feld gesetzt, das der angeklickten Grid-Zelle entspricht. Das ist praktisch, wenn man z.B. gezielt eine Fremdsprache bearbeiten möchte. Außerdem können einzeilige Texte direkt im Grid bearbeitet werden. Note Die logische Bedeutung des MLKeys darf zu einem späteren Zeitpunkt nicht mehr geändert werden. Der Dialog ist gleich aufgebaut wie der Add-Dialog. Es werden zusätzlich das Create Date des MLKeys und die Edit Dates der Fremdsprachen-Texte angezeigt. Der MLKey kann nicht bearbeitet werden. Wird im Customizing-Package ein MLKey aus dem Basis-Package geöffnet, dann sind einige weitere Felder für die Bearbeitung gesperrt: Comment / Button Untranslatable , Obsolete Die Texte können bearbeitet werden. Mit dem Button View History wird ein weiteres Fenster geöffnet, in dem die Version des Eintrages vor der letzten Bearbeitung angezeigt wird. Siehe Abschnitt History . Copy Entry / Paste Entry Wenn man ein oder mehrere Einträge selektiert hat, kann man mit dem Button Copy Entry diese in die Zwischenablage kopieren. Mit dem Button Paste Entry können diese Einträge z.B. in einer anderen Version des Packages eingefügt werden. Intern benutzt diese Funktion den Import- / Export-Mechanismus . Dieser verwendet ein XML im TMX-Format. Dadurch ist es möglich, das XML vor dem Paste Entry bei Bedarf in einem Text-Editor zu manipulieren, z.B. um den PackageCode des MLKey anzupassen. Mit Paste Entry werden neue MLKeys hinzugefügt. Enthält die Zwischenablage existierende Keys, dann wird vor dem Einfügen ein Auswahl-Dialog angezeigt. Ignore : Es werden keinerlei Einträge ersetzt. Lediglich unbekannte, neue MLKeys werden hinzugefügt. Replace : Es wird der komplette existierende Eintrag ersetzt. Wenn in der Zwischenablage ein Wert nicht gesetzt ist, dann wird dieser entfernt. Merge : Die beiden Einträge werden zusammengeführt. Dabei gewinnt jeweils der Text mit dem neueren Edit-Date. Mit dem Button Cancel wird die komplette Aktion abgebrochen. Dann werden auch keine MLKeys hinzugefügt. Customizing Jedes Customizing-Package verwaltet sein eigenes Wörterbuch. Es können neue MLKeys angelegt werden. Diese müssen den Package-Code enthalten, damit es in Zukunft keine Kollisionen mit Basis-Packages gibt. Bevor ein neuer MLKey angelegt wird, sollte immer geprüft werden, ob es nicht doch einen passenden MLKey gibt. Texte aus Basis-Packages können überschrieben bzw. ergänzt werden. So können z.B. Übersetzungen für Fremdsprachen gepflegt werden. Es muss darauf geachtet werden, dass die Bedeutung des MLKeys nicht geändert wird, weil dieser ggf. an mehreren Stellen in der Anwendung verwendet wird. Wird an einer bestimmten Stelle in der Anwendung ein anderer Text benötigt (in eNVenta kann das z.B. der Text \"Code1\" sein, der ersetzt werden soll) dann muss an dieser Stelle (jedoch möglichst weit unten in der DBColumn oder Metadatentyp) ein anderer MLKey zugeordnet werden. (siehe auch MLString-Vererbung ) Im Customizing-Package übersetzte Texte können exportiert und in das Basis-Package importiert werden. Zu einem späteren Zeitpunkt können die dann redundanten Übersetzung mit der MLKeys Cleanup Routine bereinigt werden. History Bei jeder Bearbeitung im Wörterbuch wird die Vorgänger-Version des MLKeys in einen separaten History-Bereich geschrieben. Aus dem Edit-Dialog heraus kann diese Information mit dem Button View History geöffnet werden. Gibt es keine Informationen, ist der Button deaktiviert. Die History arbeitet pro Sprache. Wird z.B. der englische Text bearbeitet, wird auch nur der alte englische Text mit seinem alten Änderungs-Datum in den History-Bereich übertragen. Die History-Informationen der anderen Sprachen bleiben unverändert. Eine leere Eigenschaft wird nicht historisiert - das gilt insbes. für Comment und Obsolete Message . Wird eine dieser Eigenschaften geleert, dann verbleibt der alte Text auch dann in der History, wenn später wieder ein neuer Text gesetzt wird. Wird ein MLKey gelöscht , wird der komplette Eintrag mit allen Sprachen in die History übertragen. Dieser kann jedoch zu einem späteren Zeitpunkt nicht mehr ohne weiteres gegriffen werden. Tip Wurde ein MLKey versehentlich gelöscht und es gibt einen Compile-Error mit dem entsprechenden MLKey, dann kann man diesen Eintrag wieder neu im Wörterbuch anlegen. Beim anschließenden Bearbeiten des MLKeys können dann die noch existierenden History-Informationen eingesehen werden. Gefüllt wird die History mit dem Save -Button. Framework Studio sammelt alle im Wörterbuch vorgenommenen Änderungen und speichert diese mit dem Save -Button in einem Rutsch. Dadurch kann ein Text auch mehrfach hintereinander geändert werden. Erst nach dem Save steht der alte Text in der History. Note Beim Labeln der Package-Version wird die History-Information nicht in die neue Package-Version übernommen. Die History-Informationen berücksichtigen nur das aktuelle Package. Weil für Basis-Packages das Wörterbuch aus dem letzten Framework-Compiler-Stand gelesen wird, enthält es keine History-Informationen."
  },
  "doc/mlkey/programmierung.html": {
    "href": "doc/mlkey/programmierung.html",
    "title": "Programmierung mit MLKeys",
    "keywords": "Programmierung mit MLKeys Klasse MLKeys Framework Studio generiert aus dem Wörtebuch eine Klasse MLKeys , die alle MLKeys beinhaltet. Sie wird im Compile-Schritt Ressource compiliert und steht somit in der kompletten Applikation zur Verfügung. Sie erbt die MLKeys aus dem Basis-Package - so z.B. auch die SYS_ -Keys aus dem System-Package. Die Klasse wird z.B. folgendermaßen verwendet: this.Global.GetMLText( MLKeys.LBL_Amount ); Alle Quellcodes, die mit MLKeys arbeiten, greifen auf diese Klasse zu - sowohl selbst geschriebener Methoden-Code als auch der von Framework Studio generierte Code. Dadurch findet der CSharp-Compiler alle Probleme, die im Zusammenhang mit MLKeys auftreten können: Compile-Error, wenn ein MLKey nicht mehr existiert. Auch wenn diese z.B. in einem Metadatentypen oder einem Form-Control verwendet werden. Eine Obsolete-Warning, wenn ein mit einer Obsolete-Message versehener MLKey verwendet wird. Die Obsolete-Message wird als Obsolete -Attribut vor den MLKey generiert. Eine Warning, wenn in einem Customizing-Package ein identischer MLKey definiert ist. Die generierte MLKeys -Klasse sieht in etwa so aus: public class MLKeys : BasisPackage_MLKeys { public static readonly MLKey LBL_Amount = new MLKey(\"LBL_Amount\"); public static readonly MLKey LBL_Article = new MLKey(\"LBL_Article\"); public static readonly MLKey TTT_Article = new MLKey(\"TTT_Article\"); public static readonly MLKey MSG_0da9815a719049ae806d3c0ba7d824ff = new MLKey(\"MSG_0da9815a719049ae806d3c0ba7d824ff\"); public static readonly MLKey MSG_0f2ad9d4385b49fc9667ed7eff2d925f = new MLKey(\"MSG_0f2ad9d4385b49fc9667ed7eff2d925f\"); [Obsolete(\"Please use LBL_Amount\")] public static readonly MLKey LBL_Amount2 = new MLKey(\"LBL_Amount2\"); } Warning Es sollten keine eigenen MLKey-Instanzen aus Strings erzeugt werden. Diese können vom Compiler nicht validiert werden. Code Editor Der Code-Editor bietet diverse Unterstützung bei der Arbeit mit der Klasse MLKeys . Im Intellisense werden alle MLKeys angeboten und im jeweiligen Tooltip wird zur besseren Orientierung der deutsche Text angezeigt. Fährt man mit der Maus über einen MLKey, dann wird ein Info-Tooltip mit dem deutschen Text angezeigt. Wird auf einem MLKey der Befehl Goto Definition (F12) ausgeführt, dann öffnet sich der Multilanguage Text Editor und es wird der entsprechende Eintrag selektiert. Methoden am Global-Object Das GlobalObject bietet mehrere Methoden an, mit denen ein MLKey in ein Text überführt werden kann. GetMLText public string GetMLText(MLKey mlkey) Diese Methode ermittelt für den übergebenen MLKey den Text. Es wird die aktuell in der Session gesetzte Sprach-Hierarchie verwendet. public string GetMLText(MLKey mlkey, string iso) Bei dieser Variante wird der Iso-Code der gewünschten Sprache übergeben. Beispiel: FSstring sArticleLabel = this.Global.GetMLText( MLKeys.LBL_Article ); FSString sAmountEn = this.Global.GetMLText( MLKeys.LBL_Amount, \"en\" ); FormatMLText public string FormatMLText(MLKey mlkey, params object[] args) Diese Methode ermittelt für den übergebenen MLKey den Text. Es wird zudem ein String.Format() mit den übergebenen args ausgeführt. Beispiel: FSstring sFormattedText = this.Global.FormatMLText( MLKeys.LBL_MitFormat, \"Text1\", lngAmount ); GetMLKeyText public MLKeyText GetMLKeyText(MLKey mlkey) Diese Variante gibt ein MLKeyText Objekt zurück, welches neben dem Text auch den übergebenen MLKey beinhaltet. Das kann hilfreich sein, wenn der MLKey interessant ist, um ihn z.B. als Fehler-Code zu verwenden. Diese Methode wird z.B. für die Code-Messages benutzt: // FSCodeMessage: Please select only one article. throw new FrameworkApplicationException(this.Global.GetMLKeyText(MLKeys.MSG_1b6b9bea43304e2082d1162d75d9e317), 0); FormatMLKeyText public MLKeyText FormatMLKeyText(MLKey mlkey, params object[] args) Gibt ein MLKeyText -Objekt mit dem formatierten Text und dem MLKey zurück. Diese Methode wird in den Code-Messages benutzt. Beispiel: // FSCodeMessage: Please specify {0} throw new FrameworkApplicationException(this.Global.FormatMLKeyText(MLKeys.MSG_24979a3d247546318dc673c5501d3b15, this.sName), 0); cGlobal EntryPoint In der Klasse cGlobal gibt es einen zentralen Entry-Point GlobalGetMLText . Dieser wird JEDES MAL aufgerufen, wenn aus einem MLKey ein Text erzeugt wird. public virtual string GlobalGetMLText(MLKey mlkey, string iso) Die Sprach-Hierarchie der Session, welche am GlobalObject hinterlegt ist, wird außerhalb dieser Methode aufgelöst. Besteht die Hierarchie aus mehreren Fallbacks (z.B. fr, en, de ), wird diese Methode auch ggf. mehrfach nacheinander mit den unterschiedlichen Iso-Codes aufgerufen. Liefert die Methode einen Wert ungleich null oder String.Empty zurück, wird dieser als Text verwendet und es erfolgt kein weiterer Aufruf. Es ist möglich, diese Methode am cGlobal zu überschreiben und die Ermittlung der Texte zu beeinflussen oder zu überwachen. Warning Diese Methode muss sehr performant gestaltet werden. Komplexe Logik kann die Performance der kompletten Anwendung sehr negativ beeinflussen. Der Basis-Aufruf muss sichergestellt werden. Ansonsten wird das komplette Wörterbuch ausgehebelt und es werden gar keine Texte mehr ermittelt."
  },
  "doc/mlkey/enventa-regeln.html": {
    "href": "doc/mlkey/enventa-regeln.html",
    "title": "eNVenta Regeln für MLKeys",
    "keywords": "eNVenta Regeln für MLKeys Allgemeine Regeln Texte aus den Test-Namespaces : Diese sollen nicht ins Wörterbuch aufgenommen werden. Unübersetzbare Texte : Texte, die nicht übersetzt werden können wie z.B. Eigennamen, müssen mit dem Kommentar untranslatable versehen werden. Sind weitere Hinweise im Kommentar nötig, beginnt der Kommentar mit untranslatable gefolgt von einem Zeilenumbruch. Der Text soll in diesem Fall nur in der deutschen Sprache angegeben werden. Abkürzungen im Namen eines MLKeys : Werden im Namen eines MLKeys bewusst Großbuchstaben als Abkürzungen für Teilworte verwendet, weil z.B. der Name sonst zu lang würde, so muss die Abkürzung nach folgendem Schema im Comment erläutert werden: {Abkürzung1} = {Begriff1}, {Abkürzung2} = {Begriff2} Beispiele: LBL_CCServicePort : Comment = CC = Cross Company LBL_CCNameDebit : Comment = CC = Cost Center Bezeichnung von MLKeys Normalfall Begriffe: LBL_{englische Bezeichnung} Beispiel: LBL_Search Sätze: MSG_{GUID} Beispiel: MSG_f39ceca46b3341ee8b9862d34cfd06b6 Einheiten LBL_{englische Bezeichnung}_Unit Beispiel: LBL _mm_Unit Zeichen LBL_{englische Bezeichnung}_Sign Beispiel: LBL_Plus_Sign für den Text „+“ Ziffern LBL_{englische Bezeichnung}_Digit oder LBL_{englische Bezeichnung}_Digits (Plural) Beispiele: LBL_Nine_Digit für den Text „9“, LBL_EightOClock_Digits für den Text „08:00“ Prozentzeichen LBL_{englischer Prefix}Percent (kein Unterstrich) Beispiel: LBL_DiscountPercent (de = „Skonto %“, en = „Discount %“) Abkürzungen / Ausgeschriebene Texte Wenn für einen englischen Begriff im deutschen am häufigsten eine abgekürzte Schreibweise verwendet wird, so wird der MLKey für den Text mit Abkürzung normal mit LBL_{englische Bezeichnung} benannt. Wird parallel dazu auch der im deutschen (oder anderen Fremdsprachen) ausgeschriebene Text benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Full benannt. Wird zu einem Begriff, zu dem es schon eine ausgeschriebene Schreibweise gibt eine Abkürzung benötigt, so wird der MLKey mit LBL_{englische Bezeichnung}_Abbrev bezeichnet. Beispiele: LBL_ClerkScanner (de = „SB-Scanner“), LBL_ClerkScanner_Full (de = „Sachbearbeiter Scanner“) LBL_Reminder (de = „Wiedervorlage“), LBL_Reminder_Abbrev (de = „Wiedervorl.“) Spezialfall: Ein Buchstabe als Abkürzung LBL_{englische Bezeichnung}_Char Beispiele: LBL_Order_Char (de = „B“, en= „O“) LBL_Container_Char (de = „B“, en = „C“) Beschriftung von Mini-Buttons LBL_{englische Bezeichnung}_Mini Wird ein MiniButton (Control Style = MiniEmpty) auf einer Maske mit einer Caption von 1 bis 2 Buchstaben versehen (die typischerweise eine Abkürzung darstellen), so wird der MLKey dazu mit der eigentlichen Bezeichnung, ergänzt um _Mini beschriftet. Dabei ist darauf zu achten, dass die Beschriftungen pro Sprache eindeutig sind. Beispiele: LBL_Customer_Mini (de = „K“, en = „Cu“) LBL_CrossOver_Mini (de = „C“, en = „Cr“) Zwei unterschiedliche deutsche Begriffe, die im Englischen gleich heißen Wenn zwei unterschiedliche Begriffe im englischen durch den gleichen Text beschrieben werden, so werden die Bezeichnungen der MLKeys durch Anhängen eines Zählers beginnend mit 1 im Format _{Zähler} unterschieden. Beispiel: de = „Herkunft“, en = „Source“ => MLKey = LBL_Source de = „Quelle“, en = „Source“ => MLKey = LBL_Source_1 Tooltips Wenn ein Tooltip eindeutig einem einfachen Begriff zugeordnet werden kann, so wird der MLKey mit TTT_{englische Bezeichnung} benannt. Andernfalls wird das Format TTT_{GUID} verwendet. Beispiele: TTT_Fatal (de = „Fatale Einträge anzeigen“) `TTT_584b58008ed04cd2b40b78b70e52402c' (de = „Wert für die Kreditorenvorerfassung-Pufferzeit definieren.“) Note Wenn man einen Tooltip verwenden möchte, zu dem es bereits einen exakt passenden LBL_ Eintrag gibt, so soll dazu kein TTT_ Eintrag angelegt werden! Diese Einträge wären sonst ja logisch äquivalent. Kleingeschriebene Begriffe Sollte man ein Text (z.B. wegen einer Verwendung in einer Textcollection) berechtigterweise klein geschrieben sein und es soll trotzdem ein sprechender Key generiert werden, so ist dieser ebenfalls klein zu schreiben. Beispiel: de = „eins“, en = „one“ => MLKey = LBL_one Texte Alle Texte in allen Sprachen beginnen mit einem großen Buchstaben. Ausnahmen: Abgekürzte Einheiten (z.B. mm) Einträge in Textcollections, soweit diese zwingend alle klein geschrieben werden müssen. Vor Satzzeichen werden keine Leerzeichen verwendet. Ganze Sätze werden mit einem Satzzeichen beendet. Im Englischen werden bei Texten mit bis ca. 4 Worte (Beschriftungen von Eingabefeldern, Menüs, Buttons usw.) alle Worte bis auf Füllwörter wie of , to , in , ... groß geschrieben."
  },
  "doc/mlkey/draft.html": {
    "href": "doc/mlkey/draft.html",
    "title": "Text-Collections",
    "keywords": "Text-Collections Text-Collections arbeiten ebenfalls mit MLKeys. Im Grunde sind sie eine Auflistung von MLKeys. Arbeitsweise Das Wörterbuch wird in xml-Dateien gespeichert. Diese liegen im Broker-Verzeichnis im Ordner lang . Die Dateien werden separat prop Package und Sprache mit dem folgenden Datei-Namen abgelegt: <package>.<iso>.lang.xml Beispiel: <broker-directory> |--lang | |--CustomPackage.de.lang.xml | |--eNVenta.de.lang.xml | |--eNVenta.en.lang.xml | |--eNVenta.fr.lang.xml | |--SystemPackage.de.lang.xml | |--SystemPackage.en.lang.xml Zur Laufzeit werden diese Dateien bei Bedarf einmalig für die benötigten Sprachen eingelesen. Dabei wird die Package-Hierarchie berücksichtigt."
  },
  "doc/html-client/funktionsumfang.html": {
    "href": "doc/html-client/funktionsumfang.html",
    "title": "Funktionsumfang",
    "keywords": "Funktionsumfang Der HTML-Client befindet sich noch in der agilen Entwicklung. Verglichen mit dem ausgereiften JavaClient ist der Funktionsumfang des HTML-Clients noch überschaubar. Neue Funktionen und die Unterstützung für weitere Controls werden kontinuierlich weiter entwickelt und veröffentlicht. Note Wird in diesem Kapitel etwas nicht erwähnt, wie z.B. ein Property eines Controls, eine Action oder andere Client-Funktionalitäten, so muss davon ausgegangen werden, dass diese noch nicht unterstützt werden. Handhabung von nicht unterstützten Funktionalitäten Es gibt im Form Designer oder im Code Editor von Framework Studio keine Limitierungen, die den Entwickler auf den Funktionsumfang des HTML-Clients einschränken. Werden Controls, Actions oder anderweitige Funktionalitäten genutzt, die vom HTML-Client nicht unterstützt werden, so werden diese (so weit es möglich ist) vom Client ignoriert. Wenn z.B. ein Grid-Control in ein Form eingebaut wird, so wird dieses erst garnicht vom HTML-Client interpretiert. Dasselbe gilt für nicht unterstützte Properties an Controls. Frameset Der HTML-Client besitzt kein Frameset. Alle geöffneten Forms werden in einer einzigen Liste organisiert. Es ist irrelevant, welchem Frame ein Form in einem Workflow zugeordnet ist. MessageBox und ExceptionBox Werden vollständig unterstützt inkl. Buttons, Icons, DialogResult und EventHandler. Werden im Client als modale Popups angezeigt. Modale Forms Modale Forms, die das Wechseln zu einem anderen Form unterdrücken, werden vom HTML-Client vollflächig angezeigt. Dabei wird der Menü-Button ausgeblendet. Verhalten beim Drücken des „Zurück“-Button auf einem mobilen Gerät: Wenn am Form das Property IsCloseIconVisible auf true gesetzt ist, wird der modale Dialog geschlossen. Wird dem Form über die Action SetCloseButton ein Button zugewiesen, dessen Click-Event beim Schließen ausgelöst werden soll, wird dies beim Drücken des Zurück-Button ebenfalls ausgelöst. Drag & Drop Drag & Drop und alle damit verbundenen Events werden vom HTML Client nicht unterstützt. Shortcuts und ToolTips Da für den HTML-Client die mobile Welt im Vordergrund steht, werden Shortcuts und ToolTips noch nicht unterstützt, da diese auf einem Handy bzw. Tablet keinen Sinn machen. Control Styles Control Styles werden für alle im HTML-Client verfügbaren Controls unterstützt. Wird im Form Designer einem Control ein Control Style zugeordnet, so werden dessen Properties korrekt interpretiert bzw. die Property-Hierarchie beachtet. Actions Es werden derzeit folgende Actions unterstützt: SetEnabled SetVisible SetCloseButton ScanBarcode Zurück-Button auf mobilen Geräten Mobile Geräte (z.B. Android) besitzen teilweise einen Zurück-Button. Der HTML Client unterstützt diesen kontextabhängig. Es gibt drei Prioritätsebenen, die nacheinander durchlaufen werden. Wird in einer Ebene auf das Drücken des Zurück-Buttons reagiert, so werden die darunter liegenden Ebenen nicht mehr behandelt. Die Ebenen geordnet nach Priorität sind: Overlays Modale Dialoge Normale Anzeige Overlays Als Overlay definiert sich alles, was sich mit einem ausgegrauten Hintergrund über die restliche Anzeige legt, wie z.B. MessageBoxen oder die ComboBox-Auswahl. Wenn ein Overlay geöffnet ist und der Zurück-Button gedrückt wird, wird das Overlay geschlossen. Eine MessageBox kann nur durch den Zurück-Button geschlossen werden, wenn ein Abbrechen-Button vorhanden ist. Modale Dialoge Modale Dialoge können mit dem Zurück-Button geschlossen werden, wenn das Property IsCloseIconVisible am Form auf true gesetzt ist. Wurde dem Form über die Action SetCloseButton ein Button mit einem Click-Event zugeordnet, so wird beim Drücken des Zurück-Buttons das Click-Event ausgelöst. Normale Anzeige Befindet sich der HTML Client in einem normalen Form, wird beim Drücken des Zurück-Buttons das Beenden der Application angestoßen, was mit der Rückfrage, ob die Session beendet werden soll, einher geht. Befindet sich der HTML Client im Broker-Auswahldialog, wird die Anwendung ohne Rückfrage geschlossen."
  },
  "doc/tables/dbrun_config.html": {
    "href": "doc/tables/dbrun_config.html",
    "title": "dbRun_Config (Business-Datenbank)",
    "keywords": "dbRun_Config (Business-Datenbank) Diese Tabelle beinhaltet die Konfigurationen für den automatischen Datenbank-Update. Die FS-Update-Logik erzeugt und aktualisiert diese Tabelle automatisch. Die Einstellungen müssen manuell per SQL vorgenommen werden. Wenn keine Einstellung existiert, dann zieht automatisch die Default-Einstellung. Spalte Beschreibung ConfigKey Schlüssel (siehe unten) ConfigValue Wert (siehe unten) ConnectionGroup Der Name der Connection-Group. Bei <NULL> zieht die Einstellung für alle Connection-Groups. Wenn für eine Connection-Group eine Konfiguration angegeben ist, dann hat diese Priorität. ConfigKey UNICODE Dieser ConfigKey stellt das Unicode-Verhalten des Update-Assinstenten ein. In ConfigValue sind folgende Werte zulässig: Disabled (Default) Neue Spalten werden ASCII (VARCHAR/ CLOB) angelegt. Enabled Neue Spalten werden Unicode (NVARCHAR/ NCLOB) angelegt. Adjust Bestehende Spalten werden auf Unicode umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. Important Diese Einstellung hat zur Folge, dass die GESAMTE Datenbank angefasst wird. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. ConfigKey LOB Dieser ConfigKey steuert, wie der Update-Assistent mit Langtext-Spalten umgehen soll. In ConfigValue sind folgende Werte zulässig Normal (Default) Neue Spalten werden mit LOB-Typen angelegt. Adjust Bestehende Spalten werden auf LOB-Typen umgestellt. Dies erfolgt im Schritt 4 des Update-Assistenten. SQL-Server: text => varchar(max) / image => varbinary(max) Oracle: varchar2(2000) => CLOB Important ACHTUNG! Diese Einstellung hat zur Folge, dass große Teile der Datenbank angefasst werden. Dies bedeutet ggf. einen erheblichen Zeitaufwand und verursacht ein großes Volumen an Transaktion-Protokollen. Bei Oracle kann sein ggf. sein, dass einige ältere Programme (wie z.B. SQL-Business) nicht mit dem Datentyp CLOB umgehen können. In diesem Fall muss der Schalter auf Normal gesetzt werden."
  },
  "doc/sql/syntax.html": {
    "href": "doc/sql/syntax.html",
    "title": "SQL-Syntax",
    "keywords": "SQL-Syntax Framework Studio übersetzt alle SQL-Statements in die Syntax der verwendeten Ziel-Datenbank. Dazu werden alle Statements geparsed und für die Ziel-Datenbank wieder neu zusammengesetzt."
  },
  "doc/sql/alpha-funktionen.html": {
    "href": "doc/sql/alpha-funktionen.html",
    "title": "Alphanumerische Funktionen",
    "keywords": "Alphanumerische Funktionen LENGTH LENGTH ( <text> ) Liefert die Länge des Ausdrucks LOWER LOWER ( <text> ) Text in Kleinbuchstaben. UPPER UPPER ( <text> ) Text in Großbuchstaben. LTRIM LTRIM ( <text> ) Schneidet die linken Leerzeichen der Zeichenkette ab. RTRIM RTRIM ( <text> ) Schneidet die rechten Leerzeichen der Zeichenkette ab. REPLACE REPLACE ( <text>, <search text>, <replace text> ) Ersetzt im übergebenen Text den Search-Text durch Replace-Text. SUBSTRING SUBSTRING ( <text>, <number start>, <number length> ) Gibt den Teil einer Zeichenkette zurück."
  },
  "doc/sql/aggr-funktionen.html": {
    "href": "doc/sql/aggr-funktionen.html",
    "title": "Aggregat-Funktionen",
    "keywords": "Aggregat-Funktionen COUNT COUNT ( <Expression> ) Liefert die Anzahl. MIN MIN ( <Expression> ) Liefert das Minimum. MAX MAX ( <Expression> ) Liefert das Maximum. SUM SUM ( <Number Expression> ) Liefert den Summe. AVG AVG ( <Number Expression> ) Liefert den Durchschnitt. VAR VAR ( <Number Expression> ) Liefert die Varianz. STDEV STDEV ( <Number Expression> ) Liefert die Standardabweichung."
  },
  "doc/mlkey/mlstring.html": {
    "href": "doc/mlkey/mlstring.html",
    "title": "MLString",
    "keywords": "MLString Framework Studio bietet eine durchgängige Unterstützung für die Mehrsprachigkeit. An allen Stellen, an denen für den Anwender sichtbare Beschriftungen, Tooltips oder Meldungstexte gepflegt werden bietet Framework Studio einen Editor zur Bearbeitung von mehrsprachigen Texten (Multi Language String / MLString ) an. Der Editor wird in Form einer Tabelle angezeigt, in der die Verschiedenen Sprachen des Textes angezeigt und bei Bedarf auch bearbeitet werden. Die fett gedruckten Angaben sind an dieser Stelle überschrieben. Die normal gedruckten Angaben sind aus dem Basis-Package oder dem Basis-Record geerbt. Siehe auch Abschnitt Vererbung . An erster Stelle steht immer der MLKey . Dieser stellt einen Verweis auf das Wörterbuch dar. Es kann direkt ein MLKey eingeben werden oder mit dem Auswahl-Button ein Such-Dialog geöffnet werden. Dabei handelt es sich um den voll funktionsfähigen Multilanguage Text Editor erweitert um eine Auswahl-Funktion. In diesem Dialog können, wenn kein passender MLKey gefunden wurde, auch ein neuer Key erfasst werden. Die Texte in den einzelnen Sprachen werden im Designer und auch zur Laufzeit der Anwendung aus dem Wörterbuch ermittelt. Die angezeigten Sprachen und deren Reihenfolge können in den Options mit der Einstellung Languages in designer eingestellt werden. Important Ist ein MLKey angegeben, dann ist es davon abzuraten, einzelne Texte zu überschreiben. Im Property-Grid wird der MLString in einer Zeile dargestellt, die zur Anzeige der einzelnen Sprachen erweitert werden kann. Die einzeilige Anzeige stellt einen kombinierten Text in Format @{MLKey} - {deutscher Text} dar. In diesem Text man auch direkt mit vorangestellten @ -Zeichen einen anderen MLKey eintragen - z.B. @LBL_ArticleID . Ein MLKey kann auch (wie oben beschrieben) am entsprechenden MLKey-Eintrag eingetragen oder ausgewählt werden. Vererbung Mit den verschiedenen Records in Framework Studio werden auch die entsprechenden MLStrings vererbt. Dadurch werden im Idealfall die am Metadatentyp definierten Texte über die komplette Kette bis hin zu den Form-Controls durchgereicht. Ein vererbter Text kann an jeder beliebigen Stelle in der Kette überschrieben werden. Es gibt 2 Möglichkeiten: Einen anderen MLKey zuweisen Damit werden alle anderen Texte aus der Basis inkl. MLKeys und den überschriebenen Texten ausgeblendet. Auch wenn der neue MLKey z.B. keinen Text für fr definiert hat, wird ein in der Basis definierter fr Text ausgeblendet. Einen einzelnen Text überschreiben: Warning Darauf sollte möglichst verzichtet werden. Wenn lediglich die Übersetzung gepflegt wird, dann erfolgt dies besser im Wörterbuch. Wenn eine abweichende Bedeutung gewünscht ist, dann sollte ein anderer MLKey angegeben werden. Das überschreibt nur den Text der entsprechenden Sprache. Die anderen nicht überschriebenen Sprachen werden weiter aus der Basis gezogen. Caution In der eNVenta/WS Standard-Entwicklung ist das verboten. Das folgende Bild zeigt eine Vererbungs-Hierarchie. Die Pfeile stellen den Weg dar, über den der Text für das Control ermittelt wird. Dabei wird hier die Sprache fr mit den Fallback-Sprachen en und de verwendet. Der erste Text der auf diesem Weg gefunden wird, wird ausgegeben."
  },
  "articles/release-4-2.html": {
    "href": "articles/release-4-2.html",
    "title": "Release-Information Framework Studio 4.2",
    "keywords": "Release-Information Framework Studio 4.2 4.2 Beta 1 (13.09.2019) Die Auslieferung umfasst das Paket FS_4.2.0_Beta_1_Setup_x64 Alle anderen Pakete wie Print-Service, Client-Launcher und Requirements können weiter aus Framework Studio 4.0 verwendet werden. Neuerungen Die Neuerungen finden Sie unter Neuheiten 4.2 Korrigierte Fehler Neben den Fehlern, die bereits bis einschließlich Framework Studio 4.0.14 korrigiert wurden, wurden in Framework Studio 4.2 die folgenden Fehler korrigiert: 2019089003 - Doku-System : Ausgeblendete Controls (hidden/Collapsed) werden im Doku-Screenshot nicht gerendert. 2019099502 - Repository : Alle Sublabeled Tabellen sollen aus Performance-Gründen mit einem Index auf die PackageID-Spalte versehen werden. Die folgenden Fehler wurden bereits für die Version 4.0.15 korrigiert und sind in der 4.2 Beta 1 ebenfalls korrigiert: 2019099320 - Java-Client : Im Metal Look & Feel wird an der aktiven Tab-Page eine falsche Border gezeichnet. 2019068382 - Java-Client : Unter Linux und MacOS werden die Menüs falsch dargestellt. Auf nicht-Windows-Systemen wird empfohlen, das Look & Feel \"Metal\" zu verwenden. Im Look & Feel \"Default\" können weiterhin Probleme auftreten. 2019099428 - Java-Client : Wird eine Datei sehr schnell per Drag&Drop auf die Anwendung gezogen, kann es nach Auswahl einer D&D-Aktion zu einer \"Java-Exception: null\" kommen. 2019047700 - IDE : Suche: Combobox zur Einschränkung auf den Elementtyp wird nicht angezeigt. 2017099728 - IDE : Im Service-Release ist der Get- und Set-Method-Code von Properties manchmal fälschlicherweise editierbar. 2019099379 - IDE : Wird im Run-Wizard bei einer Connection-Group das Runtime-Repository angegeben, und die dazugehörigen Connection steht nicht auf \"Imported\", dann prüft der der Update-Assistent von eNVenta diese Datenbank auf Änderungen. Dabei werden auch die Trigger des Repositories erkannt und zum Deaktivieren angeboten. Das hat erhebliche Fehlfunktionen im Repository zur Folge. Repository-Trigger werden jetzt erkannt und vom Update-Assistenten ignoriert. 2019088935 - Package-Merge : Die Eigenschaft \"Include Base Reports\" an ReportDocumentTypes soll generell nicht übertragen werden. Der Wert im Ziel-Package muss unverändert erhalten bleiben."
  },
  "doc/database/ml-column.html": {
    "href": "doc/database/ml-column.html",
    "title": "ML-Column",
    "keywords": "ML-Column Framework Studio bietet einen Mechanismus, um Dateninhalte in mehreren Sprachen zu speichern. Eine beliebige Tabellen-Spalte, in der eine Zeichenkette abgelegt ist, kann im Tabelleneditor als MLColumn markiert werden. Vorraussetzung ist jedoch, dass die Tabelle die Spalte FSRowID enthält, weil diese als eindeutige Referenz auf den Datensatz benötigt wird. Ist eine Tabellen-Spalte als MLColumn gekennzeichnet, dann werden die fremdsprachigen Texte in der Tabelle dbRun_MLStrings abgelegt. Die normale Tabellen-Spalte beinhaltet die Texte in Default-Sprache. Caution Fehlt einer Component das Property ROWID (mit Mapping auf die DB-Column FSRowID ), ist der Mechanismus für diese Component deaktiviert. Join-Components können keine ML-Columns aus mehreren Tabellen verabreiten, da die Component lediglich ein ROWID-Property betrachtet. Werden mehrere ROWID-Properties aus verschiedenen Tabellen eingebunden, dann ist es Zufall, welche ROWID für den MLColumn-Mechanismus herangezogen wird. Customizing-Package Die Eigenschaft MLColumn kann im Customizing-Package gesetzt werden. Somit kann man in Kunden-Umgebungen den Mechanismus gezielt für die gewünschten Tabellen-Spalten aktivieren. Anwendung in Default-Sprache Die Default-Sprache ist de - außer man definiert über die Tabelle ML_Config eine andere Default-Sprache. Wird die Anwendung in der Default-Sprache gestartet, dann arbeitet Framework Studio mit der ganz normalen Spalte der Tabelle - ohne jegliche Sonder-Logik. Die fremdsprachigen Texte können nicht beeinflusst werden. Ändert man einen Text, dann bleiben die ggf. existierenden Übersetzungen unverändert erhalten. Bei Bedarf müsste man die Anwendung anschließend in den Fremdsprachen starten und den gewünschten Text dort ebenfalls anpassen. Anwendung in Fremdsprache Startet man die Anwendung mit einer Fremdsprache, dann greifen besondere Mechanismen. Die entsprechenden Component-Properties behandeln dann ausschließlich den fremdsprachigen Text mit einem Fallback auf die Default-Sprache. Die ML-Column-Logik wird von den ganz normalen Component-Properties behandelt. Dadurch wirkt sie sich automatisch auf alle Bereiche der Anwendung aus - inkl. Form-Databinding und Reporting. Load : Beim Zugriff auf das entsprechende Component-Property wird der Text aus der Tabelle dbRun_MLStrings gelesen. Existiert dort kein Eintrag, wird der Text der Default-Sprache aus der normalen Tabellen-Spalte verwendet. Update : Wird der Text geändert, dann wird der Eintrag in der entsprechenden Fremdsprache überschrieben. Der Text in der Default-Sprache kann nicht verändert werden. Wird der fremdsprachige Text geleert, dann wird beim Save der Component der Eintrag aus der Übersetzungs-Tabelle gelöscht und das Component-Property fällt auf die Default-Sprache zurück. Insert : Beim Anlegen eines neuen Datensatzes wird der eingegebene Text sowohl in der normalen Tabelle als auch in der Fremdsprache gespeichert. Delete : Wird der Datensatz aus der Datenbank gelöscht, dann werden auch alle zu dieser FSROWID gespeicherten Texte aus der Übersetzungs-Tabelle gelöscht. Important Die Sprache ist mit dem Start der Anwendung am GlobalObject festgelegt. Es gibt keine Möglichkeit, zur Laufzeit auf die Sprache Einfluss zu nehmen oder die Texte in einer spezifischen Sprache zu behandeln. Tips für Entwickler Finden von MLColumns Wird eine DBColumn als MLColumn gekennzeichnet wird dafür der folgende Code generiert: public class Package_FSColumnName : FS.Demo.MDT.ArticleName { public Package_FSColumnName() { this.m_IsMLColumn = true; } } Dadurch können alle MLColumns mit dem Text this.m_IsMLColumn = true; über die Code-Suche gefunden werden. Dabei die Suche auf die DBTables einschränken."
  },
  "doc/html-client/android-app.html": {
    "href": "doc/html-client/android-app.html",
    "title": "Android App",
    "keywords": "Android App Für die volle Integration des HTML-Clients in die mobile Welt, stellen wir im Google Play Store den Client als Android App zur Verfügung. Diese ist vom Funktionsumfang equivalent zur Browser-Version. Name der App : Framework Studio Mobile Client Store Link : https://play.google.com/store/apps/details?id=com.fs.htmlclient Note Wir können derzeit noch keine Aussagen zu einer Veröffentlichung der App für iOS treffen. Einrichten eines Brokers Es muss natürlich definiert werden, mit welchem Broker sich der Mobile Client verbinden soll. Nach dem Start der App wird der Login angezeigt. Über den Button „+ New“ können beliebig viele Broker zur Liste hinzugefügt werden. Es ist auch möglich, Urls von Development Brokern hinzuzufügen. Dabei ist zu beachten, dass der Mobile Client nur auf den Development Broker zugreifen kann, wenn dieser über das Netzwerk erreichbar ist. Dazu muss Framework Studio mit Administrator-Rechten ausgeführt werden. Ob der Development Broker vom Netzwerk aus zugreifbar ist, kann über das Tray-Icon geprüft werden:"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Format.html",
    "title": "Property Format",
    "keywords": "Property Format Format Gibt das von der Spalte zu verwendende Format zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public FrameworkFormatMask? Format { get; set; } Property Value Type Description System.Nullable < FrameworkFormatMask >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.FormatPattern.html",
    "title": "Property FormatPattern",
    "keywords": "Property FormatPattern FormatPattern Gibt das von der Spalte zu verwendende FormatPattern zurück oder legt dieses fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public string FormatPattern { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxSize.html",
    "title": "Property MaxSize",
    "keywords": "Property MaxSize MaxSize Gibt die maximale Größe, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxSize { get; set; } Property Value Type Description System.Nullable < System.Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.MaxScale.html",
    "title": "Property MaxScale",
    "keywords": "Property MaxScale MaxScale Gibt die Anzahl der Nachkommastellen, der in der Spalte darzustellenden Daten, zurück oder legt diese fest. Wird diese Eigenschaft festgelegt, so wird der Wert, der unter Umständen automatisch aus dem zugeordneten Property oder dem PropertyMdt ermittelt werden kann, übersteuert. Declaration public int? MaxScale { get; set; } Property Value Type Description System.Nullable < System.Int32 >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.IsEditable.html",
    "title": "Property IsEditable",
    "keywords": "Property IsEditable IsEditable Gibt die Editierbarkeit der Spalte zurück oder legt diese fest. Declaration public bool? IsEditable { get; set; } Property Value Type Description System.Nullable < System.Boolean >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleDescription.html",
    "title": "Method GetRoleDescription",
    "keywords": "Method GetRoleDescription GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleDescription(string roleName) Parameters Type Name Description System.String roleName Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetRoleCaption.html",
    "title": "Method GetRoleCaption",
    "keywords": "Method GetRoleCaption GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. Declaration public string GetRoleCaption(string roleName) Parameters Type Name Description System.String roleName Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.GetUserUnits.html",
    "title": "Method GetUserUnits",
    "keywords": "Method GetUserUnits GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Declaration public List<string> GetUserUnits() Returns Type Description System.Collections.Generic.List < System.String >"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.RegisterUnits.html",
    "title": "Method RegisterUnits",
    "keywords": "Method RegisterUnits RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service. Declaration public void RegisterUnits(IEnumerable<KeyValuePair<string, string>> units) Parameters Type Name Description System.Collections.Generic.IEnumerable < System.Collections.Generic.KeyValuePair < System.String , System.String >> units Key = unit id / Value = unit name"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.html",
    "title": "Class AUHelper",
    "keywords": "Class AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. Inheritance System.Object AUHelper Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AUHelper Examples this.Global.AUHelper.ChangePassword( sOld, sNew ); Properties AuthenticationEnabled Gibt an, ob die Authentication in der Anwendung aktiviert ist. Eine Developerlizenz deaktiviert die Benutzerauthentifizierung automatisch. IsDefaultUser Gibt an, ob der authentifizierte Benutzer der Default User ist. UnitKey Gibt Schlüsselwert der Unit (Geschäftseinheit) zurück, an der der Benutzer (mit der Methode IdentifyUnit(String) ) angemeldet wurde. Units Gibt eine Enumeration von Schlüssel-Wert-Paaren zurück, welche alle an dieser Applikation zur Verfügung stehenden Geschäftseinheiten repräsentieren. Username Gibt den Namen das momentan authentifizierten Benutzers zurück. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. UserTokenAsString Gibt den Token zurück, der bei der Authentifizierung des Benutzers am Authentication-Service gelöst wird. Ist die Authentifikation ausgeschaltet, wird String.Empty zurück gegeben. Methods ChangePassword(String, String) Ändert das Passwort des momentan angemeldeten Benutzers. ChangePasswordChecked(String, Byte[], String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. ChangePasswordChecked(String, String, String, out AUHelper.Message, String) Ändert das Passwort für den angegebenen Benutzer unter Angabe einer Login Information. In der als out Parameter angegebenen Message wird der Erfolg bzw. Grund für den Misserfolg zurückgegeben. GetAllLanguages() Gibt eine Liste mit ISO Kürzeln aller an dieser Applikation bekannten Sprachen zurück. GetApplicationRoles() Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetApplicationRoles(Boolean) Gibt eine Liste mit den Namen aller Rollen zurück, welche an dieser Applikation zur Verfügung stehen. GetGrantedLanguages() Gibt eine Liste mit ISO Kürzeln der Sprachen zurück, die zur Verfügung stehen und durch die verwendeten Lizenzen freigegeben sind. GetPackages() Gibt eine Liste zurück, die alle Packages der Applikation in der Verwendungsreihenfolge enthält. GetRoleCaption(String) Gibt die Bezeichnung (=anzuzeigender Name) der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetRoleDescription(String) Gibt die Beschreibung der Rolle zurück, die über den technischen Namen roleName identifiziert wird. GetUserRoles() Gibt eine Liste mit den technischen Namen der Rollen zurück, die dem aktuell angemeldeten Benutzer zugeordnet sind. GetUserUnits() Gibt eine Liste mit Schlüsselwerten der Units (Geschäftseinheiten) zurück, welche für den aktuell angemeldeten Benutzer freigeschaltet sind. Granted(AccessUnit) Gibt aus, ob auf die übergebene AccessUnit das Recht Access besteht. Granted(AccessUnit, AUPermissionType) Gibt aus, ob ein bestimmtes Recht an einer AccessUnit besteht. IdentifyDefaultUser() Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyDefaultUser(out AUHelper.Message) Authentifiziert den in der Application hinterlegten Default User. Dazu wird der Authentication Service kontaktiert. IdentifyUnit(String) Wählt die Geschäftseinheit (Unit) mit dem angegebenen Schlüsselwert unitKey aus. Dadurch werden Rollen und Berechtigungen automatisch neu gesetzt. IdentifyUser(out AUHelper.Message, String, String, ref String, Boolean) Authentifiziert den übergebenen Benutzer. Dazu wird der Authentication Service kontaktiert. LicenseGranted(AccessUnit) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt LicenseGranted(AccessUnit, AUPermissionType) Gibt aus, ob die vorhandene Lizenz den Zugriff auf die übergebene AsccessUnit erlaubt. RegisterUnits(IEnumerable<KeyValuePair<String, String>>) Registriert die angegebenen Geschäftseinheiten (Units) am Authentication Service."
  },
  "api/FrameworkSystems.FrameworkBase.html": {
    "href": "api/FrameworkSystems.FrameworkBase.html",
    "title": "Namespace FrameworkSystems.FrameworkBase",
    "keywords": "Namespace FrameworkSystems.FrameworkBase Classes BrowserCommand Bei einem Link, der im Browser-Control angeklickt wird, können Link-Kommandos mit Parametern hinterlegt werden, die vom Broker ausgewertet werden. Diese Klasse stellt Konstanten und Methoden bereit, um solche Link-Kommandos zu erstellen und auszuwerten. DevFrameworkObject TODO! Basisklasse für alle Components die über das FrameworkStudio erzeugt werden. FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. Enums AUPermissionType Kann z.B. in Granted(AccessUnit, AUPermissionType) verwendet werden. EditorStyle FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben)"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSshort.html",
    "title": "Struct FSshort",
    "keywords": "Struct FSshort TODO! Summary description for FSshort. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSshort : IFSshort, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde. Declaration public virtual string Text { get; protected set; } Property Value Type Description System.String Remarks Lediglich die Texte in den Formaten TextPlain und TextUriList werden schon im OnCanDrop gefüllt."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.TextFlavorData.html",
    "title": "Class TextFlavorData",
    "keywords": "Class TextFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang einen Text dar. Inheritance System.Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class TextFlavorData : FlavorData Remarks In einem Drag&Drop-Vorgang können mehrere TextFlavorData Objekte (zu unterschiedlichen Textformaten) enthalten sein. Properties Text Gibt im OnDrop Eventhandler den Text zurück, wenn im OnCanDrop Eventhhandler FillOnDrop() aufgerufen wurde."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.ColumnTextAlign.html",
    "title": "Enum GridColumnDefinition.ColumnTextAlign",
    "keywords": "Enum GridColumnDefinition.ColumnTextAlign Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public enum ColumnTextAlign Fields Name Description Center Left Right"
  },
  "api/FrameworkSystems.FrameworkBase.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkBase.EditorStyle.html",
    "title": "Enum EditorStyle",
    "keywords": "Enum EditorStyle Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum EditorStyle Fields Name Description CheckBox ComboBox Editfield MultilineEditfield"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.-ctor.html",
    "title": "Constructor FrameworkApplicationException",
    "keywords": "Constructor FrameworkApplicationException FrameworkApplicationException(String) Declaration public FrameworkApplicationException(string msg) Parameters Type Name Description System.String msg FrameworkApplicationException(String, Int32) Declaration public FrameworkApplicationException(string msg, int severity) Parameters Type Name Description System.String msg System.Int32 severity FrameworkApplicationException(String, Exception) Declaration public FrameworkApplicationException(string msg, Exception innerEx) Parameters Type Name Description System.String msg System.Exception innerEx FrameworkApplicationException(String, Int32, Exception) Declaration public FrameworkApplicationException(string msg, int severity, Exception innerEx) Parameters Type Name Description System.String msg System.Int32 severity System.Exception innerEx"
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.Severity.html",
    "title": "Property Severity",
    "keywords": "Property Severity Severity Definiert den Schweregrad der Exception. Declaration public int Severity { get; } Property Value Type Description System.Int32 Remarks Diese Information wird momentan nicht ausgewertet."
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkApplicationException.html",
    "title": "Class FrameworkApplicationException",
    "keywords": "Class FrameworkApplicationException Exceptions die vom Framework geworfen werden und einen erwarteten Fehler darstellen sollten von dieser Klasse sein. Der Broker gibt diese dann als Fehler ohne StackTrace an den Client weiter. Inheritance System.Object System.Exception System.ApplicationException FrameworkApplicationException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class FrameworkApplicationException : ApplicationException, ISerializable, _Exception Constructors FrameworkApplicationException(String) FrameworkApplicationException(String, Exception) FrameworkApplicationException(String, Int32) FrameworkApplicationException(String, Int32, Exception) Properties Severity Definiert den Schweregrad der Exception."
  },
  "api/FrameworkSystems.FrameworkBase.MultiLanguage.html": {
    "href": "api/FrameworkSystems.FrameworkBase.MultiLanguage.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.MultiLanguage Classes DevMLString TODO!"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.html",
    "title": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab",
    "keywords": "Namespace FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Classes FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden"
  },
  "api/FrameworkSystems.FrameworkControls.html": {
    "href": "api/FrameworkSystems.FrameworkControls.html",
    "title": "Namespace FrameworkSystems.FrameworkControls",
    "keywords": "Namespace FrameworkSystems.FrameworkControls Classes ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). GridColumnDefinition Diese Klasse definiert eine Spalte in einem Grid. Grids können zur Laufzeit mit weiteren Spalten zu existierenden Properties ergänzt werden. Diese Spalten werden als dynamische Spalten bezeichnet. Außerdem können dynamische Spalten zur Laufzeit auch wieder aus einem Grid entfernt werden. Enums GridColumnDefinition.ColumnSortOrder GridColumnDefinition.ColumnTextAlign"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Metadatatype",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Metadatatype Classes MLContainer TODO! Structs FSbool Summary description for FSbool. FSbyte TODO! Summary description for FSbyte. FSbyteArray TODO! Summary description for FSbyteArray. FSDateTime TODO! Summary description for FSDateTime. FSdecimal TODO! Summary description for FSdecimal. FSdouble TODO! Summary description for FSdouble. FSfloat TODO! Summary description for FSfloat. FSint TODO! Summary description for FSint. FSlong TODO! Summary description for FSlong. FSshort TODO! Summary description for FSshort. FSstring TODO! Summary description for FSstring. FSSystemGuid TODO! Summary description for FSSystemGuid. Interfaces IFSType Gemeinsames Interface für alle FS-Datentypen. Dieses stellt gemeinsame Eingenschaften wie IsNull und HasValue zur Verfügung."
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSfloat.html",
    "title": "Struct FSfloat",
    "keywords": "Struct FSfloat TODO! Summary description for FSfloat. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSfloat : IFSfloat, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.Converter",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.Converter Classes XmlConverter Diese Klasse bietet Methoden und Konstanten für das Auslesen und Erzeugen von Strings, welche per Xml zwischen Broker und Client ausgetauscht werden. Interfaces IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T ."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AccessUnit.html",
    "title": "Class AccessUnit",
    "keywords": "Class AccessUnit TODO! Inheritance System.Object AccessUnit Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] public sealed class AccessUnit"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSSystemGuid.html",
    "title": "Struct FSSystemGuid",
    "keywords": "Struct FSSystemGuid TODO! Summary description for FSSystemGuid. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSSystemGuid : IFSSystemGuid, IFSType, IComparable Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.FromXml.html",
    "title": "Method FromXml",
    "keywords": "Method FromXml FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T Declaration T FromXml(string xml) Parameters Type Name Description System.String xml Returns Type Description T"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.ToXml.html",
    "title": "Method ToXml",
    "keywords": "Method ToXml ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. Declaration string ToXml(T value) Parameters Type Name Description T value Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.IXmlConverter-1.html",
    "title": "Interface IXmlConverter<T>",
    "keywords": "Interface IXmlConverter<T> Dieses Interface definiert Methoden zum Konvertieren von Daten zwischen dem Xml-Format, welches zur Kommunikation zwischen Broker und Client verwendet wird, und dem generischen Typ T . Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public interface IXmlConverter<T> Type Parameters Name Description T Methods FromXml(String) Konvertiert die String-Darstellung des im Xml übertragenen Wertes in das entsprechende Objekt vom Typ T ToXml(T) Konvertiert das Objekt vom Typ T in die entsprechende String-Darstellung für die Übertragung des Wertes im Xml. See Also XmlConverter"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSstring.html",
    "title": "Struct FSstring",
    "keywords": "Struct FSstring TODO! Summary description for FSstring. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSstring : IFSstring, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.-ctor.html",
    "title": "Constructor GridColumnDefinition",
    "keywords": "Constructor GridColumnDefinition GridColumnDefinition() Declaration public GridColumnDefinition()"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.Property.html",
    "title": "Property Property",
    "keywords": "Property Property Property Gibt den punktseparierten Pfad zu dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Declaration public string Property { get; set; } Property Value Type Description System.String Examples Werden im Grid Elemente vom Typ cDynObj angezeigt, so bedeutet Property=\"oDevObj.sName\" , dass die Spalte Daten des Propertys sName des Unterobjekts oDevObj an cDynObj darstellt."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.PropertyMdt.html",
    "title": "Property PropertyMdt",
    "keywords": "Property PropertyMdt PropertyMdt Gibt den Metadatentyp von dem Property, für das eine Spalte definiert werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer PropertyMdt { get; set; } Property Value Type Description MLContainer Remarks Wenn die Eigenschaft ComponentType nicht gesetzt werden muss, muss diese Eigenschaft ebenfalls nicht gesetzt werden. Die Werte können dann automatisch über Reflection ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditorStyle.html",
    "title": "Property EditorStyle",
    "keywords": "Property EditorStyle EditorStyle Gibt den zu verwendenden Darstellungstyp ( Editfield , CheckBox , ...) zurück oder legt diesen fest. Declaration public EditorStyle? EditorStyle { get; set; } Property Value Type Description System.Nullable < EditorStyle >"
  },
  "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkControls.GridColumnDefinition.EditStyle.html",
    "title": "Property EditStyle",
    "keywords": "Property EditStyle EditStyle Gibt den zu verwendenden Combobox-Typ ( FreeTextInput , ListValuesInput ) einer Spalte, deren EditorStyle auf ComboBox festgelegt wurde, zurück oder legt diesen fest. Declaration public ComboEditStyle? EditStyle { get; set; } Property Value Type Description System.Nullable < ComboEditStyle >"
  },
  "doc/html-client/index.html": {
    "href": "doc/html-client/index.html",
    "title": "HTML-Client (Beta)",
    "keywords": "HTML-Client (Beta) Neben dem Java Client bietet Framework Studio auch einen HTML-Client für Desktop- sowie mobile Geräte an. Dieser befindet sich aktuell in der Beta-Phase und unterstützt noch deutlich weniger Funktionen und Controls als der Java Client. Was derzeit schon mit dem HTML-Client möglich ist, erfahren Sie in diesem Kapitel. Aktivieren des HTML-Clients Damit der HTML-Client über den Run Wizard und die Broker-Startseite gestartet werden kann, muss in der Application die Checkbox Supports Html Client gesetzt werden. Dies soll vermeiden, dass bisher existierende Applikationen ohne Weiteres im HTML-Client gestartet werden können, da diese sehr wahrscheinlich auf Controls und Funktionalitäten aufbauen, die derzeit vom HTML-Client noch nicht oder nicht vollständig unterstützt werden. Browser-Unterstützung Desktop Der HTML-Client basiert auf modernster Webtechnologie und benötigt deshalb auch einen aktuellen Browser für die Ausführung. Für Desktopsysteme empfehlen wir folgende Browser : Chrome Firefox Edge Safari (OSX) Auch alle weiteren Browser, basierend auf der Chromium-Engine (Opera, Vivaldi), funktionieren problemlos. Note Internet Explorer 11 kann auf Grund der betagten JavaScript-Engine nicht mehr verwendet werden. Mobile Endgeräte Eine auf den HTML-Client ausgelegte Applikation kann über die Broker-Startseite natürlich auch von einem beliebigen mobilen Gerät aus gestartet werden, welches über einen aktuellen Browser verfügt. Die Unterstützung der Browser im mobilen Umfeld ist sehr schwer zu beurteilen, da es gerade auf Android eine extrem große Auswahl gibt. Wir empfehlen deshalb folgende mobilen Browser : Chrome Firefox Edge Dolphin Android Browser (ab Android 5.1) Safari (ab iOS 10)"
  },
  "doc/konzepte/fs-types.html": {
    "href": "doc/konzepte/fs-types.html",
    "title": "FS-Datentypen",
    "keywords": "FS-Datentypen FS-Datentypen verhalten sich fast genauso wie die .NET-Datentypen mit ähnlich lautenden Namen. Der Unterschied zu den .NET-Datentypen besteht darin, dass sie einen Null-Wert verstehen. Die FS-Datentypen sind die Basis für die Metadatentypen. Sie können aber auch als Datentyp für Properties oder einfach frei im Code verwendet werden. Sie sollten immer dann verwendet werden, wenn die Null-Information nicht verloren gehen darf. Mit diesen Datentypen ist es möglich, Null-Werte aus einer Datenbank auszuwerten und auch wieder in die Datenbank zurückzuschreiben. Außerdem können z.B. Datenfelder in Forms, die eine Zahl oder ein Datum enthalten, komplett leer sein, was z.B. bei Suchfeldern wichtig ist. Bei den FS-Datentypen handelt es sich ebenfalls um Structs. Die Wertzuweisungen zwischen verschiedenen FS-Datentypen erfolgen also ByValue – wie bei den .NET-Datentypen auch. Variablen und Properties von einem FS-Datentyp können genauso verwendet werden wie Variablen und Properties von .NET-Datentypen. Es können auch Zuweisungen zwischen den verschiedenen Datentypen erfolgen. Es erfolgt in den meisten Fällen eine implizite Konvertierung der Datentypen. Die Null-Information geht dabei aber verloren. Properties der FS-Datentypen Value: (Property) Wert des FS-Datentyps als .NET-Datentyp. D.h.: FSdecimal.Value liefert einen Wert vom Typ dezimal. Dieser Wert kann sowohl gelesen als auch geschrieben werden. Ist der Wert der Variable Null, liefert Value den in der folgenden Tabelle angegebenen Wert aus der Spalte Null-Value zurück. Das Setzen des Wertes der Variable auf einen Null-Value hat aber nicht zur Folge, dass die Variable Null wird. Einzige Ausnahme ist FSstring: IsNull bedeutet Value=““ und Value=““ bedeutet IsNull. Beispiel: FSdecimal decVar1 = 0; // Wert auf 0 oder Null prüfen if (decVar1.Value == 0) { … } // Variante ohne Value if (decVar1.IsNull || decVar1 == 0 ) { … } // Wert zuweisen: decVar1 = 5; //oder decVar1.Value = 5; IsNull (Property) Ist vom Typ bool . Gibt an, ob der Wert der Variable Null ist. Um einem FS-Datentypen explizit ein Null zuzuweisen, gibt es zwei Möglichkeiten: Sie weisen dem Property IsNull true zu, oder Sie weisen der Variable FSxxx.Null zu FSdecimal decVar1 = 0; // Wert nur auf Null prüfen if (decVar1.IsNull) { … } // Wert auf Null setzen decVar1.IsNull = true; // oder decVar1 = FSdecimal.Null; Null (Statisches Property) Liefert eine Variable mit einem Null-Wert. // Variable mit Null initialisieren FSdecimal decVar2 = FSdecimal.Null; Es folgt eine Tabelle mit allen FS-Datentypen und deren Null-Value. .NET-Datentyp FS-Datentyp Null-Value bool FSBool false byte FSbyte 0 DateTime FSDateTime DateTime.MinValue decimal FSdecimal 0 double FSdouble 0 float FSfloat 0 int FSint 0 long FSlong 0 short FSshort 0 string FSstring String.Empty HasValue (Property) Ist vom Typ bool . Man kann mit IsNull prüfen, ob ein FSType ( FSstring , FSdecimal , …) null ist. Wenn das Gegenteil geprüft werden soll, kann das Property HasValue verwendet werden. So wird der Code deutlich lesbarer, vor allem dann, wenn das zu prüfende Property tief verschachtelt ist. Beispiel: // herkömmlicher Weg (Das Ausrufezeichen wird schnell überlesen): if (!this.oOrder.oCustomer.sCompany1.IsNull) // neuer Weg: if (this.oOrder.oCustomer.sCompany1.HasValue) FSDateTime.Now Statisches Property am Typ FSDateTime , welches das aktuelle System-Datum sekundengenau zurückgibt. Wenn man mit der Datenbank oder auch mit Benutzer-Eingaben arbeitet, werden in der Regel sekundengenaue Werte verarbeitet. Wenn man mit dem System.DateTime.Now arbeitet, erhält man einen um mehrere Zehnerpotenzen genaueren Wert. Bei Vergleichen mit Benutzereingaben weichen diese dann von System.DateTime.Now ab. Es wird daher empfohlen, alle Daten, die mit dem aktuellen Datum initialisiert werden sollen, mit FSDateTime.Now zu initialisieren. Beispiel: // Variable mit sekundengenauem Wert der aktuellen Zeit initialisieren FSDateTime dtMyDate = FSDateTime.Now; Wenn mit genaueren Werten gearbeitet werden soll, ist die folgende Initialisierung ebenfalls möglich: // Variable möglichst genau mit der aktuellen Zeit initialisieren FSDateTime dtMyAccurateDate = DateTime.Now;"
  },
  "doc/html-client/controls.html": {
    "href": "doc/html-client/controls.html",
    "title": "Controls",
    "keywords": "Controls Symbol Bedeutung + Property oder Event wird vollständig unterstützt - Property oder Event wird nicht unterstützt o Property oder Event wird teilweise unterstützt (Anmerkung beachten) Allgemein Die folgende Auflistung beinhaltet diejenigen Properties und Events, die an allen verfügbaren Controls im HTML-Client vorhanden sind. Properties Name Unterstützt Anmerkung Alignment + BackColor + BorderColor + BorderRadius + BorderThickness + ButtonGroupDataSource + Caption + DockPanel.ItemSize + Font Family - Ist im Client hart definiert auf die Hierarchie Arial -> Helvetica -> Sans-Serif. Font Bold + Font Italic + Font Underline + ForeColor + IsEditable + LabelTemplate + MapEnterToTabAction - Margin + MaxSize + MinSize + Name + Padding + Shortcut - TabStop + ToolTip + Visibility + Events Name Unterstützt OnCanDrop - OnDrag - Form Properties Name Unterstützt BadgeImage DataSource - IsCloseIconVisible + MainMenu - PreferredSize - SymbolImage - Title + VerticalScrollbarOverlay - Events Name Unterstützt OnLoad + OnClose + Dock Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - DockPanelOrientation + Spacing + Events Name Unterstützt OnEnter - OnLeave - Wrap Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - ContentAlignment + InvertFlowDirection + Spacing + WrapArrangement + Events Name Unterstützt OnEnter - OnLeave - Field Panel Properties Name Unterstützt BackgroundImage - BackgroundScaleMode - RowLabelTemplate + SynchronizeColumns + Events Name Unterstützt OnEnter - OnLeave - Field Row Properties Name Unterstützt FieldRowSize + LabelMode + OptimizeGeneratedLabels + Button Properties Name Unterstützt ShowCaption + TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + ImageButton Properties Name Unterstützt BadgeImage DataSource - CaptionAlign - ContextMenu - DataSource - DisabledImage + HighlightImage - Image + MouseOverImage + PressedImage + ScaleMode - ShowCaption + SymbolImage - TabStop + Events Name Unterstützt OnClick + OnEnter + OnLeave + Label Properties Name Unterstützt DataSource + TextAlign + Events Name Unterstützt OnEnter + OnLeave + CheckBox Properties Name Unterstützt DataSource + ShowCaption + Events Name Unterstützt OnClick + OnEnter + OnLeave + Editfield Properties Name Unterstützt Anmerkung DataSource + DisabledBackColor o Wird dynamisch im Client berechnet DisplayLength + Editor o Nur \"PlainText”, \"HTML” wird nicht unterstützt Format + FormatPattern o Funktioniert nur mit Format \"Decimal\" Multiline + PasswordChar + Client generiert ein Password-Feld, wenn gesetzt, das Passwort-Zeichen selbst kann aber nicht geändert werden (in Web Browsern technisch nicht möglich). ScrollBars + SelectionEnd - SelectionStart - TabStop + TextAlign + WordWrap + Events Name Unterstützt OnEnter + OnLeave + OnValidated + ComboBox Properties Name Unterstützt DataSource + DisplayLength + EditStyle + List + ListOrder + MaxDropDownSize + TabStop + Events Name Unterstützt OnEnter + OnLeave + OnSelectionChanged + RadioButton Properties Name Unterstützt CaptionDataSource + DataSourceOnValue + Events Name Unterstützt OnEnter + OnLeave + OnClick + ListView Properties Name Unterstützt DataSource + ItemArrangement + ItemSize + SelectedItems + SelectionMode + SelectorPosition + Spacing + Template + Events Name Unterstützt OnEnter - OnLeave - OnItemActivated + OnItemSelectionChanged +"
  },
  "doc/html-client/lizenzen.html": {
    "href": "doc/html-client/lizenzen.html",
    "title": "Hinweise zu Lizenzen",
    "keywords": "Hinweise zu Lizenzen Timeout Aus technischen Gründen kann der HTML-Client weder im Browser, noch in der App auf einem mobilen Gerät dem Broker mitteilen, dass er beendet wurde. Z.B. kann auf einem Android-Gerät nicht unterschieden werden, ob eine App nur in den Ruhezustand gewechselt hat oder komplett geschlossen wurde. Dies hat zur Folge, dass Broker-Sessions, die von einem HTML-Client aus gestartet wurden, offen bleiben, bis der Broker sie von sich aus verwirft. Diese Zeitspanne beträgt 12 Stunden . ClientID Um dem Verbrauch von Lizenzen entgegen zu wirken, wird im HTML-Client eine ClientID generiert, die den Browser bzw. das mobile Gerät identifiziert und mit zum Broker geschickt wird. Im Browser ist die ClientID eine UUIDv4, die im Code generiert wird, auf mobilen Geräten wird die Cordova-Geräte-ID herangezogen. Über die ClientID kann der Broker den Browser bzw. das mobile Gerät identifizieren und bei einem erneuten Start einer Anwendung diesem die bisherige Lizenz zuordnen. Zusatz für mobile Geräte Die ClientID auf mobilen Geräten ist immer gleich. Ein mobiles Gerät verbraucht am Broker eine Lizenz unabhängig vom Benutzer. Zusatz für Browser Ein Browser hat keinen Zugriff auf das Betriebssystem und den Computer. Die generierte ClientID wird deshalb im sogenannten „Local Storage“ des Browsers gespeichert. Dieser Speicher ist je nach Konfiguration benutzerabhängig. Beispiel: Ist auf einem Computer, den drei Benutzer verwenden, Firefox als Browser installiert, so hat jeder Benutzer seinen eigenen Local Storage. Dies bedeutet, dass jeder Benutzer seine eigene ClientID bekommt und somit auch drei Lizenzen am Broker verbraucht werden. Dies gilt auch, wenn ein Benutzer dieselbe Applikation einmal im Firefox und einmal im Chrome öffnet. Die beiden Browser haben separate Local Storages und verbrauchen somit auch wieder zwei Lizenzen am Broker."
  },
  "doc/mdt/validierung.html": {
    "href": "doc/mdt/validierung.html",
    "title": "Metadatentyp-Validierung",
    "keywords": "Metadatentyp-Validierung Die Einstellungen, die am Metadatentyp zu sehen sind (z.B. Größe, Formatierung, Wertebereich, …), werden bei der Arbeit mit Properties herangezogen, um die Werte zu validieren und ggf. zu korrigieren. Auch der Client nutzt diese Informationen, um falsche Eingaben so früh wie möglich zu unterbinden. Die Zusammenhänge werden durch folgendes Schaubild erläutert: Die folgende Tabelle stellt dar, was passiert, wenn mit einem Wert gearbeitet wird, der denen am Metadatentyp definierten Kriterien nicht entspricht. Einstellung Lesen von Properties aus der Datenbank, die falsche Werte beinhalten Setzen von Properties Client Allgemein Values Value Ranges Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Strings Size Bei zu langen Strings wird auf dieser auf die Size gekürzt. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Uppercase, Lowercase Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Der Text wird ggf. mit ToUpperInvariant() bzw. ToLowerInvariant() korrigiert. Die Eingabe lässt nur Groß- bzw. Kleinbuchstaben zu. Format-Pattern (Regulärer Ausdruck) Es wird FSstring.Null zurückgegeben. Eine Exception wird geworfen. Nach der Eingabe wird der Wert geprüft und es wird eine Fehlermeldung ausgegeben. Es wird zuvor noch versucht, den String mit Uppercase oder Lowercase zu korrigieren, wenn der reguläre Ausdruck selber Uppercase bzw. Lowercase ist. Wenn das funktioniert, dann wird der Wert in Uppercase bzw. Lowercase konvertiert. Numerische Werte Precision Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Die Eingabe wird begrenzt. Scale (bei Dezimal-Zahlen) Der Wert wird „kaufmännisch“ gerundet. Der Wert wird „kaufmännisch“ gerundet. Die Eingabe wird begrenzt. Positive Integer, Negative Integer (bei Ganzzahlen) Es wird ein Null-Wert zurückgegeben. Eine Exception wird geworfen. Das Minus-Zeichen wird bei der Eingabe unterdrückt bzw. automatisch hinzugefügt. Der Java-Client gibt bei der Eingabe eines falschen Wertes die folgenden Fehlermeldungen aus: Wenn das Format-Pattern (der reguläre Ausdruck) verletzt wird: Wenn ein Wertebereich verletzt wird:"
  },
  "doc/mdt/format-pattern.html": {
    "href": "doc/mdt/format-pattern.html",
    "title": "Format-Pattern im Metadatentyp",
    "keywords": "Format-Pattern im Metadatentyp Je nachdem, welcher Datentyp ausgewählt wurde, ändern sich die Einstellungen für das Format-Pattern. Format Pattern für Zeichenketten Bei Zeichenketten können im Format reguläre Ausdrücke eingegeben werden. Die Zeichenketten müssen dann dem definierten regulären Ausdruck entsprechen. Im Java-Client wird bereits bei der Eingabe überprüft, ob die Zeichenkette dem Ausdruck genügt. Format-Pattern für Zahlen Bei Zahlen können gewöhnliche Zahlenformate eingegeben werden. Neben dem Feld Format-Pattern wird eine Beispiel-Zahl für das eingegebene Format dargestellt. Warning Es ist aber zu beachten, dass als Tausender-Trennzeichen das Komma und als Dezimal-Trennzeichen der Punkt dient. Gültige Formate wären z.B. #,##0.00 ergibt 1.234,56 0.00 ergibt 1.234,56 #,##0.00 ’EUR’ ergibt 1.234,56 EUR Format-Pattern für Datum Bei Datum können gewöhnliche Datum-Formate eingegeben werden. Neben dem Feld Format-Pattern wird als Beispiel das aktuelle Systemdatum entsprechend formatiert dargestellt. Der Button Default Values setzt die Werte auf die vom Framework Studio vorgegebenen Standardwerte zurück."
  },
  "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.FrameworkCloseMode.html",
    "title": "Enum FrameworkCloseMode",
    "keywords": "Enum FrameworkCloseMode Definiert den Modus mit dem die Application beendet werden soll. Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Flags] public enum FrameworkCloseMode Fields Name Description Close KeepUserLogin Restart"
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.-ctor.html",
    "title": "Constructor RowVersionInvalidException",
    "keywords": "Constructor RowVersionInvalidException RowVersionInvalidException(String) Declaration public RowVersionInvalidException(string caption) Parameters Type Name Description System.String caption RowVersionInvalidException(String, Exception) Declaration public RowVersionInvalidException(string caption, Exception ex) Parameters Type Name Description System.String caption System.Exception ex"
  },
  "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html": {
    "href": "api/FrameworkSystems.FrameworkExceptions.RowVersionInvalidException.html",
    "title": "Class RowVersionInvalidException",
    "keywords": "Class RowVersionInvalidException Die Component prüft beim Save automatisch, ob der Datensatz auf der Datenbank zwischenzeitlich von einer anderen Instanz geändert wurde – sprich, ob sich der Wert in der Spalte FSROWVERSION geändert hat. Wenn das der Fall ist, dann wird eine diese Exception geworfen. Inheritance System.Object System.Exception FrameworkSystems.FrameworkExceptions.FrameworkException RowVersionInvalidException Namespace : FrameworkSystems.FrameworkExceptions Assembly : FrameworkSystems.FrameworkExceptions.dll Syntax [Serializable] public class RowVersionInvalidException : FrameworkException, ISerializable, _Exception Constructors RowVersionInvalidException(String) RowVersionInvalidException(String, Exception)"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Gibt die Anzahl der enthaltenen Dateien zurück. Declaration public int Count { get; } Property Value Type Description System.Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück. Declaration public IEnumerator<FileFlavorData> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < FileFlavorData > Examples FileListFlavorData oFileListFlavorData = oExternalTransferObject.GetFileListFlavorData(); foreach (FileFlavorData oFileFlavorData in oFileListFlavorData) { String sFileName = oFileFlavorData.Name; // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FileListFlavorData.html",
    "title": "Class FileListFlavorData",
    "keywords": "Class FileListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang die Liste der transportierten Dateien dar. Die Klasse ist enumerierbar ( IEnumerator<FileFlavorData> ) und eine Spezialisierung von FlavorData . Inheritance System.Object FlavorData FileListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FileListFlavorData : FlavorData, IEnumerable<FileFlavorData>, IEnumerable Remarks Die Enumeration enthält (auch im Event OnCanDrop ) immer mindestens ein Objekt vom Typ FileFlavorData . Properties Count Gibt die Anzahl der enthaltenen Dateien zurück. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen Dateien zurück."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.html",
    "title": "Namespace FrameworkSystems.FrameworkBase.AccessControl",
    "keywords": "Namespace FrameworkSystems.FrameworkBase.AccessControl Classes AccessUnit TODO! AUHelper Diese Klasse bietet Methoden und Properties zu den Themen Authentifizierung, Geschäftseinheiten, Laufzeitlizensierung und Packages an. Sie ist über AUHelper zu erreichen. AUHelper.PackageInfo Diese Klasse beinhaltet die Informationen eines Packages. Die Liste der Packages kann mit der Methode GetPackages() ermittelt werden."
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.-ctor.html",
    "title": "Constructor FrameworkProgress",
    "keywords": "Constructor FrameworkProgress FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Declaration public FrameworkProgress(IGlobalObjects global) Parameters Type Name Description IGlobalObjects global"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Id.html",
    "title": "Property Id",
    "keywords": "Property Id Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. Declaration public guid Id { get; } Property Value Type Description FrameworkSystems.FrameworkDataProvider.BaseObjects.guid"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.CanCancel.html",
    "title": "Property CanCancel",
    "keywords": "Property CanCancel CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Declaration public bool CanCancel { get; set; } Property Value Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Canceled.html",
    "title": "Property Canceled",
    "keywords": "Property Canceled Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. Declaration public bool Canceled { get; } Property Value Type Description System.Boolean"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Der Text, der über dem ProgressBar angezeigt werden soll. Declaration public string Text { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.DetailText.html",
    "title": "Property DetailText",
    "keywords": "Property DetailText DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Declaration public string DetailText { get; set; } Property Value Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.MaxValue.html",
    "title": "Property MaxValue",
    "keywords": "Property MaxValue MaxValue Der Maximalwert des Fortschrittsbalken. Declaration public long MaxValue { get; set; } Property Value Type Description System.Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Value.html",
    "title": "Property Value",
    "keywords": "Property Value Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Declaration public long Value { get; set; } Property Value Type Description System.Int64"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.Dispose.html",
    "title": "Method Dispose",
    "keywords": "Method Dispose Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client. Declaration public void Dispose()"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.DisplayMdt.html",
    "title": "Property DisplayMdt",
    "keywords": "Property DisplayMdt DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. Declaration public MLContainer DisplayMdt { get; set; } Property Value Type Description MLContainer"
  },
  "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html": {
    "href": "api/FrameworkSystems.FrameworkControls.ColumnListDataSource.html",
    "title": "Class ColumnListDataSource",
    "keywords": "Class ColumnListDataSource Diese Klasse definiert den List-Datasource einer dynamischen Spalte im Grid ( List ). Inheritance System.Object ColumnListDataSource Namespace : FrameworkSystems.FrameworkControls Assembly : FrameworkSystems.FrameworkControls.dll Syntax public class ColumnListDataSource Constructors ColumnListDataSource() Properties ContainsNullEntry Gibt zurück oder legt fest, ob die Liste einen Null -Entrag enthalten soll. DataSource Gibt den punktseparierten Pfad zu dem Property, das als DataSource verwendet werden soll, zurück oder legt diesen fest. DisplayMdt Gibt den Metadatentyp, der für die Darstellung der Listeneinträge verwendet werden soll, zurück oder legt diesen fest. Aus dem Metadatentyp werden Eigenschaften wie type, size, precision, scale, caption, tool tip, format und so weiter ermittelt. DisplayMember Gibt das Property, was als DisplayMember verwendet werden soll, zurück oder legt dieses fest. ValueMember Gibt das Property, was als ValueMember verwendet werden soll, zurück oder legt dieses fest."
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.ID.html",
    "title": "Field ID",
    "keywords": "Field ID Die eindeutige ID des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly guid ID Returns Type Description FrameworkSystems.FrameworkDataProvider.BaseObjects.guid"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.AssemblyPrefix.html",
    "title": "Field AssemblyPrefix",
    "keywords": "Field AssemblyPrefix Der in der Package-Hierarchie eindeutige Präfix für Klassen- und Assembly-Namen. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string AssemblyPrefix Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html": {
    "href": "api/FrameworkSystems.FrameworkBase.AccessControl.AUHelper.PackageInfo.Name.html",
    "title": "Field Name",
    "keywords": "Field Name Der Name des Packages. Namespace : FrameworkSystems.FrameworkBase.AccessControl Assembly : FrameworkSystems.FrameworkBase.dll Syntax public readonly string Name Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Converter.XmlConverter.XML_NULL.html",
    "title": "Field XML_NULL",
    "keywords": "Field XML_NULL Definiert die String-Repräsentation eines null-Wertes im Xml. Namespace : FrameworkSystems.FrameworkBase.Converter Assembly : FrameworkSystems.FrameworkBase.dll Syntax public const string XML_NULL = \"\" Returns Type Description System.String"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkProgress.html",
    "title": "Class FrameworkProgress",
    "keywords": "Class FrameworkProgress Mit Hilfe eines FrameworkProgress Objektes kann der Client über einen längeren Vorgang auf dem Server informiert werden. Dabei erscheint ein Fortschrittsbalken (engl. progress bar). Die Aktualisierung dessen erfolgt nicht in Echtzeit, da der Client diesbezüglich in kurzen, zeitlichen Abständen Anfragen an den Server schickt. Inheritance System.Object FrameworkProgress Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class FrameworkProgress : IDisposable Remarks Es können auch mehrere FrameworkProgress Objekte zeitgleich verwendet werden. Die angezeigten Balken werden untereinander angeordnet. Examples using(FrameworkProgress progress = new FrameworkProgress(this.Global)) { // gibt an, ob der Cancel-Button überhaupt angezeigt werden soll progress.CanCancel = true; // sonstige Eigenschaften progress.Text = \"Fortschritt ...\"; progress.MaxValue = 1000; for(int i = 0; i <= progress.MaxValue; i++) { // breche ab, falls progress.Canceled = true if(progress.Canceled) { break; } progress.Value = i; progress.DetailText = \"i hat den Wert \" + i; // Aktion ... } } Anzeige auf dem Client: Constructors FrameworkProgress(IGlobalObjects) Der Konstruktor nimmt das Objekt this.Global ( IGlobalObjects ) entgegen, wodurch die aktuelle Client-Session zugeordnet werden kann. Properties CanCancel Wenn diese Eigenschaft true ist, wird im Client ein Button zum Abbrechen des Vorgangs angezeigt. Betätigt der Nutzer diesen Button, so ist die Eigenschaft Canceled auf true . Canceled Wird auf true gesetzt, nachdem der Benutzer am Client den Cancel-Button betätigt hat. Sie kann nicht zurückgesetzt werden. Vorraussetzung ist, dass die Eigenschaft CanCancel auf true gesetzt wird. DetailText Der Text, der unter dem ProgressBar angezeigt werden soll. Id Ein Global Unique Identifier, mit dem das FrameworkProgress Objekt eindeutig identifiziert werden kann. MaxValue Der Maximalwert des Fortschrittsbalken. Text Der Text, der über dem ProgressBar angezeigt werden soll. Value Der aktuelle Wert des Fortschrittsbalken. Hierfür muss gelten 0 ≤ Value ≤ MaxValue . Methods Dispose() FrameworkProgress implementiert IDisposable. Nach dem Dispose verschwindet der ProgressBar auf dem Client."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.FillOnDrop.html",
    "title": "Method FillOnDrop",
    "keywords": "Method FillOnDrop FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. Declaration public virtual void FillOnDrop() Remarks Hintergrund: Einige Datenformate bringen unter Umständen sehr große Datenmengen mit sich. Beispielsweise können Dateien sehr groß sein. Daher werden beim ersten Request des Clients ( OnCanDrop ) nur Informationen wie der Speicherort, Name, Größe usw. übertragen und nur dann, wenn der Inhalt tatsächlich im OnDrop benötigt wird (und deshalb FillOnDrop() aufgerufen wurde), werden die ggf. großen Daten ausgelesen und übertragen."
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.FlavorData.html",
    "title": "Class FlavorData",
    "keywords": "Class FlavorData Die Daten, welche am externen Transferobjekt ( ExternalTransferObject ) bei einem Drag&Drop-Vorgang in einem bestimmten Format ( FlavorType ) angeboten werden, werden immer in einem Objekt verpackt, das eine Spezialisierung der abstrakten Klasse FlavorData darstellt. Inheritance System.Object FlavorData FileListFlavorData ImageFlavorData TextFlavorData Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public abstract class FlavorData Remarks Die Klasse bietet die Methode FillOnDrop() . Durch den Aufruf dieser Methode wird gesteuert, dass beim Drop-Vorgang alle Daten vollständig gefüllt werden sollen. Methods FillOnDrop() Durch das Aufrufen der Methode im OnCanDrop Eventhandler wird das System darüber informiert, dass im OnDrop alle zu diesem Flavor zur Verfügung stehenden Daten gefüllt werden sollen. See Also FileFlavorData FileListFlavorData ImageFlavorData TextFlavorData UriListFlavorData"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSbyte.html",
    "title": "Struct FSbyte",
    "keywords": "Struct FSbyte TODO! Summary description for FSbyte. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSbyte : IFSbyte, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Count.html",
    "title": "Property Count",
    "keywords": "Property Count Count Gibt die Anzahl der enthaltenen URIs zurück. Declaration public int Count { get; } Property Value Type Description System.Int32"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.Text.html",
    "title": "Property Text",
    "keywords": "Property Text Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Declaration public override string Text { get; protected set; } Property Value Type Description System.String Overrides TextFlavorData.Text"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.GetEnumerator.html",
    "title": "Method GetEnumerator",
    "keywords": "Method GetEnumerator GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück. Declaration public IEnumerator<string> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < System.String > Examples UriListFlavorData oUriListFlavorData = oExternalTransferObject.GetUriListFlavordata(); foreach (string sUri in oUriListFlavorData) { // ... }"
  },
  "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html": {
    "href": "api/FrameworkSystems.FrameworkBase.DragAndDrop.UriListFlavorData.html",
    "title": "Class UriListFlavorData",
    "keywords": "Class UriListFlavorData Diese Klasse stellt bei einem Drag&Drop-Vorgang eine Liste von URIs (Uniform Resource Identifier) dar. Inheritance System.Object FlavorData TextFlavorData UriListFlavorData Inherited Members FlavorData.FillOnDrop() Namespace : FrameworkSystems.FrameworkBase.DragAndDrop Assembly : FrameworkSystems.FrameworkBase.dll Syntax public class UriListFlavorData : TextFlavorData, IEnumerable<string>, IEnumerable Remarks Die Klasse ist enumerierbar ( IEnumerator<String> ). Diese Klasse ist eine Spezialisierung von TextFlavorData , da der URI-Listen-Flavor ein spezieller Text-Flavor ist. Properties Count Gibt die Anzahl der enthaltenen URIs zurück. Text Wenn der Drag&Drop-Vorgang nur eine URI enthält, gibt dieses Property genau diese URI zurück. Andernfalls ist die Eigenschaft undefiniert. Methods GetEnumerator() Gibt einen Enumerator zum Iterieren durch die enthaltenen URIs zurück."
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.GetArgumentFSlong.html",
    "title": "Method GetArgumentFSlong",
    "keywords": "Method GetArgumentFSlong GetArgumentFSlong(String) Declaration public FSlong GetArgumentFSlong(string key) Parameters Type Name Description System.String key Returns Type Description FSlong"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkOnLinkClickEventArgs.html",
    "title": "Class FrameworkOnLinkClickEventArgs",
    "keywords": "Class FrameworkOnLinkClickEventArgs TODO: muss noch genauer beschrieben werden Inheritance System.Object System.EventArgs FrameworkSystems.FrameworkStudio.DevFormBase.EventTab.FrameworkEventArgs FrameworkOnLinkClickEventArgs Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.EventTab Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public class FrameworkOnLinkClickEventArgs : FrameworkEventArgs Methods GetArgumentFSlong(String)"
  },
  "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html": {
    "href": "api/FrameworkSystems.FrameworkBase.FrameworkFormatMask.html",
    "title": "Enum FrameworkFormatMask",
    "keywords": "Enum FrameworkFormatMask TODO! (auch die einzelnen Formate mit Beispielen beschreiben) Namespace : FrameworkSystems.FrameworkBase Assembly : FrameworkSystems.FrameworkBase.dll Syntax public enum FrameworkFormatMask Fields Name Description DateOnlyLong DateOnlyMedium DateOnlyShort DateTimeLong DateTimeMedium DateTimeShort Decimal Integer LowerCase NegativeInteger None PositiveInteger TimeOnlyLong TimeOnlyMedium TimeOnlyShort UpperCase UserDefined"
  },
  "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html": {
    "href": "api/FrameworkSystems.FrameworkStudio.DevFormBase.Data.ComboEditStyle.html",
    "title": "Enum ComboEditStyle",
    "keywords": "Enum ComboEditStyle TODO! Namespace : FrameworkSystems.FrameworkStudio.DevFormBase.Data Assembly : FrameworkSystems.FrameworkStudio.DevFormBase.dll Syntax public enum ComboEditStyle Fields Name Description FreeTextInput ListValuesInput"
  },
  "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html": {
    "href": "api/FrameworkSystems.FrameworkBase.Metadatatype.FSdecimal.html",
    "title": "Struct FSdecimal",
    "keywords": "Struct FSdecimal TODO! Summary description for FSdecimal. Implements IFSType Namespace : FrameworkSystems.FrameworkBase.Metadatatype Assembly : FrameworkSystems.FrameworkBase.dll Syntax [Serializable] [ComVisible(false)] [DataContract] public struct FSdecimal : IFSdecimal, IFSType, IComparable, IConvertible Remarks Siehe auch: FS-Datentypen"
  }
}