<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Registerkarte Properties </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Registerkarte Properties ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/fs-docfx.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="registerkarte-properties">Registerkarte Properties</h1>

<p><img src="media/registerkarte-properties.png" alt="Component Registerkarte Property"></p>
<h2 id="neue-properties-anlegen">Neue Properties anlegen</h2>
<p>Die Properties werden in der Class-Registerkarte angezeigt. 
Hier können neue Properties angelegt werden. 
Das können Sie über den Button (<strong>New</strong>) mit dem Eintrag <strong>Property</strong> bzw. <strong>Membervariable</strong> oder über das Kontext-Menü der Component (<strong>New / Property</strong> bzw. <strong>New / Membervariable</strong>) machen. 
Eine dritte Möglichkeit besteht darin, eine Component direkt per Drag &amp; Drop aus dem <strong>Namespace Treeview</strong> auf die Property Tabelle zu ziehen.</p>
<p>Drag&amp;Drop von Components</p>
<p><img src="media/registerkarte-properties-dragondrop.png" alt="Component Registerkarte Property"></p>
<p>Das Property wird angelegt und zugleich im Component-Fenster angezeigt.</p>
<h2 id="properties-löschen">Properties löschen</h2>
<p>Properties werden ebenfalls über die Registerkarte <strong>Class</strong> gelöscht. Wählen Sie das zu löschende Property aus und anschließend aus dem Kontext-Menü den Eintrag <strong>Delete</strong>.</p>
<h2 id="properties-kopieren">Properties kopieren</h2>
<p>Sie können ein Property in eine andere Komponente, in ein anderes Form kopieren oder innerhalb der Komponente duplizieren. Dazu wählen Sie das gewünschte Property in der Property-Liste aus. Anschließend verwenden Sie entweder die Standardtastenkürzel Strg+C, Strg+V und Strg+X oder das Kontextmenü, um den gewünschten Kopiervorgang durchzuführen.</p>
<h2 id="properties-bearbeiten">Properties bearbeiten</h2>
<p>Sie können ein Property öffnen, indem Sie einen Doppelklick auf den Eintrag in der Class-Registerkarte machen. Alternativ können Sie auch im Component-Fenster auf der Registerkarte Property in der Tabelle das gewünschte <strong>Property</strong> auswählen.</p>
<p>Die Properties werden in der Tabelle sortiert, wenn Sie auf die Spaltenüberschrift des gewünschten Sortierkriteriums anklicken.</p>
<h4 id="name">Name</h4>
<p>Bezeichnung des Properties. Über diesen Namen wird das Property im Code angesprochen.</p>
<h4 id="access-level">Access Level</h4>
<p>Legen Sie hier das Access-Level des Properties fest. Die Angabe ist analog zum .NET-Standard.</p>
<h4 id="datatype">Datatype</h4>
<p>Siehe <a href="#datentyp-bearbeiten">Datentyp bearbeiten</a></p>
<h4 id="useinterface">UseInterface</h4>
<p>Es besteht die Möglichkeit, ein Property, welches als Datatype eine Component eingestellt hat, als Interface einzubinden, um zirkulare Referenzen zu umgehen.</p>
<p>Wenn man an einer Component ein Property anlegt und dabei als Typ eine Component aus einem anderen Namespace verwendet, dann wird bei diesem Property automatisch die Eigenschaft <strong>UseInterface</strong> gesetzt.</p>
<h4 id="property-type">Property Type</h4>
<p>Folgende Typen stehen zur Auswahl:</p>
<p>• Membervariable
• Generated
• Generated (readonly)
• Individual
• Individual (readonly)
• und Relation.</p>
<p>Diese Typen werden weiter unten genauer beschrieben.</p>
<h4 id="mapping">Mapping</h4>
<p>Diese Spalte gibt das Mapping (die Verbindung) des Properties zur Query an. In der Combobox stehen hier alle Spalten (Alias) der Query zur Auswahl.</p>
<h4 id="registerkarte-description">Registerkarte Description</h4>
<p>Hier kann eine Beschreibung zum Property angegeben werden.</p>
<h4 id="registerkarten-get-method--set-method">Registerkarten Get Method / Set Method</h4>
<p>Siehe Individual / Individual (readonly) Properties</p>
<h4 id="registerkarten-depends-on--loadcommand">Registerkarten Depends On / LoadCommand</h4>
<p>Siehe Relation Properties</p>
<h3 id="registerkarte-default-label">Registerkarte Default Label</h3>
<p>Hier suchen Sie die Bezeichnung des Felds im Form aus. Sie können wählen, ob Sie die Bezeichnung aus der Database-Table bzw. dem Metadatentypen oder eine eigene Bezeichnung nehmen möchten. Die Bezeichnungen sind hierarchisch aufgebaut und können in den aufeinander aufbauenden Ebenen überschrieben werden.</p>
<p>Metadatatype-Labels können durch die Database-Labels überschrieben werden, Database-Labels durch die Component-Labels, Component-Labels durch die Form-Labels. Ist in einer tieferen Ebene ein Label vergeben worden, wird dieses angezeigt.</p>
<h3 id="registerkarte-control-types">Registerkarte Control Types</h3>
<p>Sie haben die Möglichkeit, ein Standard-Control zu definieren bzw. ein zusätzliches Control hinzuzufügen. Soll es ein Editfield, eine Combobox etc. sein?</p>
<h2 id="datentyp-bearbeiten">Datentyp bearbeiten</h2>
<p>Die Eingabe des Datentyps erfolgt über ein Textfeld mit Auto-Vervollständigung. Beim Anlegen neuer Properties wird der zuletzt ausgewählte Datentyp vorbelegt.</p>
<p>Diese Angabe kann nicht geändert werden, wenn dieses Property ein Mapping hat. Dann wird der Metadatentyp aus der entsprechenden Database-Column gezogen.</p>
<p>:::image type=&quot;content&quot; source=&quot;media/registerkarte-properties-datentyp.png&quot; alt-text=&quot;datatype&quot;:::</p>
<p>Tippen Sie einfach den Namen des gewünschten Datentyps ein. Elemente, die mit dem eingegebenen Text beginnen, werden in der Auto-Vervollständigungsliste angezeigt und können über die Pfeiltasten oder per Maus ausgewählt werden. </p>
<p>Wenn Sie den Namen eines Namespaces angeben und anschließend einen Punkt eingeben, wird die Auswahl der Vorschläge auf diesen Namespace eingeschränkt. Beispiel: „Sales.cd“ liefert alle Elemente aus dem Sales Namespace, die mit cd beginnen.</p>
<p>Durch Verwendung des Platzhalters „%“ können Sie angeben, dass die Ergebnisse nicht mit dem danach folgenden Text anfangen müssen, sondern der Text lediglich enthalten sein muss. Beispiel: „sales.%ordertype“ liefert alle Elemente aus dem Sales Namespace, deren Name ordertype enthält, also z.B. cdOrderType.</p>
<p>Wird die TextBox verlassen, wird der Name des ausgewählten Elements durch den vollständig referenzierenden Namen ersetzt.</p>
<div class="WARNING"><h5>Warning</h5><ul>
<li><p>Beim ersten Verwenden der Textbox kann es einige Sekunden dauern, bis der interne Speicher mit allen Elementen gefüllt ist.</p>
</li>
<li><p>Es werden maximal 100 Vorschläge angeboten.</p>
</li>
</ul>
</div>
<h2 id="externe-typen">Externe Typen</h2>
<p><img src="media/registerkarte-properties-externtyp.png" alt="registerkarte-properties-externtyp"></p>
<p>Properties von Components und Data Contracts sowie Membervariablen von Forms können externe Datentypen zugewiesen werden. Wird die CheckBox „External Type“ gesetzt, wird die Autovervollständigung des Datatype-Textfeldes deaktiviert und ein beliebiger Typ kann angegeben werden (im Beispiel <code>List&lt;List&lt;int&gt;&gt;</code> ).</p>
<p>Dies bietet sich z.B. an, wenn in einem Namespace mit externen Assemblies gearbeitet wird, deren Klassen als Datentypen von Properties verwendet werden sollen.</p>
<p>Im IntelliSense wird beim Aufruf eines solchen Properties „object“ angezeigt, da im Hintergrund mit „object“ gearbeitet wird. Das Property „lstTest“ aus dem Beispiel kann aber z.B. trotzdem so verwendet werden:</p>
<pre><code class="lang-csharp">int i = this.lstTest[0][1]; // Der Wert von i ist danach 2
</code></pre><h3 id="membervariablen">Membervariablen</h3>
<p>Bei diesem Typ wird kein Property, sondern eine Membervariable erzeugt. Membervariablen haben keine get- und keine set-Methode.</p>
<p>Sie sollten nur mit dem Access-Level <strong>private</strong> versehen werden, um eine externe Manipulation zu unterbinden, da keinerlei Sicherungsmöglichkeiten nach außen definiert werden können.</p>
<p>Eine Membervariable wird nicht im <strong>Form-Designer</strong> angeboten. Sie sollte nur zum Merken von Informationen innerhalb der Komponente verwendet werden.</p>
<h3 id="generated--generated-readonly-properties">Generated / Generated (readonly) Properties</h3>
<p>Die get- und set-Methode für das Property wird automatisch generiert, kann aber auch überdefiniert werden. Dazu muss die Checkbox <strong>Write Individual</strong> auf der Registerkarte <strong>Get Method</strong> bzw. <strong>Set Method</strong> gesetzt werden. In Getter und Setter kann mit der Hintergrundvariable this.PropertyNameValue gearbeitet werden. In Customizations sollte mit base.PropertyName gearbeitet werden, damit Getter und Setter aus dem Basis-Package nicht ausgehebelt werden.</p>
<p>In der Component wird auch der Original-Wert des Properties gespeichert. Wird dem Property ein Wert zugewiesen, der vom Original-Wert abweicht, wird der Status der Component auf <strong>Changed</strong> gesetzt.</p>
<p>Der Original-Wert kann mit <strong>PropertynameOrgValue</strong> abgefragt werden.</p>
<pre><code class="lang-csharp">this.prop = „abc“;
if (this.prop != this.propOrgValue )
{ /*Wert hat sich geändert*/ }
</code></pre><p>Ist <strong>Generated (readonly)</strong> ausgewählt, steht für das Property nur die get-Methode zur Verfügung. Auf das Property kann somit nur lesend zugegriffen werden. Bei einer Wertzuweisung an das Property liefert der Compiler eine Fehlermeldung.</p>
<p>Hat das Property ein Mapping, verwalten die generierten get- und set-Methoden das Resultset der Query.</p>
<p>Ohne Mapping wird eine versteckte private Variable verwaltet.</p>
<p>Properties mit einem Mapping können nur auf <strong>Generated</strong> oder <strong>Generated (readonly)</strong> stehen. Ist in der Query die Spalte ’Readonly’ gecheckt, ist sogar nur <strong>Generated (readonly)</strong> möglich.</p>
<h3 id="individual--individual-readonly-properties">Individual / Individual (readonly) Properties</h3>
<p>Bei diesen Typen können/müssen Sie die get- und die set-Methode manuell ausprogrammieren. Es werden in den Registerkarten <strong>Get Property</strong> und <strong>Set Property</strong> die entsprechenden Code-Felder aktiv. Der Aufruf des Setters führt nicht dazu, dass der Status der Component geändert wird.</p>
<p>Bei <strong>Individual (readonly)</strong> wird nur das Code-Feld für die get-Methode aktiv.</p>
<div class="WARNING"><h5>Warning</h5><p>Achten Sie darauf, dass eine Get-Methode immer einen Rückgabewert vom Typ des Properties besitzen muss.</p>
</div>
<p>Folgende 3 Anwendungsfälle sind denkbar (Beispiel):</p>
<p><strong>1.Fall:</strong></p>
<p>Sie haben z.B. einen Generated Property Status, und wollen in einem weiteren Property den Text zum Status ausgeben. Dann empfiehlt sich ein Individual (readonly) Property.</p>
<p>Die get-Methode könnte folgendermaßen aussehen:</p>
<pre><code class="lang-csharp">if (this.Status == 1) return „offen“;
else if (this.Status == 2) return “erledigt”;
else return “”;
</code></pre><p><strong>2. Fall:</strong></p>
<p>Sie haben ein <strong>Generated Property</strong> vom Typ string, wollen aber ein int Property haben, mit dem Sie im Code arbeiten. Mit einem Individual Property können Sie dieses entsprechend verpacken:</p>
<p>Generated Property sType vom Typ string (z.B. mit einer Column aus der Query verbunden).</p>
<p>Individual Property intType vom Typ int:</p>
<p>get-Methode:</p>
<pre><code class="lang-csharp">return Convert.ToInt32( this.sType );
</code></pre><p>set-Methode:</p>
<pre><code class="lang-csharp">this.sType = Convert.ToString( value );
</code></pre><p><strong>3. Fall:</strong></p>
<p>Sie wollen ein Property anbieten, das nur bei Bedarf instanziiert und gefüllt wird. Dazu müssen Sie zum einen ein <strong>Individual (readonly)</strong> Property (z.B. oComp) anlegen und zum zweiten eine private <strong>Membervariable</strong> (z.B. oCompMember), die den nachgelesen Wert merkt, damit das Einlesen nur einmal erfolgt (Property und Membervariable müssen denselben Typ haben).</p>
<p>get-Methode:</p>
<pre><code class="lang-csharp">if (this.oCompMember == null)
{
    this.oCompMember = new cComp( this.Global );
    oCompMember.Load ( );
}
return oCompMember
</code></pre><h3 id="relation-properties">Relation Properties</h3>
<p>Die Relations dienen dazu, Ihre Komponenten miteinander zu verbinden. Wenn Sie z.B. einen Auftrag und einen Kunden haben, ist es in der Regel so, dass der Auftrag eine Kundennummer hat, die angibt, welcher Kunde den Auftrag erteilt hat.</p>
<p>Relations stellen eine Möglichkeit dar, diese beiden Komponenten miteinander zu verbinden. Dazu wird im Auftrag ein Property Kunde angelegt. Dieses Property muss dem Typ Relation entsprechen. Anschließend müssen noch Angaben darüber gemacht werden, wie die beiden Komponenten miteinander verbunden sind.</p>
<div class="WARNING"><h5>Warning</h5><p>Achten Sie darauf, dass als Datatype eine Component ausgewählt ist, da Sie andernfalls Relation nicht als Property Type auswählen können.</p>
</div>
<h4 id="registerkarten-get-method-und-set-method">Registerkarten Get Method und Set Method</h4>
<p><strong>Analog zu Generated Properties <a href="#generated--generated-readonly-properties">Generated / Generated (readonly) Properties</a> Properties:) kann bei Bedarf zusätzlich individueller Code, der beim Setzen und Auslesen des Properties durchlaufen werden soll, programmiert werden.</strong></p>
<h4 id="registerkarte-depends-on">Registerkarte Depends On</h4>
<p>Auf dieser Registerkarte können Sie angeben, welches Property aus dem Auftrag mit welchem Property aus dem Kunden verbunden werden soll. Sie geben also eine Schlüsselbeziehung an, ähnlich wie Sie das auf einer relationalen Datenbank tun würden. Sie können auch mehrere Properties miteinander verknüpfen, wenn sich der Schlüssel aus mehreren Properties zusammensetzt.</p>
<h4 id="button-add">Button Add</h4>
<p>Fügt ein weiteres Property in die Relation ein. In der Tabelle wird eine neue Zeile angelegt und Sie definieren, welches Property mit welchem wie verknüpft werden soll.</p>
<h4 id="button-remove">Button Remove</h4>
<p>Löscht die markierte Zeile aus der Relation.</p>
<h4 id="spalte-depends-on-property">Spalte Depends on Property</h4>
<p>Hier wird das Property auf der Seite Component, in der Sie sich gerade befinden, angegeben. Im Beispiel wäre das ein Property des Auftrags, z.B. die „Kundennnr“.</p>
<h4 id="spalte-compare-operator">Spalte Compare Operator</h4>
<p>Gibt an, mit welchem Operator die Properties verknüpft werden sollen.</p>
<h4 id="spalte-oxxxproperty">Spalte oXXX.Property</h4>
<p>Gibt an, mit welchem Property der eingebundenen Component das eigene Property verknüpft werden soll. Im Beispiel wäre das evtl. „Kunde.Kundennr“.</p>
<h4 id="spalte-generated-load-condition">Spalte Generated Load Condition</h4>
<p>Zeigt die aus den anderen Spalten entstandene Suchbedingung an.</p>
<h4 id="registerkarte-load-command">Registerkarte Load Command</h4>
<p>Mit den Angaben auf der Registerkarte <strong>Depends On</strong> wird Code generiert, der für das Nachlesen der Daten (hier der Kundendaten) zuständig ist. Diesen Code können Sie überschreiben, wenn Sie eine eigene Logik wünschen.</p>
<p>Sind alle Angaben gemacht, wird die Relation erst beim ersten Zugriff nachgelesen. Dabei werden die gemachten Angaben berücksichtigt. Ändern sich die Inhalte der verbundenen Properties, wird erneut ein Load ausgeführt.</p>
<div class="WARNING"><h5>Warning</h5><p>Derzeit können nur 1:1 Relationen abgebildet werden. D.h. es ist nicht möglich eine Collection als Relation einzubinden.</p>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
